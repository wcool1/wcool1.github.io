<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为什么中国的电话服务没有来电留言？</title>
    <link href="/2025/12/15/Tech/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E7%9A%84%E7%94%B5%E8%AF%9D%E6%9C%8D%E5%8A%A1%E6%B2%A1%E6%9C%89%E6%9D%A5%E7%94%B5%E7%95%99%E8%A8%80/"/>
    <url>/2025/12/15/Tech/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E5%9B%BD%E7%9A%84%E7%94%B5%E8%AF%9D%E6%9C%8D%E5%8A%A1%E6%B2%A1%E6%9C%89%E6%9D%A5%E7%94%B5%E7%95%99%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近看了绝命毒师，其中经常出现“请在哔声后留言”，遂产生这个疑问。后面关于老白为什么会变成这样，除了社会的问题，更多是他自身的性格缺陷，有时间好好聊聊。</p></blockquote><span id="more"></span><p>本质反映了中美在<strong>技术演进路径</strong>、<strong>商业模式</strong>以及<strong>文化习惯</strong>上的巨大差异。</p><p>简单来说，中国的电话服务并非“没有”来电留言（Voicemail）功能（实际上运营商一直提供此业务），而是这项功能在中国“水土不服”，从未真正流行起来，最终被短信和微信等即时通讯工具彻底取代。</p><p>以下是导致这种差异的深层原因：</p><h3 id="1-商业模式与收费策略的差异（最直接原因）"><a href="#1-商业模式与收费策略的差异（最直接原因）" class="headerlink" title="1. 商业模式与收费策略的差异（最直接原因）"></a>1. 商业模式与收费策略的差异（最直接原因）</h3><ul><li><strong>美国（默认开通&#x2F;免费）：</strong><br>在美国，Voicemail 是移动通信套餐中<strong>默认包含</strong>的基础服务，通常是免费的。用户买了手机卡，语音信箱就已经开通了。如果没人接听，电话会自动转入留言。这培养了用户“不接电话就留言”的肌肉记忆。</li><li><strong>中国（付费&#x2F;需要主动开通）：</strong><br>在很长一段时间里，中国移动、中国联通将语音信箱视为一种<strong>增值业务</strong>（Value-Added Service）。</li><li><strong>接收方：</strong> 往往需要每月支付功能费（例如5-10元&#x2F;月）。</li><li><strong>拨打方：</strong> 留言过程被视为“通话中”，需要支付分钟费。<br>这种双向收费或额外收费的门槛，直接扼杀了这项服务在中国普及的可能性。</li></ul><h3 id="2-技术发展的“蛙跳效应”（Leapfrog-Effect）"><a href="#2-技术发展的“蛙跳效应”（Leapfrog-Effect）" class="headerlink" title="2. 技术发展的“蛙跳效应”（Leapfrog Effect）"></a>2. 技术发展的“蛙跳效应”（Leapfrog Effect）</h3><p>中美通讯技术普及的时代背景不同，导致了路径依赖的差异：</p><ul><li><strong>美国：座机时代的延续</strong><br>美国在20世纪70-80年代就已经普及了家庭座机和<strong>电话答录机</strong>（Answering Machine）。“听到‘哔’声后请留言”是几代美国人根深蒂固的习惯。当手机出现时，他们自然而然地将这种习惯带到了移动时代。</li><li><strong>中国：直接跨入短信时代</strong><br>中国家庭座机的普及率远未达到美国的程度，更不用说昂贵的电话答录机了。<br>当中国移动通信开始爆发时（90年代末、2000年初），**寻呼机（BP机）<strong>和随后的</strong>短信（SMS）**迅速普及。</li><li>中国人发现，相比于“听一段模糊不清的留言”，<strong>发短信</strong>更便宜、更直接、也更高效。因此，中国用户直接跳过了“语音留言”阶段，进入了“文字留言”阶段。</li></ul><h3 id="3-文化与沟通习惯的差异"><a href="#3-文化与沟通习惯的差异" class="headerlink" title="3. 文化与沟通习惯的差异"></a>3. 文化与沟通习惯的差异</h3><ul><li><p><strong>“同步” vs “异步”偏好：</strong></p></li><li><p><strong>美国：</strong> 语音留言被视为一种礼貌。如果不接电话也不留言，会被认为“由于某些原因不想说话”或“不重要”。</p></li><li><p><strong>中国：</strong> 中国人更倾向于“即时反馈”。如果你不接电话，我的第一反应是挂断，然后过会儿再打，或者发个短信&#x2F;微信问“现在方便吗？”。</p></li><li><p><strong>对“录音”的心理抗拒：</strong><br>早期中国用户对对着机器说话感到尴尬或不自然。许多人听到“请在滴声后留言”的第一反应是惊慌失措并挂断电话，担心产生高额话费，或者觉得“对着空气说话”很傻。</p></li></ul><h3 id="4-“杀手级”应用的替代：微信-WeChat"><a href="#4-“杀手级”应用的替代：微信-WeChat" class="headerlink" title="4. “杀手级”应用的替代：微信 (WeChat)"></a>4. “杀手级”应用的替代：微信 (WeChat)</h3><p>如果说短信是语音信箱的竞争对手，那么微信就是它的“掘墓人”。</p><ul><li><p><strong>微信语音消息（Voice Message）：</strong> 微信完美替代了语音信箱的功能，而且体验更好。</p></li><li><p>它是免费的。</p></li><li><p>它是可视化的（知道谁发的，多长）。</p></li><li><p>它支持撤回和重听。</p></li><li><p><strong>来电提醒（Call Notify）：</strong> 中国的运营商提供一种替代服务叫“来电提醒”（通常包含在套餐内或很便宜）。如果关机或没信号，开机后会收到一条短信：“X点X分，138xxxx曾呼叫过您”。这对中国用户来说已经足够了——看到短信，回拨过去即可。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>美国的来电留言是<strong>座机文化的残留</strong>，被免费策略延续至今；而中国则因为<strong>高昂的早期资费</strong>和<strong>短信&#x2F;IM技术的快速迭代</strong>，直接进化到了效率更高的“短信&#x2F;微信留言”模式。</p><p>现在，即便是在美国，年轻一代也越来越讨厌Voicemail，甚至出现了“Voicemail phobia”（语音信箱恐惧症），更倾向于Text（发短信）。某种意义上，中国的沟通模式反而在这个层面“领先”了一步。</p>]]></content>
    
    
    <categories>
      
      <category>Tech</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周末北京武汉往返随记</title>
    <link href="/2025/11/24/Life/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E8%AE%B0/"/>
    <url>/2025/11/24/Life/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>日记</p></blockquote><span id="more"></span><p>得益于祖国的高速发展，从北京到武汉只需要在复兴号上睡上一晚，第二天睁眼便抵达了。<br>刚下高铁，南北的气候差异便在一呼一吸之间具象化了。</p><center><img src="/2025/11/24/Life/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E8%AE%B0/IMG_20251122_080702.jpg" style="zoom:15%;margin: 0 auto"><center></center></center>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阅读速度与注意力机制的关系</title>
    <link href="/2025/11/12/Tech/%E9%98%85%E8%AF%BB%E9%80%9F%E5%BA%A6%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2025/11/12/Tech/%E9%98%85%E8%AF%BB%E9%80%9F%E5%BA%A6%E4%B8%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>探究阅读速度与注意力机制的相爱相杀</p></blockquote><span id="more"></span><h1 id="中文阅读效能、专注力机制与神经语言学干预策略深度研究报告：基于220-CPM阅读速率的案例分析"><a href="#中文阅读效能、专注力机制与神经语言学干预策略深度研究报告：基于220-CPM阅读速率的案例分析" class="headerlink" title="中文阅读效能、专注力机制与神经语言学干预策略深度研究报告：基于220 CPM阅读速率的案例分析"></a>中文阅读效能、专注力机制与神经语言学干预策略深度研究报告：基于220 CPM阅读速率的案例分析</h1><h2 id="1-绪论：阅读实验的现象学解构与研究背景"><a href="#1-绪论：阅读实验的现象学解构与研究背景" class="headerlink" title="1. 绪论：阅读实验的现象学解构与研究背景"></a>1. 绪论：阅读实验的现象学解构与研究背景</h2><h3 id="1-1-研究缘起与案例背景"><a href="#1-1-研究缘起与案例背景" class="headerlink" title="1.1 研究缘起与案例背景"></a>1.1 研究缘起与案例背景</h3><p>本研究报告基于用户进行的一项自我量化实验：在10分钟的时间窗口内，受试者完成了2200字的中文阅读任务，计算得出其阅读速率为 <strong>220字&#x2F;分钟（CPM, Characters Per Minute）</strong>。在实验过程中，受试者报告了显著的“思维游荡”（Mind Wandering）现象，即俗称的“分神”或“走神”。受试者提出的核心假设是：这种缓慢的阅读速度是由低下的专注力导致的。</p><p>这一案例并非孤立现象，而是现代知识工作者和学生群体中普遍存在的认知困境的典型代表。在信息过载的时代，高效的信息摄取能力已成为核心竞争力之一。然而，关于“慢速阅读”与“注意力分散”之间的因果关系，公众常识往往存在误区。传统的直觉认为，注意力不集中导致了阅读效率低下，因此解决方案往往指向“训练专注力”。然而，当代认知心理学、神经语言学及眼动研究的证据表明，这种因果关系可能恰恰相反：<strong>阅读速度过慢导致的认知负荷不足（Cognitive Underload），可能是诱发注意力分散的根本原因。</strong></p><h3 id="1-2-报告目的与范围"><a href="#1-2-报告目的与范围" class="headerlink" title="1.2 报告目的与范围"></a>1.2 报告目的与范围</h3><p>本报告旨在对上述案例进行详尽的病理学分析与干预方案设计。我们将超越表层的行为观察，深入大脑的认知控制系统、视觉处理通路及语言解码机制，以回答以下核心问题：</p><ol><li><p><strong>基准诊断</strong>：220 CPM的阅读速度在中文母语者群体中处于何种水平？它揭示了受试者采用了何种底层的阅读策略？</p></li><li><p><strong>机制解析</strong>：专注力低下是阅读慢的原因，还是结果？大脑的默认模式网络（DMN）与任务正激活网络（TPN）在阅读过程中如何相互拮抗？</p></li><li><p><strong>病理探究</strong>：除了专注力，还有哪些隐形的生理或语言学障碍（如全音默读、眼动控制低效、视知觉广度狭窄）限制了阅读速度？</p></li><li><p><strong>干预策略</strong>：基于神经可塑性原理，如何设计科学的训练方案（如视觉引导、舒尔特方格、组块化训练等）来系统性地提升阅读速度并改善专注力？</p></li></ol><p>本报告将整合来自认知心理学、教育心理学、神经科学及阅读科学的最新实证研究数据，为受试者提供一份详实、严谨且具有高度可操作性的深度分析报告。</p><hr><h2 id="2-阅读效能的基准评估与诊断分析"><a href="#2-阅读效能的基准评估与诊断分析" class="headerlink" title="2. 阅读效能的基准评估与诊断分析"></a>2. 阅读效能的基准评估与诊断分析</h2><p>为了准确评估受试者的阅读表现，我们首先必须建立一个基于大样本数据的参照系。中文作为一种表意文字（Logographic system），其阅读机制与拼音文字（如英文）存在显著差异，因此必须依据针对中文母语者的学术研究数据进行对标分析。</p><h3 id="2-1-阅读速率的量化诊断"><a href="#2-1-阅读速率的量化诊断" class="headerlink" title="2.1 阅读速率的量化诊断"></a>2.1 阅读速率的量化诊断</h3><p>受试者的实验数据明确显示其阅读速率为 <strong>220 CPM</strong>。这一数值本身并不具有独立的意义，只有置于不同的阅读模式常模中进行对比，才能揭示其背后的认知机制。</p><h4 id="2-1-1-中文阅读速度常模体系"><a href="#2-1-1-中文阅读速度常模体系" class="headerlink" title="2.1.1 中文阅读速度常模体系"></a>2.1.1 中文阅读速度常模体系</h4><p>根据多项针对中文阅读速度的实证研究 ，我们可以构建如下的分层速度模型：  </p><p><strong>表 1：中文母语者阅读速度分层常模对照表</strong></p><table><thead><tr><th>阅读模式 (Reading Mode)</th><th>速度范围 (CPM)</th><th>典型场景与认知特征</th><th>神经机制描述</th></tr></thead><tbody><tr><td><strong>朗读 (Oral Reading &#x2F; Reading Aloud)</strong></td><td><strong>180 - 260</strong></td><td>公众演讲、播音、儿童识字</td><td>受限于发音器官（舌、唇、喉）的肌肉运动极限；必须经过语音编码回路。</td></tr><tr><td><strong>默读 - 学习型 (Study Reading)</strong></td><td><strong>200 - 350</strong></td><td>阅读教科书、复杂技术文档、需记忆材料</td><td>高认知负荷，伴随频繁的眼动回视（Regression）和深度语义加工。</td></tr><tr><td><strong>默读 - 休闲型 (Casual &#x2F; Rauding)</strong></td><td><strong>400 - 700</strong></td><td>阅读小说、新闻、非虚构类通俗读物</td><td>视觉-语义直达通路（Orthography-to-Semantics）主导；语音中介减弱。</td></tr><tr><td><strong>快速阅读 (Speed Reading &#x2F; Skimming)</strong></td><td><strong>800 - 1500+</strong></td><td>信息检索、略读、概览</td><td>牺牲部分细节理解（如虚词、修饰语），主要抓取核心名词和动词；利用周边视觉。</td></tr><tr><td><strong>受试者当前状态</strong></td><td><strong>220</strong></td><td><strong>典型朗读速度区间</strong></td><td><strong>高度疑似“全音默读”策略；听觉通道主导。</strong></td></tr></tbody></table><p>Export to Sheets</p><h4 id="2-1-2-数据解读：听觉通道的锁定效应"><a href="#2-1-2-数据解读：听觉通道的锁定效应" class="headerlink" title="2.1.2 数据解读：听觉通道的锁定效应"></a>2.1.2 数据解读：听觉通道的锁定效应</h4><p>对比表1数据，我们发现一个惊人的吻合：受试者的 <strong>220 CPM</strong> 几乎完美落在中文母语者的 <strong>平均朗读速度（约 255 ± 29 CPM）</strong> 区间内 。  </p><p>这一数据重合绝非巧合。它强有力地暗示了受试者在进行所谓的“默读”时，其大脑内部的运作模式实际上是“无声的朗读”。在神经语言学中，这被称为 <strong>默读（Subvocalization）</strong> 或 <strong>潜在发音</strong>。</p><ul><li><p><strong>物理瓶颈</strong>：人类的视觉处理速度（眼睛识别图像并传输至大脑）理论上可以非常快（毫秒级），但人类的说话速度受限于口腔肌肉的物理惯性。如果读者习惯于将每一个看到的字都转化为内心的声音，那么阅读速度就会被强制锁定在说话速度的上限上。</p></li><li><p><strong>诊断结论</strong>：受试者的慢速阅读并非因为理解能力差，而是因为<strong>错误地使用了听觉回路来处理视觉信息</strong>。这就像是用步行的速度在高速公路上驾驶跑车，无论引擎（大脑处理能力）多么强大，速度都被限制在了第一档。</p></li></ul><h3 id="2-2-阅读理解与速度的辩证关系"><a href="#2-2-阅读理解与速度的辩证关系" class="headerlink" title="2.2 阅读理解与速度的辩证关系"></a>2.2 阅读理解与速度的辩证关系</h3><p>受试者提到“时间到没读完”。在阅读测试中，速度与理解率（Comprehension Rate）通常呈现倒U型关系。</p><ul><li><p><strong>过快</strong>（&gt;1000 CPM）：对于未受训练者，理解率会急剧下降，出现“眼过脑不过”的现象。</p></li><li><p><strong>过慢</strong>（&lt;300 CPM）：这正是受试者所处的区间。研究表明，过慢的阅读速度不仅不会提高理解率，反而可能<strong>降低</strong>理解率 。这是因为语言是基于短时记忆（Short-term Memory）和工作记忆（Working Memory）的流式处理。如果读取一个句子的前半部分和后半部分的时间间隔过长，工作记忆中的信息会发生衰退（Decay），导致读者读到句末时已经忘记了句首的主语，从而不得不回视重读。这种破碎的阅读体验直接导致了受试者所描述的“没读完”和挫败感。</p></li></ul><p>  </p><hr><h2 id="3-专注力低下的认知心理学机制：归因分析"><a href="#3-专注力低下的认知心理学机制：归因分析" class="headerlink" title="3. 专注力低下的认知心理学机制：归因分析"></a>3. 专注力低下的认知心理学机制：归因分析</h2><p>受试者疑问：“这是不是专注力低下导致？主要原因是什么？”。 基于现代认知心理学模型，我们必须修正这一因果判断。证据显示，<strong>阅读速度慢往往是导致分神的原因（始作俑者），而非仅仅是分神的结果。</strong></p><h3 id="3-1-认知负荷理论（Cognitive-Load-Theory）与“认知欠载”"><a href="#3-1-认知负荷理论（Cognitive-Load-Theory）与“认知欠载”" class="headerlink" title="3.1 认知负荷理论（Cognitive Load Theory）与“认知欠载”"></a>3.1 认知负荷理论（Cognitive Load Theory）与“认知欠载”</h3><p>专注力的维持依赖于适度的认知唤醒水平。这里存在一个类似于经济学中的“供需关系”：</p><ul><li><p><strong>供给端</strong>：大脑的认知处理带宽（Bandwidth）。一个受过教育的成年大脑，在处理母语信息时，具备极高的处理速率（通常远高于说话速度）。</p></li><li><p><strong>需求端</strong>：眼睛输入的文本流速。</p></li></ul><p>当受试者以 220 CPM 的速度阅读时，出现了一种被称为 <strong>认知欠载（Cognitive Underload）</strong> 的状态 。  </p><ul><li><p><strong>机制详解</strong>：假设受试者的大脑每分钟能轻松处理 800 个字的信息量，但眼睛每分钟只提供了 220 个字。这意味着有约 <strong>72.5%</strong> 的认知资源处于“闲置”状态。</p></li><li><p><strong>资源溢出效应</strong>：大脑是一个不允许真空的器官。闲置的认知资源不会自动进入休眠模式，而是会本能地寻找其他刺激来填补空白。这种“溢出”的注意力资源会自动扫描内部环境（如当下的情绪、未完成的任务、身体的感觉）或外部环境（如噪音）。</p></li><li><p><strong>结论</strong>：受试者之所以“经常分神想别的事情”，正是因为<strong>读得太慢，脑子“吃不饱”</strong>。慢速阅读为杂念的入侵提供了充足的认知空间。</p></li></ul><h3 id="3-2-默认模式网络（DMN）与任务正激活网络（TPN）的拮抗"><a href="#3-2-默认模式网络（DMN）与任务正激活网络（TPN）的拮抗" class="headerlink" title="3.2 默认模式网络（DMN）与任务正激活网络（TPN）的拮抗"></a>3.2 默认模式网络（DMN）与任务正激活网络（TPN）的拮抗</h3><p>神经科学研究发现，大脑中存在两个反向相关的神经网络系统：</p><ol><li><p><strong>任务正激活网络（Task Positive Network, TPN）</strong>：当我们专注于执行具体的外部任务（如高强度阅读、解题）时被激活。</p></li><li><p><strong>默认模式网络（Default Mode Network, DMN）</strong>：当我们处于休息、发呆或任务刺激不足时被激活。DMN 负责自我参照思维、回忆过去、规划未来以及社会认知——这正是受试者体验到的“想别的事情” 。</p></li></ol><p>  </p><p><strong>拮抗原理</strong>：TPN 和 DMN 通常是相互抑制的。当任务难度适中且速度够快时，TPN 强力激活，DMN 被深度抑制，人进入“心流”（Flow）状态。然而，当阅读速度过慢（如 220 CPM），任务对大脑的刺激强度不足以维持 TPN 的主导地位，抑制作用减弱，DMN 趁虚而入，导致思维游荡（Mind Wandering） 。  </p><p><strong>从这个角度看，受试者的分神其实是大脑在“无聊”状态下的自我保护机制，试图通过激活 DMN 来维持一定的神经唤醒度。</strong></p><h3 id="3-3-任务价值评估与执行控制衰竭"><a href="#3-3-任务价值评估与执行控制衰竭" class="headerlink" title="3.3 任务价值评估与执行控制衰竭"></a>3.3 任务价值评估与执行控制衰竭</h3><p>根据控制价值理论（Control-Value Theory），执行功能（Executive Function）会持续评估当前任务的“期望价值” 。  </p><ul><li><p><strong>低效的反馈循环</strong>：慢速阅读导致信息获取效率低下，读者长时间得不到新的知识刺激（Reward）。</p></li><li><p><strong>价值阈值</strong>：当大脑判定“继续阅读这句话”的奖励（获得的信息量）低于“思考中午吃什么”的奖励时，执行控制系统会自动切换目标。</p></li><li><p><strong>焦虑的干扰</strong>：受试者提到“时间到没读完”。这种时间压力会诱发焦虑。焦虑本身会占用工作记忆资源（尤其是语音回路），导致处理当前文本的资源更少，理解力下降，进而导致更多的回视和更慢的速度，形成恶性循环 。</p></li></ul><p>  </p><hr><h2 id="4-阅读速度慢的多元病理分析：除此之外的原因"><a href="#4-阅读速度慢的多元病理分析：除此之外的原因" class="headerlink" title="4. 阅读速度慢的多元病理分析：除此之外的原因"></a>4. 阅读速度慢的多元病理分析：除此之外的原因</h2><p>除了“认知欠载”导致的注意力分散外，还有一系列具体的生理和语言学机制共同作用，将受试者的阅读速度限制在 220 CPM。以下分析将回答“阅读速度慢还有别的可能原因吗？”。</p><h3 id="4-1-核心障碍：全音默读（Subvocalization）的生理机制"><a href="#4-1-核心障碍：全音默读（Subvocalization）的生理机制" class="headerlink" title="4.1 核心障碍：全音默读（Subvocalization）的生理机制"></a>4.1 核心障碍：全音默读（Subvocalization）的生理机制</h3><p>这是最主要的技术性障碍。如前文诊断，220 CPM 是典型的声读速度。</p><h4 id="4-1-1-默读的层次"><a href="#4-1-1-默读的层次" class="headerlink" title="4.1.1 默读的层次"></a>4.1.1 默读的层次</h4><p>默读并非全有或全无，而是存在不同的层次 ：  </p><ol><li><p><strong>显性唇读</strong>：嘴唇微动，这是最初级的阅读形式。</p></li><li><p><strong>喉部默读</strong>：嘴唇不动，但声带和喉部肌肉有微弱的肌电活动（EMG）。</p></li><li><p><strong>听觉默读</strong>：肌肉无活动，但在大脑的布罗卡区（Broca’s Area）和韦尼克区（Wernicke’s Area）产生完整的“内心听觉形象”。受试者很可能处于这一层。</p></li><li><p><strong>语义直映</strong>：仅有极其微弱的语音激活，主要依赖视觉皮层与语义网络的直接连接。</p></li></ol><h4 id="4-1-2-中文阅读中的“声调警察”"><a href="#4-1-2-中文阅读中的“声调警察”" class="headerlink" title="4.1.2 中文阅读中的“声调警察”"></a>4.1.2 中文阅读中的“声调警察”</h4><p>对于中文学习者或过于严谨的读者，还存在一种特殊的默读障碍——“声调警察”（Tone Police）现象 。部分读者在内心阅读时，不仅要读出音，还潜意识地强迫自己确认每一个字的声调是否准确。这种对语音精确性的过度强迫（Hyper-correction）会消耗大量的认知资源，使得阅读速度甚至低于正常的说话速度。受试者的 220 CPM 略低于平均语速 255 CPM，这暗示了可能存在这种微观层面的迟疑和确认过程。  </p><h3 id="4-2-眼动控制低效（Oculomotor-Inefficiency）"><a href="#4-2-眼动控制低效（Oculomotor-Inefficiency）" class="headerlink" title="4.2 眼动控制低效（Oculomotor Inefficiency）"></a>4.2 眼动控制低效（Oculomotor Inefficiency）</h3><p>阅读过程在微观上是由一系列**注视（Fixations）<strong>和</strong>眼跳（Saccades）**组成的。低效的眼动模式是慢速阅读的直接物理原因。</p><h4 id="4-2-1-逐字注视（Word-by-Word-Fixation）"><a href="#4-2-1-逐字注视（Word-by-Word-Fixation）" class="headerlink" title="4.2.1 逐字注视（Word-by-Word Fixation）"></a>4.2.1 逐字注视（Word-by-Word Fixation）</h4><p>高效阅读者通常进行“跳读”，即眼跳跨度大，一次注视涵盖多个字。而慢速读者往往表现为<strong>逐字注视</strong>。</p><ul><li><p><strong>数据对比</strong>：</p><ul><li><p><strong>中文平均眼跳幅度</strong>：约 2-3 个汉字 。  </p></li><li><p><strong>受试者推测</strong>：可能接近 1 个汉字&#x2F;次注视。</p></li></ul></li><li><p><strong>后果</strong>：每一次眼跳都需要大脑重新定位，并伴随短暂的视觉阻断（Saccadic Suppression）。如果每读一个字都要停顿一次，大脑在眼动规划上消耗的时间将远超信息处理的时间，极易导致视觉疲劳。</p></li></ul><h4 id="4-2-2-高频回视（Regression）"><a href="#4-2-2-高频回视（Regression）" class="headerlink" title="4.2.2 高频回视（Regression）"></a>4.2.2 高频回视（Regression）</h4><p>回视是指眼球向阅读方向的反方向移动，以重新读取之前的文本。</p><ul><li><p><strong>常模</strong>：熟练读者的回视率约为 10-15%。</p></li><li><p><strong>慢速读者</strong>：回视率可高达 30-40% 。  </p></li><li><p><strong>原因</strong>：除了理解失败外，<strong>强迫性回视</strong>也是常见原因——即读者缺乏自信，总觉得“没看清”，下意识地回去确认。受试者提到的“分神”往往伴随着大量的无意识回视：分神-&gt;漏读-&gt;回视-&gt;焦虑-&gt;更慢。</p></li></ul><h3 id="4-3-视知觉广度（Perceptual-Span）与组块化（Chunking）能力缺失"><a href="#4-3-视知觉广度（Perceptual-Span）与组块化（Chunking）能力缺失" class="headerlink" title="4.3 视知觉广度（Perceptual Span）与组块化（Chunking）能力缺失"></a>4.3 视知觉广度（Perceptual Span）与组块化（Chunking）能力缺失</h3><ul><li><p><strong>视幅狭窄</strong>：未经训练的读者通常过度依赖中央凹（Fovea）视觉（最清晰的中心视野，仅覆盖约2度视角），而忽略了副中央凹（Parafovea）和周边视觉（Peripheral Vision）的信息获取能力 。高效读者利用周边视觉预处理下一个词的字形，从而引导眼跳更准确地落在下一个意群的中心（Optimal Viewing Position）。  </p></li><li><p><strong>组块化失败</strong>：中文阅读高度依赖语境和词组。例如“注意力”这三个字，在高效读者眼中是一个单一的意义单元（Chunk），只需一次注视。而在低效读者眼中，可能是“注-意-力”三个独立的符号。受试者可能缺乏快速识别高频词组和成语的能力，导致大脑必须进行低级的字形解码，无法进行高级的语义合成 。</p></li></ul><p>  </p><h3 id="4-4-文本适应性与外部因素"><a href="#4-4-文本适应性与外部因素" class="headerlink" title="4.4 文本适应性与外部因素"></a>4.4 文本适应性与外部因素</h3><ul><li><p><strong>文本难度</strong>：如果受试者阅读的文章充斥生僻字或专业术语，大脑必须从“自动化加工”切换到“控制性加工”，速度必然下降 。  </p></li><li><p><strong>排版因素</strong>：字体过小、行间距过密或过宽，都会影响眼跳的准确性。</p></li><li><p><strong>生理状态</strong>：疲劳、缺觉会显著延长注视时间（Fixation Duration），降低眼跳速度。</p></li></ul><hr><h2 id="5-综合解决方案与系统训练策略"><a href="#5-综合解决方案与系统训练策略" class="headerlink" title="5. 综合解决方案与系统训练策略"></a>5. 综合解决方案与系统训练策略</h2><p>基于上述深入分析，我们提出一套系统性的改善方案。核心逻辑是：<strong>逆转因果——通过技术手段强制提高阅读速度，从而倒逼专注力的提升，打破“慢-分神-更慢”的恶性循环。</strong></p><h3 id="5-1-第一阶段：物理机制干预——打破默读与优化眼动"><a href="#5-1-第一阶段：物理机制干预——打破默读与优化眼动" class="headerlink" title="5.1 第一阶段：物理机制干预——打破默读与优化眼动"></a>5.1 第一阶段：物理机制干预——打破默读与优化眼动</h3><p>本阶段目标：消除生理限速因素，将速度提升至 400 CPM 以上。</p><h4 id="5-1-1-视觉引导法（Meta-Guiding-The-Pointer-Method）"><a href="#5-1-1-视觉引导法（Meta-Guiding-The-Pointer-Method）" class="headerlink" title="5.1.1 视觉引导法（Meta-Guiding &#x2F; The Pointer Method）"></a>5.1.1 视觉引导法（Meta-Guiding &#x2F; The Pointer Method）</h4><p>这是最立竿见影的物理干预手段。</p><ul><li><p><strong>原理</strong>：利用人眼的“视动反射”（Optokinetic reflex），眼球天然倾向于跟随移动的物体。手指的平滑移动可以消除不必要的微眼跳和回视 。  </p></li><li><p><strong>操作步骤</strong>：</p><ol><li><p><strong>工具</strong>：使用手指、笔尖或鼠标指针。</p></li><li><p><strong>动作</strong>：将引导物放在正在阅读的文字下方。</p></li><li><p><strong>规则</strong>：引导物以<strong>匀速、连续</strong>的方式在行间移动。<strong>引导物绝不停止，绝不回头。</strong></p></li><li><p><strong>速度</strong>：起步阶段，让手指移动的速度略快于你感到舒适的理解速度。迫使眼睛必须加速追赶手指。</p></li><li><p><strong>心态</strong>：接受“理解率暂时下降”的现实。初期只需看清字形，不必强求100%理解。</p></li></ol></li></ul><h4 id="5-1-2-听觉干扰法（Auditory-Distraction-Anti-Subvocalization）"><a href="#5-1-2-听觉干扰法（Auditory-Distraction-Anti-Subvocalization）" class="headerlink" title="5.1.2 听觉干扰法（Auditory Distraction &#x2F; Anti-Subvocalization）"></a>5.1.2 听觉干扰法（Auditory Distraction &#x2F; Anti-Subvocalization）</h4><p>旨在切断视觉与听觉中枢的强耦合 。  </p><ul><li><p><strong>原理</strong>：工作记忆中的语音回路容量有限。如果我们在阅读时主动占用语音回路，大脑就无法同时进行“默读”，从而被迫开辟纯视觉通路。</p></li><li><p><strong>训练方法</strong>：</p><ol><li><p><strong>节奏干扰</strong>：阅读时手指在桌面上轻轻打拍子（如每秒两下，哒-哒-哒）。</p></li><li><p><strong>白噪音&#x2F;音乐</strong>：播放无歌词的器乐（如古典音乐、电子乐）或白噪音。</p></li><li><p><strong>咀嚼法</strong>：阅读时嚼口香糖。这会占用口腔运动皮层，抑制喉部微动作。</p></li><li><p><strong>数数法（高阶）</strong>：阅读时在心里默念“1, 2, 3, 4”或唱一首简单的儿歌。这极其困难，但能彻底阻断对文本的默读。</p></li></ol></li></ul><h3 id="5-2-第二阶段：视知觉能力训练——拓展视幅"><a href="#5-2-第二阶段：视知觉能力训练——拓展视幅" class="headerlink" title="5.2 第二阶段：视知觉能力训练——拓展视幅"></a>5.2 第二阶段：视知觉能力训练——拓展视幅</h3><p>本阶段目标：从“逐字阅读”进化为“组块阅读”，激活周边视觉。</p><h4 id="5-2-1-舒尔特方格（Schulte-Grid）专项训练"><a href="#5-2-1-舒尔特方格（Schulte-Grid）专项训练" class="headerlink" title="5.2.1 舒尔特方格（Schulte Grid）专项训练"></a>5.2.1 舒尔特方格（Schulte Grid）专项训练</h4><p>舒尔特方格是公认的最有效的注意力与视幅训练工具 。  </p><ul><li><p><strong>工具</strong>：一张 5x5 的方格纸，内含 1-25 的乱序数字。</p></li><li><p><strong>标准操作</strong>：</p><ol><li><p>眼睛注视表格<strong>正中心</strong>的方格，保持视线不移动。</p></li><li><p>利用**余光（周边视觉）**按顺序寻找 1, 2, 3… 直到 25。</p></li><li><p>手指指出数字位置，同时大声读出（或默念）。</p></li></ol></li><li><p><strong>进阶要求</strong>：眼睛始终锁定中心，不可随数字移动。这强迫大脑扩大有效视野范围。</p></li><li><p><strong>量化目标</strong>：成年人的及格线约为 25-30 秒。若能训练至 <strong>15秒以内</strong>，其阅读视幅将显著改善，能够轻松实现“一目半行”甚至“一目一行”。</p></li><li><p><strong>训练量</strong>：每天练习 5-10 组，连续 2 周可见显著效果。</p></li></ul><h4 id="5-2-2-意群阅读（Chunking）练习"><a href="#5-2-2-意群阅读（Chunking）练习" class="headerlink" title="5.2.2 意群阅读（Chunking）练习"></a>5.2.2 意群阅读（Chunking）练习</h4><ul><li><p><strong>原理</strong>：训练大脑将多个字识别为一个整体 。  </p></li><li><p><strong>操作</strong>：</p><ul><li><p>在文本上人为画竖线，将每行字切分为 2-3 个组块。例如：“专注力低下的 | 主要原因 | 是什么”。</p></li><li><p>练习时，视线只落在每个组块的<strong>中心点</strong>，利用余光看清两边的字。</p></li><li><p>逐渐增加每个组块的字数（从 3 个字增加到 5-7 个字）。</p></li></ul></li></ul><h3 id="5-3-第三阶段：认知策略干预——重塑专注力"><a href="#5-3-第三阶段：认知策略干预——重塑专注力" class="headerlink" title="5.3 第三阶段：认知策略干预——重塑专注力"></a>5.3 第三阶段：认知策略干预——重塑专注力</h3><p>本阶段目标：解决“分神”的心理诱因，提高任务价值感。</p><h4 id="5-3-1-番茄工作法（Pomodoro-Technique）的改良应用"><a href="#5-3-1-番茄工作法（Pomodoro-Technique）的改良应用" class="headerlink" title="5.3.1 番茄工作法（Pomodoro Technique）的改良应用"></a>5.3.1 番茄工作法（Pomodoro Technique）的改良应用</h4><ul><li><p><strong>原理</strong>：利用时间切片（Timeboxing）来匹配注意力的生理节律，通过设定明确的终点来维持高唤醒度 。  </p></li><li><p><strong>操作</strong>：</p><ul><li><p><strong>短周期</strong>：鉴于受试者专注力较弱，建议从 <strong>15分钟</strong> 开始，而非标准的25分钟。</p></li><li><p><strong>全神贯注</strong>：在这15分钟内，即使看不懂也不许停，不许回视，不许做任何与阅读无关的事。</p></li><li><p><strong>强制休息</strong>：时间一到，必须停止阅读，休息 3-5 分钟。</p></li><li><p><strong>记录</strong>：每完成一个番茄钟，打一个勾。这种即时反馈能提供多巴胺奖励。</p></li></ul></li></ul><h4 id="5-3-2-主动阅读与元认知监控（Metacognitive-Strategies）"><a href="#5-3-2-主动阅读与元认知监控（Metacognitive-Strategies）" class="headerlink" title="5.3.2 主动阅读与元认知监控（Metacognitive Strategies）"></a>5.3.2 主动阅读与元认知监控（Metacognitive Strategies）</h4><ul><li><p><strong>SQ3R 策略</strong>（Survey, Question, Read, Recite, Review）的简化版 。  </p><ul><li><p><strong>预读（Previewing）</strong>：在开始精读前，花 1 分钟快速浏览标题、小标题、粗体字、开头和结尾。建立文章的宏观结构。</p></li><li><p><strong>提问（Questioning）</strong>：读之前先问自己：“这篇文章想解决什么问题？”“作者的核心观点是什么？”</p></li><li><p><strong>带着问题去“搜索”</strong>：将阅读模式从“被动接收”转变为“主动搜索”。当大脑在寻找猎物（答案）时，它是不可能分神的。</p></li></ul></li><li><p><strong>段落概括</strong>：每读完一个段落，强迫自己停顿 1 秒，用一个词或一句话概括大意 。这能确保大脑始终在线。</p></li></ul><p>  </p><hr><h2 id="6-训练计划建议（8周改善方案）"><a href="#6-训练计划建议（8周改善方案）" class="headerlink" title="6. 训练计划建议（8周改善方案）"></a>6. 训练计划建议（8周改善方案）</h2><p>为了确保效果，建议受试者按照以下渐进式计划执行：</p><table><thead><tr><th>阶段</th><th>周期</th><th>核心目标</th><th>每日训练内容 (约30分钟)</th><th>预期成果</th></tr></thead><tbody><tr><td><strong>启动期</strong></td><td><strong>第 1-2 周</strong></td><td><strong>打破默读</strong></td><td>1\. <strong>视觉引导阅读</strong> (15 min)：手指强行引导，速度设定为“略微跟不上”。 2\. <strong>听觉干扰</strong> (10 min)：阅读时播放白噪音或打拍子。 3\. <strong>舒尔特方格</strong> (5 min)：每天5次，记录时间。</td><td>阅读速度突破 <strong>300 CPM</strong>。初期可能会感到理解率下降和不适，这是正常的脑神经重塑过程。</td></tr><tr><td><strong>突破期</strong></td><td><strong>第 3-4 周</strong></td><td><strong>拓展视幅</strong></td><td>1\. <strong>意群阅读练习</strong> (15 min)：尝试一眼看3-5个字，减少眼跳。 2\. <strong>舒尔特方格进阶</strong> (10 min)：尝试达到20秒&#x2F;次。 3\. <strong>番茄阅读法</strong> (20 min)：进行高强度专注阅读。</td><td>舒尔特方格进入 <strong>20秒</strong>。阅读时不再逐字扫描，眼动更加平滑。速度达到 <strong>450 CPM</strong>。</td></tr><tr><td><strong>巩固期</strong></td><td><strong>第 5-8 周</strong></td><td><strong>深化理解</strong></td><td>1\. <strong>主动阅读实战</strong> (30 min)：应用预读、提问策略。 2\. <strong>变速阅读</strong>：先快读略读，再慢读精读，自由切换。 3\. <strong>定期自测</strong>：每周末进行一次10分钟测速。</td><td>建立全新的阅读习惯。速度稳定在 <strong>500-700 CPM</strong>。分神现象显著减少，进入“心流”状态。</td></tr></tbody></table><p>Export to Sheets</p><hr><h2 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h2><p>通过对受试者“10分钟2200字”实验数据的深度剖析，本报告得出以下核心结论：</p><ol><li><p><strong>诊断明确</strong>：220 CPM 的阅读速度是典型的<strong>朗读速度</strong>，表明受试者受到严重的**全音默读（Subvocalization）<strong>习惯和</strong>逐字注视（Word-by-Word Fixation）**模式的限制。这属于阅读策略层面的技术性低效，而非智力或理解力问题。</p></li><li><p><strong>因果修正</strong>：<strong>专注力低下并非导致阅读慢的根本原因，相反，过慢的阅读速度导致的“认知欠载”才是导致分神的主因。</strong> 慢速阅读无法充分激活大脑的任务正激活网络（TPN），导致默认模式网络（DMN）接管大脑，引发思维游荡。</p></li><li><p><strong>系统解决方案</strong>：解决分神问题的最佳途径不是枯燥地“练习专注”，而是通过<strong>视觉引导、听觉干扰、舒尔特方格</strong>等科学训练手段，强行提升阅读速度。当阅读速度提升至大脑的舒适带宽（500 CPM+）时，认知资源将被充分调用，分神现象将自然消退。</p></li></ol><p>快速阅读不仅是为了省时间，更是为了<strong>抢占大脑的注意力高地</strong>。通过执行本报告提供的8周训练计划，受试者完全有能力重塑神经回路，实现从“低效朗读者”到“高效视觉阅读者”的认知跃迁。</p>]]></content>
    
    
    <categories>
      
      <category>Tech</category>
      
    </categories>
    
    
    <tags>
      
      <tag>brain science</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片缩放器方案调研</title>
    <link href="/2025/06/02/SE/%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE%E5%99%A8%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/"/>
    <url>/2025/06/02/SE/%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE%E5%99%A8%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图片缩放器是所有内容平台不可或缺的功能，对其展开方案调研</p></blockquote><span id="more"></span><h1 id="基于-Vue-3-和-TypeScript-的全局图像放大系统架构研究报告"><a href="#基于-Vue-3-和-TypeScript-的全局图像放大系统架构研究报告" class="headerlink" title="基于 Vue 3 和 TypeScript 的全局图像放大系统架构研究报告"></a>基于 Vue 3 和 TypeScript 的全局图像放大系统架构研究报告</h1><h2 id="1-绪论与需求背景分析"><a href="#1-绪论与需求背景分析" class="headerlink" title="1. 绪论与需求背景分析"></a>1. 绪论与需求背景分析</h2><h3 id="1-1-研究背景与问题定义"><a href="#1-1-研究背景与问题定义" class="headerlink" title="1.1 研究背景与问题定义"></a>1.1 研究背景与问题定义</h3><p>在现代 Web 应用开发中，图像作为信息传递的核心媒介，其交互体验直接关系到用户的留存率与满意度。随着单页应用（Single Page Application, SPA）技术的普及，特别是 Vue 3 及其组合式 API（Composition API）和 TypeScript 强类型系统的广泛采用，前端架构的复杂度日益提升。开发者面临的一个典型且具挑战性的需求是：<strong>如何在一个已经成型或正在开发的 Vue 3 + TypeScript 项目中，实现对“所有”图片的全局放大功能（Lightbox），而无需侵入式地修改现有的每一个组件模板。</strong></p><p>本报告旨在响应这一特定需求，提供一套“成熟方案”。所谓“成熟方案”，在企业级软件工程语境下，应当具备以下核心特质：</p><ol><li><p><strong>全局性（Ubiquity）：</strong> 能够自动覆盖应用内的静态图片、动态加载图片、富文本中的图片以及第三方组件内的图片，无需逐一标记。</p></li><li><p><strong>低耦合（Decoupling）：</strong> 图像的渲染逻辑（各个业务组件）与图像的交互逻辑（放大查看）应当物理分离，避免逻辑交叉污染。</p></li><li><p><strong>高性能（Performance）：</strong> 在包含数千张图片的页面中，不应因绑定过多的事件监听器而导致内存泄漏或页面卡顿。</p></li><li><p><strong>类型安全（Type Safety）：</strong> 严格遵循 TypeScript 标准，提供完整的类型推断，杜绝 <code>any</code> 类型的滥用。</p></li><li><p><strong>可扩展性（Extensibility）：</strong> 支持手势操作、键盘导航、多图轮播（Gallery Mode）以及元数据展示。</p></li></ol><h3 id="1-2-技术栈上下文与约束"><a href="#1-2-技术栈上下文与约束" class="headerlink" title="1.2 技术栈上下文与约束"></a>1.2 技术栈上下文与约束</h3><p>本方案基于以下技术栈环境构建：</p><ul><li><p><strong>框架核心：</strong> Vue 3.x（使用 Composition API 和 <code>&lt;script setup&gt;</code> 语法糖）。</p></li><li><p><strong>语言标准：</strong> TypeScript 4.x&#x2F;5.x（强调严格模式 <code>strict: true</code>）。</p></li><li><p><strong>状态管理：</strong> Pinia（作为 Vue 3 的官方推荐状态管理库，取代 Vuex）。</p></li><li><p><strong>构建工具：</strong> Vite（强调构建速度与 ES Module 支持）。</p></li></ul><p>在 Vue 3 的生态系统中，传统的 Vue 2 插件模式（即通过 <code>Vue.prototype</code> 挂载全局方法）已被弃用 。Vue 3 强调显式的依赖注入和组合式函数的复用。因此，架构设计必须顺应这一范式转变，利用 <code>provide/inject</code> 或全局单例状态来管理 UI 层的覆盖物。  </p><h3 id="1-3-报告结构导读"><a href="#1-3-报告结构导读" class="headerlink" title="1.3 报告结构导读"></a>1.3 报告结构导读</h3><p>本报告将分为七个核心部分深入剖析该解决方案。首先，我们将调研现有的 Vue 3 图片预览生态，评估 <code>v-viewer</code>、<code>vue-easy-lightbox</code> 等主流库的优劣。其次，我们将论证为何“全局事件代理”（Global Event Delegation）是实现“点击任意图片”需求的唯一架构级解法，而非传统的指令或组件包裹模式。随后，我们将详细阐述基于 Pinia 的单例模式实现，以及如何通过 TypeScript 确保系统的健壮性。最后，我们将探讨性能优化、移动端适配及服务端渲染（SSR）兼容性等高级议题。</p><hr><h2 id="2-前端图像可视化生态系统深度调研"><a href="#2-前端图像可视化生态系统深度调研" class="headerlink" title="2. 前端图像可视化生态系统深度调研"></a>2. 前端图像可视化生态系统深度调研</h2><p>在构建成熟方案之前，必须对现有的开源解决方案进行详尽的技术评估。选择正确的底层库是项目成功的基石。对于“图片放大器”这一功能，社区中存在多种实现路径，从轻量级的 Vue 组件到基于底层 DOM 操作的封装库。</p><h3 id="2-1-主流解决方案技术评估"><a href="#2-1-主流解决方案技术评估" class="headerlink" title="2.1 主流解决方案技术评估"></a>2.1 主流解决方案技术评估</h3><p>根据 NPM 下载量、GitHub Star 数、Vue 3 原生支持度以及 TypeScript 类型定义的完整性，我们筛选出以下三个主要候选方案进行深度分析。</p><h4 id="2-1-1-v-viewer-基于-Viewer-js"><a href="#2-1-1-v-viewer-基于-Viewer-js" class="headerlink" title="2.1.1 v-viewer (基于 Viewer.js)"></a>2.1.1 v-viewer (基于 Viewer.js)</h4><p><code>v-viewer</code> 是著名 JavaScript 图片查看库 <code>viewer.js</code> 的 Vue 封装版本。<code>viewer.js</code> 本身是 Web 领域功能最全面的图片查看器之一。</p><ul><li><p><strong>功能特性：</strong> 支持缩放、旋转、翻转、键盘导航、触摸手势、缩略图导航、标题显示等 。其核心优势在于极其丰富的功能集，几乎涵盖了所有桌面端和移动端的交互需求。  </p></li><li><p><strong>Vue 3 与 TypeScript 支持：</strong> <code>v-viewer</code> 的最新版本（3.x）已完全兼容 Vue 3，并提供了内置的 TypeScript 类型声明文件（<code>.d.ts</code>），这使得在 TS 项目中引入该库时，能够获得良好的代码提示和类型检查 。  </p></li><li><p><strong>架构适配性：</strong> 它提供了一个非常关键的 API —— <code>viewerApi</code>。允许开发者以函数调用的方式（Programmatic API）直接启动查看器，而无需在模板中显式声明 <code>&lt;viewer&gt;</code> 组件。这一点对于实现“全局拦截”至关重要 。</p></li></ul><p>  </p><h4 id="2-1-2-vue-easy-lightbox"><a href="#2-1-2-vue-easy-lightbox" class="headerlink" title="2.1.2 vue-easy-lightbox"></a>2.1.2 vue-easy-lightbox</h4><p>这是一个专为 Vue 设计的轻量级灯箱插件，且在 Vue 3 版本中重写以支持 TypeScript。</p><ul><li><p><strong>功能特性：</strong> 专注于核心功能：缩放、旋转、切换。它没有 Viewer.js 那么庞大的体积，UI 风格更加简洁现代 。  </p></li><li><p><strong>Vue 3 与 TypeScript 支持：</strong> 作者提供了完整的 TypeScript 支持，并且在新版本中引入了 <code>useEasyLightbox</code> 组合式函数（Composable），这与 Vue 3 的设计理念高度契合 。  </p></li><li><p><strong>架构适配性：</strong> 它主要设计为组件形式使用（<code>&lt;VueEasyLightbox... /&gt;</code>）。虽然可以通过状态控制其显示隐藏，但缺乏像 Viewer.js 那样强大的 DOM 扫描和自动分组能力。</p></li></ul><h4 id="2-1-3-Element-Plus-Image-Viewer"><a href="#2-1-3-Element-Plus-Image-Viewer" class="headerlink" title="2.1.3 Element Plus Image Viewer"></a>2.1.3 Element Plus Image Viewer</h4><p>如果项目已经使用了 Element Plus UI 库，其内部的 <code>el-image-viewer</code> 组件是一个备选项。</p><ul><li><p><strong>功能特性：</strong> 提供基础的预览功能，与 Element Plus 设计语言统一。</p></li><li><p><strong>局限性：</strong> 官方文档主要将其作为 <code>el-image</code> 组件的附属功能介绍，单独调用的文档较少，且功能扩展性（如自定义手势、复杂的工具栏定制）不如专业库 。</p></li></ul><p>  </p><h3 id="2-2-选型决策矩阵"><a href="#2-2-选型决策矩阵" class="headerlink" title="2.2 选型决策矩阵"></a>2.2 选型决策矩阵</h3><p>为了直观展示各方案的差异，我们构建了以下对比矩阵：</p><table><thead><tr><th>评估维度</th><th>v-viewer (Viewer.js)</th><th>vue-easy-lightbox</th><th>Element Plus Viewer</th><th>自研实现</th></tr></thead><tbody><tr><td><strong>成熟度 (Maturity)</strong></td><td><strong>极高</strong> (行业标准级)</td><td>高</td><td>中</td><td>低 (需长期迭代)</td></tr><tr><td><strong>功能丰富度</strong></td><td><strong>极高</strong> (旋转&#x2F;翻转&#x2F;Exif)</td><td>中 (基础缩放)</td><td>中</td><td>取决于投入</td></tr><tr><td><strong>TS 类型支持</strong></td><td><strong>原生内置</strong></td><td><strong>原生内置</strong></td><td>内置</td><td>需自行定义</td></tr><tr><td><strong>调用方式</strong></td><td>组件 + <strong>函数式API</strong></td><td>组件 + Composable</td><td>组件为主</td><td>任意</td></tr><tr><td><strong>包体积 (Gzip)</strong></td><td>较重 (~20KB+)</td><td>轻量 (~5KB)</td><td>随库引入</td><td>极轻</td></tr><tr><td><strong>全局整合难度</strong></td><td><strong>低</strong> (API调用极其方便)</td><td>中</td><td>高</td><td>高</td></tr></tbody></table><p> </p><h3 id="2-3-结论：基于-v-viewer-的架构选定"><a href="#2-3-结论：基于-v-viewer-的架构选定" class="headerlink" title="2.3 结论：基于 v-viewer 的架构选定"></a>2.3 结论：基于 v-viewer 的架构选定</h3><p>针对用户提出的“成熟方案”要求，<strong><code>v-viewer</code> 是最佳选择</strong>。原因如下：</p><ol><li><p><strong>API 调用的灵活性：</strong> <code>viewerApi</code> 函数允许我们在任何地方（包括非 Vue 组件的纯 JS&#x2F;TS 文件中）启动查看器，这完美适配了我们将要采用的“全局事件代理”模式 。  </p></li><li><p><strong>功能的完备性：</strong> 用户需求虽仅提到“放大”，但实际生产环境中，用户往往期望手势缩放、保存图片、旋转查看细节等功能。Viewer.js 一站式解决了这些隐性需求，无需二次开发。</p></li><li><p><strong>生态验证：</strong> 作为一个被大量顶级品牌使用的库 ，其稳定性和浏览器兼容性（包括移动端）远超自研或小型库。</p></li></ol><p>  </p><p>因此，本报告后续的架构设计将围绕 <strong>Vue 3 + TypeScript + Pinia + v-viewer</strong> 展开。</p><hr><h2 id="3-全局交互架构设计：事件代理模式"><a href="#3-全局交互架构设计：事件代理模式" class="headerlink" title="3. 全局交互架构设计：事件代理模式"></a>3. 全局交互架构设计：事件代理模式</h2><p>要实现“对所有图片增加放大器”且“不侵入组件代码”，传统的组件封装（Wrapping）或指令（Directive）模式均显得力不从心。我们需要一种更底层的架构模式——<strong>全局事件代理（Global Event Delegation）</strong>。</p><h3 id="3-1-传统模式的局限性分析"><a href="#3-1-传统模式的局限性分析" class="headerlink" title="3.1 传统模式的局限性分析"></a>3.1 传统模式的局限性分析</h3><h4 id="3-1-1-模式一：组件封装"><a href="#3-1-1-模式一：组件封装" class="headerlink" title="3.1.1 模式一：组件封装 (&lt;ImagePreview&gt;)"></a>3.1.1 模式一：组件封装 (<code>&lt;ImagePreview&gt;</code>)</h4><p>开发者可能会想到封装一个 <code>&lt;ImagePreview :src=&quot;...&quot;&gt;</code> 组件，替换项目中所有的 <code>&lt;img&gt;</code> 标签。</p><ul><li><strong>缺陷：</strong> 这种方式对于遗留代码或第三方库（如富文本编辑器输出的 HTML、Markdown 渲染内容）无效。且重构成本巨大，不仅要修改现有代码，还会增加 DOM 深度 。</li></ul><p>  </p><h4 id="3-1-2-模式二：全局指令-v-zoom"><a href="#3-1-2-模式二：全局指令-v-zoom" class="headerlink" title="3.1.2 模式二：全局指令 (v-zoom)"></a>3.1.2 模式二：全局指令 (<code>v-zoom</code>)</h4><p>创建一个 <code>v-zoom</code> 指令，在 <code>mounted</code> 钩子中给元素绑定点击事件。</p><ul><li><strong>缺陷：</strong> 虽然比组件灵活，但仍需在每个 <code>&lt;img v-zoom&gt;</code> 上手动添加。对于动态内容（<code>v-html</code>），指令无法自动渗透到内部元素，除非编写复杂的 MutationObserver 逻辑。且每个图片都绑定监听器会带来显著的内存开销 。</li></ul><p>  </p><h3 id="3-2-推荐模式：全局事件代理-Global-Event-Delegation"><a href="#3-2-推荐模式：全局事件代理-Global-Event-Delegation" class="headerlink" title="3.2 推荐模式：全局事件代理 (Global Event Delegation)"></a>3.2 推荐模式：全局事件代理 (Global Event Delegation)</h3><p>事件代理利用了 DOM 事件的<strong>冒泡机制（Event Bubbling）</strong>。当用户点击页面深处的 <code>&lt;img&gt;</code> 元素时，点击事件会逐层向上传播，最终到达 <code>document</code> 或 <code>window</code> 对象。</p><p><strong>核心架构逻辑：</strong></p><ol><li><p><strong>监听：</strong> 在应用的最顶层（通常是 <code>App.vue</code> 或 <code>main.ts</code> 初始化阶段），向 <code>document</code> 注册一个全局的 <code>click</code> 侦听器 。  </p></li><li><p><strong>拦截：</strong> 当事件触发时，检查 <code>event.target</code> 是否为 <code>HTMLImageElement</code>（即 <code>&lt;img&gt;</code> 标签）。</p></li><li><p><strong>过滤：</strong> 通过类名（如 <code>.no-zoom</code>）、父级元素（如是否在 <code>&lt;a&gt;</code> 标签内）或属性（<code>data-no-zoom</code>）来判断该图片是否需要被拦截 。  </p></li><li><p><strong>执行：</strong> 如果满足条件，阻止默认行为（如需要），并调用全局单例的 Lightbox 服务进行展示。</p></li></ol><p><strong>数据与性能优势：</strong></p><ul><li><p><strong>内存占用恒定：</strong> 无论页面有一张还是五千张图片，内存中永远只有一个事件监听器函数 。  </p></li><li><p><strong>动态内容支持：</strong> AJAX 加载的图片、路由切换后的新页面图片、富文本中的图片，只要它们出现在 DOM 中并被点击，都会触发冒泡，无需重新绑定 。</p></li></ul><p>  </p><h3 id="3-3-TypeScript-类型工程"><a href="#3-3-TypeScript-类型工程" class="headerlink" title="3.3 TypeScript 类型工程"></a>3.3 TypeScript 类型工程</h3><p>在 TypeScript 环境下，事件代理需要严格的类型断言。<code>event.target</code> 默认是 <code>EventTarget | null</code>，需要通过类型守卫（Type Guard）确认为 <code>HTMLImageElement</code> 才能安全访问 <code>.src</code> 或 <code>.dataset</code> 属性。</p><p>TypeScript</p><pre><code class="hljs">// 类型守卫示例function isImageElement(target: EventTarget | null): target is HTMLImageElement &#123;  return (target as HTMLElement)?.tagName === &#39;IMG&#39;;&#125;</code></pre><p>这种类型安全的处理是“成熟方案”区别于即兴代码的重要标志 。  </p><hr><h2 id="4-核心实现策略：单例状态管理-Singleton-State"><a href="#4-核心实现策略：单例状态管理-Singleton-State" class="headerlink" title="4. 核心实现策略：单例状态管理 (Singleton State)"></a>4. 核心实现策略：单例状态管理 (Singleton State)</h2><p>仅仅拦截点击是不够的，我们还需要一个机制来唤起 UI。在 Vue 3 中，最佳实践是利用 <strong>Pinia</strong> 建立一个全局单例状态，以此解耦“点击检测逻辑”和“UI 渲染逻辑”。</p><h3 id="4-1-状态管理架构"><a href="#4-1-状态管理架构" class="headerlink" title="4.1 状态管理架构"></a>4.1 状态管理架构</h3><p>我们将创建一个名为 <code>useLightboxStore</code> 的 Pinia store。这个 store 将充当整个系统的“控制台”。</p><ul><li><p><strong>State（状态）：</strong></p><ul><li><p><code>visible</code>: 布尔值，控制查看器是否显示。</p></li><li><p><code>images</code>: 字符串数组或对象数组，存储当前需要展示的图片列表。</p></li><li><p><code>index</code>: 数字，当前查看图片的索引。</p></li><li><p><code>options</code>: 配置对象，用于透传 Viewer.js 的配置（如是否显示工具栏、背景遮罩透明度等）。</p></li></ul></li><li><p><strong>Actions（动作）：</strong></p><ul><li><p><code>open(imageSources, startIndex)</code>: 接收图片列表和初始索引，激活状态。</p></li><li><p><code>close()</code>: 重置状态，关闭查看器。</p></li></ul></li></ul><p>这种设计模式符合 Vue 3 的**单一数据源（Single Source of Truth）**原则 。任何组件（不仅仅是全局点击监听器）都可以通过调用 <code>store.open(...)</code> 来唤起看图器，极大地提高了代码复用性。  </p><h3 id="4-2-响应式联动机制"><a href="#4-2-响应式联动机制" class="headerlink" title="4.2 响应式联动机制"></a>4.2 响应式联动机制</h3><p>在架构层面，我们并不直接在 <code>App.vue</code> 的模板中编写大量的 <code>v-if</code> 逻辑来挂载 <code>&lt;viewer&gt;</code> 组件。相反，我们将利用 Vue 的 <code>watch</code> 侦听器来监控 store 的变化。</p><p>当 <code>lightboxStore.visible</code> 变为 <code>true</code> 时，我们将通过 <code>v-viewer</code> 提供的<strong>指令式 API</strong>（Imperative API）—— <code>viewerApi(&#123;&#125;)</code> —— 来动态创建查看器实例 。这种方法避免了在 DOM 中预渲染隐藏的图片列表，减少了 DOM 节点的数量，提升了首屏渲染性能。  </p><hr><h2 id="5-详细实现方案-The-Implementation"><a href="#5-详细实现方案-The-Implementation" class="headerlink" title="5. 详细实现方案 (The Implementation)"></a>5. 详细实现方案 (The Implementation)</h2><p>本章节将提供生产环境级别的代码实现，涵盖 Store 定义、全局拦截器 Composable、以及根组件整合。</p><h3 id="5-1-第一步：安装依赖与类型定义"><a href="#5-1-第一步：安装依赖与类型定义" class="headerlink" title="5.1 第一步：安装依赖与类型定义"></a>5.1 第一步：安装依赖与类型定义</h3><p>首先确保项目中安装了必要的库：</p><p>Bash</p><pre><code class="hljs">npm install v-viewer viewerjs pinia# 或者yarn add v-viewer viewerjs pinia</code></pre><p>由于我们使用的是 TypeScript，通常需要确认类型定义。<code>v-viewer</code> 自带类型，但在某些严格配置下，可能需要补充类型声明。</p><p><strong>文件：<code>src/types/v-viewer.d.ts</code></strong> 如果遇到类型报错，可以添加此补充定义：</p><p>TypeScript</p><pre><code class="hljs">declare module &#39;v-viewer&#39; &#123;  import &#123; Plugin &#125; from &#39;vue&#39;;  export const component: any;  // 定义 api 函数的强类型签名  export const api: (options: &#123;       images: string | object;       options?: object   &#125;) =&gt; any;  const plugin: Plugin;  export default plugin;&#125;</code></pre><h3 id="5-2-第二步：构建-Lightbox-Store-Pinia"><a href="#5-2-第二步：构建-Lightbox-Store-Pinia" class="headerlink" title="5.2 第二步：构建 Lightbox Store (Pinia)"></a>5.2 第二步：构建 Lightbox Store (Pinia)</h3><p>这是整个系统的状态中枢。</p><p><strong>文件：<code>src/stores/lightboxStore.ts</code></strong></p><p>TypeScript</p><pre><code class="hljs">import &#123; defineStore &#125; from &#39;pinia&#39;;import &#123; ref &#125; from &#39;vue&#39;;// 定义图片源接口，支持 URL 字符串或包含 src/alt 的对象export type ImageSource = string | &#123; src: string; alt?: string; [key: string]: any &#125;;export const useLightboxStore = defineStore(&#39;lightbox&#39;, () =&gt; &#123;  // --- State ---  const isVisible = ref(false);  const imageList = ref&lt;ImageSource&gt;();  const initialIndex = ref(0);    // --- Actions ---    /**   * 打开图片查看器   * @param images - 图片源数组   * @param index - 初始展示的图片索引   */  const show = (images: ImageSource, index: number = 0) =&gt; &#123;    // 数据清洗：过滤掉空值    if (!images || images.length === 0) &#123;      console.warn(&#39;[Lightbox] No images provided to show.&#39;);      return;    &#125;        imageList.value = images;    initialIndex.value = index;    isVisible.value = true;  &#125;;  /**   * 关闭图片查看器   */  const hide = () =&gt; &#123;    isVisible.value = false;    // 可选：延迟清空数据以配合动画    setTimeout(() =&gt; &#123;      imageList.value =;      initialIndex.value = 0;    &#125;, 300);  &#125;;  return &#123;    isVisible,    imageList,    initialIndex,    show,    hide  &#125;;&#125;);</code></pre><p>引用说明：此实现基于 Vue 3 Composition API 和 Pinia 的 Setup Store 模式 。  </p><h3 id="5-3-第三步：开发全局事件拦截器-Composable"><a href="#5-3-第三步：开发全局事件拦截器-Composable" class="headerlink" title="5.3 第三步：开发全局事件拦截器 (Composable)"></a>5.3 第三步：开发全局事件拦截器 (Composable)</h3><p>这是实现“全自动”的核心逻辑。我们将逻辑封装在一个 Composable 函数中，以便在 <code>App.vue</code> 中调用。</p><p><strong>文件：<code>src/composables/useGlobalImageInterceptor.ts</code></strong></p><p>TypeScript</p><pre><code class="hljs">import &#123; onMounted, onUnmounted &#125; from &#39;vue&#39;;import &#123; useLightboxStore &#125; from &#39;@/stores/lightboxStore&#39;;export function useGlobalImageInterceptor() &#123;  const lightboxStore = useLightboxStore();  const handleGlobalClick = (event: MouseEvent) =&gt; &#123;    // 1. 类型断言与基础检查    const target = event.target as HTMLElement;    if (!target || target.tagName!== &#39;IMG&#39;) &#123;      return;    &#125;    const imgElement = target as HTMLImageElement;    // 2. 排除逻辑 (Filtering)    // 场景：排除 Logo、图标、特定类名的图片    // 检查自身或父级是否有 &#39;no-zoom&#39; 类名    if (imgElement.closest(&#39;.no-zoom&#39;) || imgElement.classList.contains(&#39;no-zoom&#39;)) &#123;      return;    &#125;    // 3. 链接处理逻辑    // 如果图片被包裹在链接中，通常需要权衡是跳转链接还是放大图片。    // 成熟方案建议：如果有链接，且链接是跳转页面，则不拦截（尊重超链接）。    // 除非链接本身是指向大图的（这是一种传统的 Lightbox 写法）。    const parentLink = imgElement.closest(&#39;a&#39;);    if (parentLink) &#123;      // 简单的启发式判断：如果链接是指向图片的，则拦截并放大；否则放行      const href = parentLink.getAttribute(&#39;href&#39;);      const isImageLink = href?.match(/\.(jpeg|jpg|gif|png|webp)$/i);            if (!isImageLink) &#123;        // 允许跳转，不执行放大        return;       &#125; else &#123;        // 是图片链接，阻止跳转，执行放大        event.preventDefault();      &#125;    &#125;    // 4. 获取高清图源    // 许多现代网站使用缩略图 (src) 和高清图 (data-original / data-src)    // 优先使用高清图    const highResSrc = imgElement.dataset.original || imgElement.dataset.src || imgElement.src;    const altText = imgElement.alt || &#39;Image&#39;;    // 5. 上下文构建 (Contextual Gallery)    // 这是一个高级特性：点击图片时，自动识别它是否属于一个“图集”。    // 例如：文章正文中的图片容器。    let galleryImages: string =;    let activeIndex = 0;    // 假设我们约定，文章内容的容器类名为 &#39;article-content&#39; 或 &#39;gallery-group&#39;    const galleryContainer = imgElement.closest(&#39;.article-content,.gallery-group&#39;);    if (galleryContainer) &#123;      // 扫描容器内所有可视图片      const allImages = Array.from(galleryContainer.querySelectorAll(&#39;img&#39;))       .filter(img =&gt;!img.classList.contains(&#39;no-zoom&#39;) &amp;&amp; img.style.display!== &#39;none&#39;);            galleryImages = allImages.map(img =&gt; &#123;        return (img as HTMLElement).dataset.original || (img as HTMLElement).dataset.src || (img as HTMLImageElement).src;      &#125;);      // 找到当前点击图片在集合中的索引      activeIndex = galleryImages.findIndex(src =&gt; src === highResSrc);      if (activeIndex === -1) activeIndex = 0;    &#125; else &#123;      // 单图模式      galleryImages =;      activeIndex = 0;    &#125;    // 6. 触发 Store    // 阻止事件继续冒泡，防止触发其他无关的点击逻辑    event.stopPropagation();     lightboxStore.show(galleryImages, activeIndex);  &#125;;  // 生命周期管理  onMounted(() =&gt; &#123;    // 使用 capture: true 可以在事件到达目标之前拦截，但通常冒泡阶段更安全    // 这里使用 document 级的监听    document.addEventListener(&#39;click&#39;, handleGlobalClick);  &#125;);  onUnmounted(() =&gt; &#123;    document.removeEventListener(&#39;click&#39;, handleGlobalClick);  &#125;);&#125;</code></pre><p>引用说明：事件代理机制利用了 DOM 的 Event Bubbling ，通过 <code>closest</code> API 实现了智能的上下文感知，这是成熟方案区别于简单 Demo 的关键点。  </p><h3 id="5-4-第四步：根组件集成与-UI-渲染"><a href="#5-4-第四步：根组件集成与-UI-渲染" class="headerlink" title="5.4 第四步：根组件集成与 UI 渲染"></a>5.4 第四步：根组件集成与 UI 渲染</h3><p>最后，在 <code>App.vue</code> 中挂载逻辑。</p><p><strong>文件：<code>src/App.vue</code></strong></p><p>HTML</p><pre><code class="hljs">&lt;template&gt;  &lt;router-view /&gt;    &lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; watch &#125; from &#39;vue&#39;;import &#123; useLightboxStore &#125; from &#39;@/stores/lightboxStore&#39;;import &#123; useGlobalImageInterceptor &#125; from &#39;@/composables/useGlobalImageInterceptor&#39;;import &#123; api as viewerApi &#125; from &#39;v-viewer&#39;;import &#39;viewerjs/dist/viewer.css&#39;; // 引入样式// 1. 初始化全局拦截器useGlobalImageInterceptor();// 2. 监听 Store 变化以驱动 Viewer.jsconst lightboxStore = useLightboxStore();// 定义 Viewer.js 的配置项// 参考文档：https://github.com/fengyuanchen/viewerjs#optionsconst viewerOptions = &#123;  toolbar: true,  navbar: true,  title: false, // 简洁模式，通常不需要显示文件名  movable: true,  zoomable: true,  rotatable: true,  scalable: true,  transition: true, // 启用 CSS3 过渡  fullscreen: true,  keyboard: true,  // 核心：当 Viewer 关闭时，必须同步 Store 状态  hidden: () =&gt; &#123;    lightboxStore.hide();  &#125;,&#125;;// 3. 响应式联动watch(  () =&gt; lightboxStore.isVisible,  (visible) =&gt; &#123;    if (visible) &#123;      // 调用 API 生成实例      const $viewer = viewerApi(&#123;        options: &#123;         ...viewerOptions,          initialViewIndex: lightboxStore.initialIndex,        &#125;,        images: lightboxStore.imageList,      &#125;);            // 注意：viewerApi 会返回 viewer 实例，如果需要更复杂的控制（如销毁），可以保存它      // 但 v-viewer 默认会在 hide 时自动清理 DOM    &#125;  &#125;);&lt;/script&gt;</code></pre><hr><h2 id="6-高级优化与成熟度指标"><a href="#6-高级优化与成熟度指标" class="headerlink" title="6. 高级优化与成熟度指标"></a>6. 高级优化与成熟度指标</h2><p>上述代码实现了一个基础的全局放大系统，但要达到“成熟方案”的标准，还需在以下几个维度进行优化。</p><h3 id="6-1-性能优化：懒加载与代码分割"><a href="#6-1-性能优化：懒加载与代码分割" class="headerlink" title="6.1 性能优化：懒加载与代码分割"></a>6.1 性能优化：懒加载与代码分割</h3><p>引入 <code>viewerjs</code> 会增加应用的包体积（gzip 后约 20KB+）。如果在用户从未点击图片的情况下就加载这部分代码，是对带宽的浪费。</p><p><strong>优化方案：动态导入（Dynamic Import）</strong></p><p>我们可以修改 <code>App.vue</code> 中的 <code>watch</code> 逻辑，仅在第一次需要显示时才加载库文件。</p><p>TypeScript</p><pre><code class="hljs">watch(  () =&gt; lightboxStore.isVisible,  async (visible) =&gt; &#123;    if (visible) &#123;      // 动态导入库和样式      // Vite 会自动将这部分代码分割成独立的 chunk      const [viewerModule, _css] = await Promise.all([        import(&#39;v-viewer&#39;),        import(&#39;viewerjs/dist/viewer.css&#39;)      ]);            const viewerApi = viewerModule.api;            viewerApi(&#123;        options: &#123;...viewerOptions, initialViewIndex: lightboxStore.initialIndex &#125;,        images: lightboxStore.imageList,      &#125;);    &#125;  &#125;);</code></pre><p>这种优化可以显著提升应用的首屏加载速度（FCP&#x2F;LCP）。  </p><h3 id="6-2-移动端与响应式适配"><a href="#6-2-移动端与响应式适配" class="headerlink" title="6.2 移动端与响应式适配"></a>6.2 移动端与响应式适配</h3><p>Viewer.js 原生支持触摸手势（Touch Gestures），但在移动端，浏览器的默认行为（如双击缩放页面）可能会与查看器冲突。</p><ul><li><p><strong>视口设置：</strong> 确保 <code>index.html</code> 中设置了正确的 meta viewport：</p><p>HTML</p><pre><code class="hljs">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</code></pre></li><li><p><strong>CSS 触摸操作：</strong> 在全局 CSS 中，建议对图片元素设置 <code>touch-action</code> 属性，以优化浏览器对点击和滑动的处理。</p><p>CSS</p><pre><code class="hljs">img &#123;  /* 允许浏览器处理平移和缩放，但在 viewer 打开时 viewer.js 会接管 */  touch-action: manipulation; &#125;</code></pre></li></ul><h3 id="6-3-内存泄漏防护"><a href="#6-3-内存泄漏防护" class="headerlink" title="6.3 内存泄漏防护"></a>6.3 内存泄漏防护</h3><p>在 SPA 中，路由切换不会刷新页面。如果全局监听器绑定不当，可能会导致内存泄漏。<code>useGlobalImageInterceptor</code> 中使用了 <code>onUnmounted</code> 进行事件解绑，这是安全的。但是，<code>v-viewer</code> 创建的 DOM 实例如果异常退出（如组件强制卸载），可能会残留在 <code>body</code> 中。</p><p><strong>解决方案：</strong> 确保 <code>viewerOptions</code> 中的 <code>hidden</code> 回调被正确执行。此外，Pinia store 的状态在关闭时应及时重置，避免持有没有必要的大数组引用。</p><h3 id="6-4-高清图与渐进式加载体验"><a href="#6-4-高清图与渐进式加载体验" class="headerlink" title="6.4 高清图与渐进式加载体验"></a>6.4 高清图与渐进式加载体验</h3><p>成熟的方案应考虑到图片加载体验。在列表中展示的是小图（thumbnail），放大时展示的是大图（original）。</p><p>在 5.3 节的代码中，我们优先读取 <code>dataset.original</code>：</p><p>TypeScript</p><pre><code class="hljs">const highResSrc = imgElement.dataset.original || imgElement.src;</code></pre><p>开发者只需在业务代码中遵循这一约定：</p><p>HTML</p><pre><code class="hljs">&lt;img src=&quot;small.jpg&quot; data-original=&quot;heavy-4k-image.jpg&quot; /&gt;</code></pre><p>系统即可自动处理“缩略图 -&gt; 高清图”的无缝切换，无需额外配置。</p>]]></content>
    
    
    <categories>
      
      <category>SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fontend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Whisper&amp;deepseek</title>
    <link href="/2025/03/01/AI/Whisper-deepseek/"/>
    <url>/2025/03/01/AI/Whisper-deepseek/</url>
    
    <content type="html"><![CDATA[<blockquote><p>whispher转写会议音频+deepseek总结项目记录</p></blockquote><span id="more"></span><ul><li>目前通过脚本实现与用户的简单交互：.&#x2F;start.sh 一行命令回车进行录音，再回车结束录音后，Whisper进行转写，deepseek进行总结；效果如下</li></ul><p><img src="/2025/03/01/AI/Whisper-deepseek/1742200862032.png" alt=".&#x2F;Whisper-deepseek&#x2F;1742200862032"></p><p><img src="/2025/03/01/AI/Whisper-deepseek/1742200884249.png" alt=".&#x2F;Whisper-deepseek&#x2F;1742200884249"></p><p>结果生成在&#x2F;data&#x2F;VAproject&#x2F;output&#x2F;时间戳目录下</p><p><img src="/2025/03/01/AI/Whisper-deepseek/1742201037./Whisper-deepseek/170.png" alt=".&#x2F;Whisper-deepseek&#x2F;1742201037.&#x2F;Whisper-deepseek&#x2F;170"></p><p>1h40min会议音频测试结果展示在文章末尾，用户也可以通过如下步骤自定义生成docx文件的模版样式（通过pypandoc库实现）；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 打开office word/wps，新建一个空白docx文档<br><span class="hljs-bullet">2.</span> 设置想要的样式，比如标题1、标题2、正文等<br><span class="hljs-bullet">3.</span> 保存样式：修改原样式，勾选基于此模版的新文档<br><span class="hljs-bullet">4.</span> 将文件命名为reference.docx，上传到到盒子中localApp.py的同级目录下<br></code></pre></td></tr></table></figure><ul><li><p>项目整体达到可使用的水平，但还现存一些模型能力带来的小问题</p><ol><li>极少数情况下，某些段落总结中会夹杂着少许英文，添加提示词强调中文输出无用，不明显；</li><li>通过修改模型参数generation_mode&#x3D;’greedy’为“penalty_sample”，可以避免无限输出重复内容的问题，但少数情况下，模型并不按照我的提示词模版进行输出；</li></ol><p><img src="/2025/03/01/AI/Whisper-deepseek/1742201533116.png" alt=".&#x2F;Whisper-deepseek&#x2F;1742201533116"><br><img src="/2025/03/01/AI/Whisper-deepseek/1742201699988.png" alt=".&#x2F;Whisper-deepseek&#x2F;1742201699988"><br><img src="/2025/03/01/AI/Whisper-deepseek/174220./Whisper-deepseek/1750479.png" alt=".&#x2F;Whisper-deepseek&#x2F;174220.&#x2F;Whisper-deepseek&#x2F;1750479"></p></li></ul><div class="row">    <embed src="1h08min.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目预处理初步测试效果</title>
    <link href="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/"/>
    <url>/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如下是目前项目的初步测试结果，包含了对pdf、docx、doc、ppt、png、jpg、bmp、xls、xlsx等各类文档的批处理；</p></blockquote><span id="more"></span><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p><img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image.png" alt="alt text"></p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="发票-pdf"><a href="#发票-pdf" class="headerlink" title="发票.pdf"></a>发票.pdf</h4><p><img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-12.png" alt="alt text"><br><img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-11.png" alt="alt text"></p><h4 id="风景图-lake-jpg"><a href="#风景图-lake-jpg" class="headerlink" title="风景图 lake.jpg"></a>风景图 lake.jpg</h4><p>   <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-3.png" alt="alt text"></p><p>   <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-22.png" alt="alt text"></p><h4 id="动作图-png"><a href="#动作图-png" class="headerlink" title="动作图.png"></a>动作图.png</h4><p>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-14.png" alt="alt text"><br>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-21.png" alt="alt text"></p><h4 id="attention-pdf，着重看其中的图片处理"><a href="#attention-pdf，着重看其中的图片处理" class="headerlink" title="attention.pdf，着重看其中的图片处理"></a>attention.pdf，着重看其中的图片处理</h4><p>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-4.png" alt="alt text"><br>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-13.png" alt="alt text"></p><h4 id="wind-xls"><a href="#wind-xls" class="headerlink" title="wind.xls"></a>wind.xls</h4><p>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-5.png" alt="alt text"><br>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-6.png" alt="alt text"></p><h4 id="word-docx"><a href="#word-docx" class="headerlink" title="word.docx"></a>word.docx</h4><p>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-16.png" alt="alt text"><br>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-17.png" alt="alt text"></p><h4 id="z9-bmp"><a href="#z9-bmp" class="headerlink" title="z9.bmp"></a>z9.bmp</h4><p>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-9.png" alt="alt text"><br>  <img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-10.png" alt="alt text"></p><h4 id="pptx-ppt"><a href="#pptx-ppt" class="headerlink" title="pptx&#x2F;ppt"></a>pptx&#x2F;ppt</h4><p><img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-18.png" alt="alt text"><br><img src="/2025/02/17/AI/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-19.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ollama-minicpm-v</title>
    <link href="/2025/02/13/AI/Ollama-minicpm-v/"/>
    <url>/2025/02/13/AI/Ollama-minicpm-v/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Ollama-minicpm-v是一个基于minicpm的开源项目，本文是对该模型视觉识别效果的简单介绍和使用说明。</p></blockquote><span id="more"></span><h3 id="测评"><a href="#测评" class="headerlink" title="测评"></a>测评</h3><ul><li><p>对图片的描述：描述全面、细节到位；</p><ul><li>风景</li></ul><p>  <img src="/2025/02/13/AI/Ollama-minicpm-v/image-2.png" alt="alt text"><br>  <img src="/2025/02/13/AI/Ollama-minicpm-v/image-3.png" alt="alt text"></p><ul><li>动作</li></ul><p>  <img src="/2025/02/13/AI/Ollama-minicpm-v/image.png" alt="alt text"><br>  <img src="/2025/02/13/AI/Ollama-minicpm-v/image-1.png" alt="alt text"></p><ul><li><p>流程图的理解：基本看懂了这个流程图</p><p> <img src="/2025/02/13/AI/Ollama-minicpm-v/image-6.png" alt="alt text"><br> <img src="/2025/02/13/AI/Ollama-minicpm-v/image-5.png" alt="alt text"></p></li></ul></li><li><p>对图片的OCR：虽然不是完全复原布局，但是该有的信息以及总结都有，也满足Markdown格式</p><p><img src="/2025/02/13/AI/Ollama-minicpm-v/image-8.png" alt="alt text"><br><img src="/2025/02/13/AI/Ollama-minicpm-v/image-10.png" alt="alt text"></p></li><li><p>优点，识别效果远高于其他Ollama中的视觉模型</p></li><li><p>缺点：每次回答结果都不太一样，不太稳定，有时回答不了；</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br><span class="hljs-keyword">import</span> ollama<br><br>response = ollama.chat(<br>    model=<span class="hljs-string">&#x27;minicpm-v&#x27;</span>,<br><br>    messages=[&#123;<br>        <span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>        <span class="hljs-string">&#x27;content&#x27;</span>: <span class="hljs-string">&#x27;请你识别这种图片，如果这张图片内容大多是文字，直接以Markdown格式给出OCR结果（完整还原布局和信息），否则如果是风景图/流程图等文字量较少的图片，描述一下这张图的内容(特征和细节），使用中文回答&#x27;</span>,<br>        <span class="hljs-string">&#x27;./Ollama-minicpm-v/images&#x27;</span>: [<span class="hljs-string">&#x27;1.png&#x27;</span>]<br>    &#125;]<br>)<br><br><span class="hljs-comment"># 只打印消息内容</span><br><span class="hljs-built_in">print</span>(response[<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>]) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExtractThinker</title>
    <link href="/2025/02/06/AI/ExtractThinker/"/>
    <url>/2025/02/06/AI/ExtractThinker/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li>流程：doclingOCR文件生成Markdown文本——llm进行识别并判断是自定义类型中的哪一种——llm进行提取相应类型所需的数据——存入数据库</li><li>参考、<ul><li><a href="https://pub.towardsai.net/building-an-on-premise-document-intelligence-stack-with-docling-ollama-phi-4-extractthinker-6ab60b495751">https://pub.towardsai.net/building-an-on-premise-document-intelligence-stack-with-docling-ollama-phi-4-extractthinker-6ab60b495751</a></li><li><a href="https://github.com/enoch3712/ExtractThinker">https://github.com/enoch3712/ExtractThinker</a></li></ul></li><li>效果如下</li></ul><p><img src="/2025/02/06/AI/ExtractThinker/image.png" alt="alt text"></p><p><img src="/2025/02/06/AI/ExtractThinker/image-1.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Test Docling</title>
    <link href="/2025/01/16/AI/Test-Docling/"/>
    <url>/2025/01/16/AI/Test-Docling/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试开源项目docling的功能</p></blockquote><span id="more"></span><h3 id="docling"><a href="#docling" class="headerlink" title="docling"></a>docling</h3><ul><li>仓库地址：<a href="https://github.com/DS4SD/docling">https://github.com/DS4SD/docling</a></li><li>Usage文档： <a href="https://ds4sd.github.io/docling/usage/#control-pdf-table-extraction-options">https://ds4sd.github.io/docling/usage/#control-pdf-table-extraction-options</a></li><li>特点：能读取流行的文档格式（PDF、DOCX、PPTX、XLSX、图片、HTML、AsciiDoc 和 Markdown），并导出为 HTML、Markdown 和 JSON。</li></ul><h4 id="默认的Fast模式"><a href="#默认的Fast模式" class="headerlink" title="默认的Fast模式"></a>默认的Fast模式</h4><ul><li>代码示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docling.document_converter <span class="hljs-keyword">import</span> DocumentConverter<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path<br><span class="hljs-comment"># 创建output目录(如果不存在)</span><br>output_dir = <span class="hljs-string">&quot;output&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>    os.makedirs(output_dir)<br><br>source = <span class="hljs-string">&quot;contract.docx&quot;</span>  <span class="hljs-comment"># document per local path or URL</span><br><span class="hljs-comment"># 获取源文件名(不含扩展名)</span><br>source_name = os.path.splitext(os.path.basename(source))[<span class="hljs-number">0</span>]<br><br>converter = DocumentConverter()<br>result = converter.convert(source)<br><br><span class="hljs-comment"># 构建输出文件路径</span><br>output_path = os.path.join(output_dir, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;source_name&#125;</span>.md&quot;</span>)<br><br><span class="hljs-comment"># 将转换结果写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(result.document.export_to_markdown())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;转换完成,文件已保存至: <span class="hljs-subst">&#123;output_path&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>测试效果如下：</p><ul><li>文本</li></ul><p><img src="/2025/01/16/AI/Test-Docling/image-42.png" alt="alt text"></p><ul><li>复杂图片，没有识别也没有保留；数字、括号识别很精准</li></ul><p><img src="/2025/01/16/AI/Test-Docling/image-43.png" alt="alt text"></p><ul><li>对表格的识别很好，但对公式、指数等识别不准确；不过作者在readme的Coming soon中提交到了，未来会补充；</li></ul><p><img src="/2025/01/16/AI/Test-Docling/image-44.png" alt="alt text"><br><img src="/2025/01/16/AI/Test-Docling/image-45.png" alt="alt text"></p><h4 id="Accurate模式"><a href="#Accurate模式" class="headerlink" title="Accurate模式"></a>Accurate模式</h4><ul><li><p>Usage文档中描述：Since docling 1.16.0: You can control which TableFormer mode you want to use. Choose between TableFormerMode.FAST (default) and TableFormerMode.ACCURATE (better, but slower) to receive better quality with difficult table structures；即选择TableFormerMode.ACCURATE (better, but slower) 可以识别更复杂的表格结构获得更好的质量，但速度会变慢。</p></li><li><p>需要在默认的OCR引擎上添加中文支持<code>pipeline_options.ocr_options.lang = [&quot;ch_sim&quot;, &quot;en&quot;]  # example of languages for EasyOCR</code></p></li><li><p>示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docling.datamodel.base_models <span class="hljs-keyword">import</span> InputFormat<br><span class="hljs-keyword">from</span> docling.document_converter <span class="hljs-keyword">import</span> DocumentConverter, PdfFormatOption<br><span class="hljs-keyword">from</span> docling.datamodel.pipeline_options <span class="hljs-keyword">import</span> PdfPipelineOptions, TableFormerMode<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path<br>pipeline_options = PdfPipelineOptions(do_table_structure=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 开启表格结构识别</span><br>pipeline_options.table_structure_options.mode = TableFormerMode.ACCURATE  <span class="hljs-comment"># use more accurate TableFormer model</span><br>pipeline_options.ocr_options.lang = [<span class="hljs-string">&quot;ch_sim&quot;</span>, <span class="hljs-string">&quot;en&quot;</span>]  <span class="hljs-comment"># example of languages for EasyOCR</span><br>doc_converter = DocumentConverter(<br>    format_options=&#123;<br>        InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)<br>    &#125;<br>)<br><br><br><span class="hljs-comment"># 创建output目录(如果不存在)</span><br>output_dir = <span class="hljs-string">&quot;outputAccurate&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>    os.makedirs(output_dir)<br><br>source = <span class="hljs-string">&quot;test5.pdf&quot;</span>  <span class="hljs-comment"># document per local path or URL</span><br><span class="hljs-comment"># 获取源文件名(不含扩展名)</span><br>source_name = os.path.splitext(os.path.basename(source))[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 构建输出文件路径</span><br>output_path = os.path.join(output_dir, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;source_name&#125;</span>.md&quot;</span>)<br><br>result = doc_converter.convert(source)<br><br><br><br><span class="hljs-comment"># 将转换结果写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(result.document.export_to_markdown())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;转换完成,文件已保存至: <span class="hljs-subst">&#123;output_path&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>如下为测试结果,以发票为例，左边为Fast模式，右边为Accurate模式;</p></li></ul><p><img src="/2025/01/16/AI/Test-Docling/image-46.png" alt="alt text"></p><p><img src="/2025/01/16/AI/Test-Docling/image-47.png" alt="alt text"></p><ul><li><p>可以看出来，Accurate模式识别的布局确实更细致一些，但也有更多重复的地方；</p></li><li><p>最后还有一个AI集成功能没有测完</p><ul><li><a href="https://ds4sd.github.io/docling/integrations/">https://ds4sd.github.io/docling/integrations/</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Test Markdownit对比MinerU</title>
    <link href="/2025/01/13/AI/Markitdown/"/>
    <url>/2025/01/13/AI/Markitdown/</url>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p></blockquote><span id="more"></span><h3 id="Test-Markdownit对比MinerU"><a href="#Test-Markdownit对比MinerU" class="headerlink" title="Test Markdownit对比MinerU"></a>Test Markdownit对比MinerU</h3><ul><li>开源地址：<a href="https://github.com/microsoft/markitdown">https://github.com/microsoft/markitdown</a></li></ul><h4 id="基础用法（无大模型）"><a href="#基础用法（无大模型）" class="headerlink" title="基础用法（无大模型）"></a>基础用法（无大模型）</h4><ul><li>优点：<ul><li>各种文件格式都能转成markdown</li><li>速度快，不到1s一张10页的论文pdf就被转换完成</li></ul></li><li>缺点：无法OCR、处理图片，无法处理公式<ul><li>参考如下仓库issue，作者没有进行处理<ul><li><a href="https://github.com/microsoft/markitdown/issues/255">https://github.com/microsoft/markitdown/issues/255</a></li><li><a href="https://github.com/microsoft/markitdown/issues/246">https://github.com/microsoft/markitdown/issues/246</a></li><li><a href="https://github.com/microsoft/markitdown/issues/217">https://github.com/microsoft/markitdown/issues/217</a></li><li><a href="https://github.com/microsoft/markitdown/issues/163">https://github.com/microsoft/markitdown/issues/163</a></li></ul></li></ul></li><li>举例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> markitdown <span class="hljs-keyword">import</span> MarkItDown<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_pdf_to_md</span>(<span class="hljs-params">pdf_filename</span>):<br>    <span class="hljs-comment"># 创建output目录（如果不存在）</span><br>    output_dir = <span class="hljs-string">&quot;output&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>        os.makedirs(output_dir)<br><br>    md = MarkItDown()<br>    result = md.convert(pdf_filename)<br><br>    <span class="hljs-comment"># 构建输出文件路径</span><br>    output_filename = os.path.splitext(os.path.basename(pdf_filename))[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;.md&quot;</span><br>    output_path = os.path.join(output_dir, output_filename)<br><br>    <span class="hljs-comment"># 将结果写入文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(result.text_content)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果已保存到: <span class="hljs-subst">&#123;output_path&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    pdf_filename = <span class="hljs-string">&quot;demo1.pdf&quot;</span><br>    convert_pdf_to_md(pdf_filename)<br></code></pre></td></tr></table></figure><p><img src="/2025/01/13/AI/Markitdown/01/13/AI/Markitdown/image.png" alt="alt text"></p><h4 id="使用大语言模型进行图像描述"><a href="#使用大语言模型进行图像描述" class="headerlink" title="使用大语言模型进行图像描述"></a>使用大语言模型进行图像描述</h4><ul><li>仓库的readme举例描述如下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> markitdown <span class="hljs-keyword">import</span> MarkItDown<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br>client = OpenAI()<br>md = MarkItDown(llm_client=client, llm_model=<span class="hljs-string">&quot;gpt-4o&quot;</span>)<br>result = md.convert(<span class="hljs-string">&quot;example.jpg&quot;</span>)<br><span class="hljs-built_in">print</span>(result.text_content)<br><br></code></pre></td></tr></table></figure><ul><li>实际运行不了；需要改成如下，并添加自己的秘钥;<ul><li>由于我没买过openAI的API，所以换成了Gemini进行尝试，结果运行出错，调查仓库issue发现此软件未对OpenAI之外的模型进行兼容处理；尽管使用OpenAI的API，也不能OCR；参考如下</li><li><a href="https://github.com/microsoft/markitdown/issues/255">https://github.com/microsoft/markitdown/issues/255</a></li><li><a href="https://github.com/microsoft/markitdown/issues/256">https://github.com/microsoft/markitdown/issues/256</a></li><li><a href="https://github.com/microsoft/markitdown/issues/232">https://github.com/microsoft/markitdown/issues/232</a></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> markitdown <span class="hljs-keyword">import</span> MarkItDown<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 设置 OpenAI API 密钥</span><br>api_key = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入您的 OpenAI API 密钥: &quot;</span>).strip()<br>os.environ[<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>] = api_key<br><br>client = OpenAI()<br>md = MarkItDown(llm_client=client, llm_model=<span class="hljs-string">&quot;gpt-4&quot;</span>)<br>result = md.convert(<span class="hljs-string">&quot;image1.jpg&quot;</span>)<br><span class="hljs-built_in">print</span>(result.text_content)<br><br></code></pre></td></tr></table></figure><h4 id="Markitdown与MinerU对比"><a href="#Markitdown与MinerU对比" class="headerlink" title="Markitdown与MinerU对比"></a>Markitdown与MinerU对比</h4><ul><li>不同<ul><li>Markitdown无OCR功能、无法处理图片、无法处理公式</li><li>Markitdown速度快，不到1s一张10页的论文pdf就被转换完成;而MinerU需要7s左右（在GPU加速下）</li></ul></li><li>共同点<ul><li>Markitdown、MinerU都能将各种文件格式转成markdown，包括PDF、图片、word、excel、ppt等</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>testMinerU</title>
    <link href="/2025/01/06/AI/testMinerU/"/>
    <url>/2025/01/06/AI/testMinerU/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试minerU的过程与结果</p></blockquote><span id="more"></span><h3 id="minerU"><a href="#minerU" class="headerlink" title="minerU"></a>minerU</h3><ul><li><p>可本地部署的一站式开源高质量数据提取工具，将PDF转换成Markdown和JSON格式。转换成这两种格式的目的就是方便将数据提取出来更好地存储&#x2F;传递给相关大模型进行逻辑处理提高解答的准确率；（大模型都是通过markdown或json格式的数据进行训练和响应的）</p></li><li><p>首先要配置相关环境</p><ul><li>具体见 <a href="https://github.com/opendatalab/MinerU/blob/master/docs/README_Windows_CUDA_Acceleration_zh_CN.md?tab=readme-ov-file#command-line">https://github.com/opendatalab/MinerU/blob/master/docs/README_Windows_CUDA_Acceleration_zh_CN.md?tab=readme-ov-file#command-line</a></li><li>每次使用之前，先conda activate MinerU 进入环墶</li><li>GPU配置CUDA加速之后，速度明显提升好几倍，但是效果似乎没变；</li></ul></li><li><p>运行命令</p><ul><li>简单来讲主要功能：magic-pdf -p {pdf文件（夹）路径} -o {输出路径} -m {模式：ocr&#x2F;text&#x2F;auto(default)} –lang (语言：ch、en)<ul><li>提示：选择正确的语言可以显著提高识别准确率。对于混合语言文档，建议使用自动检测模式（默认）。</li></ul></li><li>比如 magic-pdf -p test.pdf -o .&#x2F;Output -m ocr –lang ch 后会在当前目录下生成一个Output文件夹，结构如下<ul><li>Output&#x2F;相应pdf文件名&#x2F;模式&#x2F;识别结果</li><li>具体意义详见：<a href="https://mineru.readthedocs.io/en/latest/user_guide/tutorial/output_file_description.html">https://mineru.readthedocs.io/en/latest/user_guide/tutorial/output_file_description.html</a><br><img src="/2025/01/06/AI/testMinerU/image-31.png" alt="alt text"></li></ul></li><li>详见： <a href="https://mineru.readthedocs.io/en/latest/user_guide/quick_start/command_line.html">https://mineru.readthedocs.io/en/latest/user_guide/quick_start/command_line.html</a></li></ul></li><li><p>测试结果：类似于如下，排版比较简单的合同、文章等等大多是文字的图片，可以ocr识别出来提取文字；而像发票、车票等排版复杂的图片目前minerU识别不了，还是以图片的形式存在于markdown中，</p><ul><li><p>合同、文章：<br><img src="/2025/01/06/AI/testMinerU/image-37.png" alt="alt text"><br><img src="/2025/01/06/AI/testMinerU/image-34.png" alt="alt text"><br><img src="/2025/01/06/AI/testMinerU/image-36.png" alt="alt text"></p></li><li><p>发票、车票</p><p><img src="/2025/01/06/AI/testMinerU/image-38.png" alt="alt text"><br><img src="/2025/01/06/AI/testMinerU/image-39.png" alt="alt text"></p></li></ul></li><li><p>分析原因：</p><ul><li><p>也许是没开GPU加速的原因？试试</p><ul><li>开了之后，速度确实加快了很多，之前30-40s一张pdf，现在不到15s，时长取决于内容的多少,但是发票等图片还是以图片的形式存在于markdown中</li></ul></li><li><p>谷歌之后发现github也有人提出类似的issue</p><ul><li><a href="https://github.com/opendatalab/MinerU/issues/1348">如何实现插图中的文字识别 · Issue #1348 · opendatalab&#x2F;MinerU</a></li><li><a href="https://github.com/opendatalab/MinerU/discussions/795">能不能解析图片中的文字 · opendatalab&#x2F;MinerU · Discussion #795</a></li><li><a href="https://github.com/opendatalab/MinerU/issues/1392">图表 ·问题 #1392 ·开放数据实验室&#x2F;MinerU — Charting · Issue #1392 · opendatalab&#x2F;MinerU</a></li></ul></li><li><p>查看项目readme.md文档</p><ul><li>作者已在Known Issues 说明 some uncommon list formats may not be recognized.<ul><li><a href="https://github.com/opendatalab/MinerU?tab=readme-ov-file#known-issues">https://github.com/opendatalab/MinerU?tab=readme-ov-file#known-issues</a></li></ul></li></ul></li><li><p>尝试解决办法</p><ul><li>不用命令行，改用python代码进行调用强制开启OCR<ul><li>结果：无用</li></ul></li><li>通过paddle去识别那些minerU识别不了的内容<ul><li><a href="https://github.com/PaddlePaddle/PaddleOCR">https://github.com/PaddlePaddle/PaddleOCR</a></li></ul></li><li>我已提交issue，等待作者和大佬们升级项目<ul><li><a href="https://github.com/opendatalab/MinerU/issues/1415">https://github.com/opendatalab/MinerU/issues/1415</a></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>testOCR</title>
    <link href="/2025/01/02/AI/testOCR/"/>
    <url>/2025/01/02/AI/testOCR/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试两款开源OCR工具以及百度飞桨在线产品PP-OCRv4的识别效果</p></blockquote><span id="more"></span><ul><li><p>先说结论：百度的飞桨在线产品<a href="https://aistudio.baidu.com/community/app/91660/webUI">PP-OCRv4</a> 对文字、数字、排版的识别都很不错；开源paddleOCR和Umi-OCR对文字、数字的识别效果都还可以，但是对排版的识别及其导致的输出顺序效果都不太好，二者差不多，相同与不同如下；</p></li><li><p>相同点：</p><ul><li>都可批量OCR</li><li>对文本、数字等等效果比较好，但对布局格式识别、输出顺序不太行。</li><li>对图片、pdf等文件都可以识别</li></ul></li><li><p>不同之处</p><ul><li>Umi-OCR通过应用程序鼠标点击进行操作</li><li>PaddleOCR通过命令行&#x2F;python进行操作,输出结果中含有置信度</li><li>Umi-OCR可识别二维码</li></ul></li><li><p>如下是测试过程：</p></li></ul><h3 id="Umi-OCR"><a href="#Umi-OCR" class="headerlink" title="Umi-OCR"></a><a href="https://github.com/hiroi-sora/Umi-OCR">Umi-OCR</a></h3><ul><li>设置规则<ul><li>多栏：自动识别多栏布局输出</li><li>单栏：不识别布局，从上往下按照一行行的顺序识别和输出</li></ul></li></ul><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-15.png" alt="alt text"></p><h4 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h4><ul><li>效果很好，连格式几乎都一样，除了有些缩进和换行被忽略了；<br><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-7.png" alt="alt text"></li></ul><h4 id="发票1"><a href="#发票1" class="headerlink" title="发票1"></a>发票1</h4><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-13.png" alt="alt text"></p><ul><li>多栏-按自然段换行：最上面盖章处，识别有少许偏差，上面中间部分一行行识别和输出效果还可以，下面列与列之间间隙较大，就变成了一列列识别和输出，键与值之间错位，不方便对应；最右下角可能是光线不好，没识别出来；</li></ul><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-14.png" alt="alt text"></p><ul><li>多栏，总是换行：识别效果和顺序和上方差不多，但每识别一段就换行；</li></ul><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-16.png" alt="alt text"></p><ul><li>单栏：自然换行：从上往下按照一行行的顺序识别和输出，但是遇到一些格式不一样的一起识别就会出现顺序问题</li></ul><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-17.png" alt="alt text"></p><h4 id="发票2"><a href="#发票2" class="headerlink" title="发票2"></a>发票2</h4><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-10.png" alt="alt text"></p><ul><li>多栏-按自然段换行：尽管除了少数和印章重叠的字识别有误之外（蓝色圈出），文字和数字都识别出来了，但是识别和输出格式和输出顺序很糟糕，整体上也是从左向右一列列识别和输出，但他并不是以每列相同的宽度去读取的，像圈1和圈4所在列就比较规则，所以它也能准确读出来，但有些列的宽度并不能包含相应格式的数据保证他们的连贯性；（如图中圈3）</li></ul><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-12.png" alt="alt text"></p><ul><li>单栏：自然换行 ：从上往下按照一行行的顺序识别和输出，语意不连贯，键值不对应，盖章文字未识别出；</li></ul><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-18.png" alt="alt text"></p><ul><li>总结：对纯文本效果比较好，但对布局格式识别不太行；</li></ul><h3 id="开源PaddleOCR"><a href="#开源PaddleOCR" class="headerlink" title="开源PaddleOCR"></a><a href="https://paddlepaddle.github.io/PaddleOCR/latest/ppocr/quick_start.html#3">开源PaddleOCR</a></h3><h4 id="纯文本-1"><a href="#纯文本-1" class="headerlink" title="纯文本"></a>纯文本</h4><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-27.png" alt="alt text"><br><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-29.png" alt="alt text"></p><h4 id="发票1-1"><a href="#发票1-1" class="headerlink" title="发票1"></a>发票1</h4><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-21.png" alt="alt text"></p><h4 id="发票2-1"><a href="#发票2-1" class="headerlink" title="发票2"></a>发票2</h4><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-28.png" alt="alt text"></p><ul><li>总结：和前者效果差不多：对纯文本效果比较好，但对布局格式识别不太行；</li></ul><h3 id="PP-OCRv4-在线"><a href="#PP-OCRv4-在线" class="headerlink" title="PP-OCRv4 在线"></a><a href="https://aistudio.baidu.com/community/app/91660/webUI">PP-OCRv4 在线</a></h3><ul><li>对文本、数字、布局、排版格式等等识别的都很好；唯一缺点就是印章重叠处的文字识别不太精准；</li></ul><h4 id="纯文本-2"><a href="#纯文本-2" class="headerlink" title="纯文本"></a>纯文本</h4><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-23.png" alt="alt text"></p><h4 id="发票"><a href="#发票" class="headerlink" title="发票"></a>发票</h4><p><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-22.png" alt="alt text"><br><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-24.png" alt="alt text"><br><img src="/2025/01/02/AI/testOCR/01/02/AI/testOCR/image-30.png" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vueRouter</title>
    <link href="/2024/10/20/SE/vueRouter/"/>
    <url>/2024/10/20/SE/vueRouter/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Vue3 Router</p></blockquote><span id="more"></span><h3 id="Router路由管理"><a href="#Router路由管理" class="headerlink" title="Router路由管理"></a>Router路由管理</h3><p>在 Vue 3 中，<code>useRoute</code> 和 <code>useRouter</code> 都是 Vue Router 提供的组合式 API，用于在组合式函数中访问路由。</p><p><strong>区别：</strong></p><ul><li><code>useRoute</code> 用于访问当前路由的状态，是只读的。</li><li><code>useRouter</code> 用于执行路由操作，如导航、切换、添加路由等。</li></ul><hr><ul><li><p><strong><code>useRoute</code></strong></p><ul><li><p>返回当前激活的路由信息，是一个只读的响应式对象。</p></li><li><p>可以获取路由的‘meta’、 <code>path</code>、<code>params</code>、<code>query</code>、<code>name</code> 等属性。</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">path</span>) <span class="hljs-comment">// 输出当前路径</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>) <span class="hljs-comment">// 获取路由参数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>useRouter</code></strong></p><ul><li><p>返回当前组件的路由实例对象，可以使用它进行添加路由、导航等操作。</p></li><li><p>提供了‘addRoute’、 <code>push</code>、<code>replace</code> 等方法</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">goHome</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span> &#125;) <span class="hljs-comment">// 导航到名为 &#x27;Home&#x27; 的路由</span><br>  <span class="hljs-comment">//遍历数据中的路由信息添加到main路由下</span><br>  <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>,item)<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transData</title>
    <link href="/2024/10/19/SE/vueTransData/"/>
    <url>/2024/10/19/SE/vueTransData/</url>
    
    <content type="html"><![CDATA[<blockquote><p>讲述Vue3中数据传输的方法以及异步操作</p></blockquote><span id="more"></span><h2 id="Vue3中的数据传递"><a href="#Vue3中的数据传递" class="headerlink" title="Vue3中的数据传递"></a>Vue3中的数据传递</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ol><li>是组件间传递数据的主流方式，尤其是在父子组件关系明确且数据流向单一的情况下。这种方式简单且直观，适合大多数场景。</li><li>子组件使用 props 属性接收父组件传递的数据；</li><li>语法：<code>&lt;子组件 :属性名=&quot;父组件数据&quot;  :属性名=&quot;父组件数据&quot;/&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">   &lt;!-- 父组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;parentMessage&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>   &lt;!-- 选项式 --&gt;<br>&lt;script&gt;<br>   import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>   export default &#123;<br>   data() &#123;<br>      return &#123;<br>         parentMessage: &#x27;Hello from parent&#x27;<br>      &#125;;<br>   &#125;,<br>   components: &#123; ChildComponent &#125;<br>       /* 这行代码是关于组件注册的,必要的，但是如果使用&lt;script setup&gt;则可以省略<br>      组件注册目的：<br><br>      告诉 Vue 这个父组件要使用 ChildComponent 子组件<br>      建立组件间的关联关系<br>      为什么必要：<br><br>      Vue 规定必须先注册组件才能在模板中使用<br>      如果不注册就直接在模板中使用 &lt;ChildComponent&gt;，Vue 会报错<br><br>      */<br>   <br>   &#125;;<br>&lt;/script&gt;<br>&lt;!-- 组合式API --&gt;<br><br>&lt;script setup&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>const parentMessage = &#x27;Hello, Child!&#x27;;<br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 选项式<span class="hljs-variable constant_">API</span><br>   &lt;script &gt;<br>   <br>   <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>      <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;message&#x27;</span>]<br>   &#125;;<br>   &lt;/script&gt; --&gt;<br><br>   &lt;!-- 组合式<span class="hljs-variable constant_">API</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   //编译器宏：defineProps 是由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 &#x27;vue&#x27; 中导入。自动可用：在 <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"> 块内，defineProps 会被自动识别并处理。</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-comment">// 使用 defineProps 声明 props</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-attr">message</span>: &#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;);</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   </span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">   </span><br></code></pre></td></tr></table></figure></li></ol><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><ol><li><p>在子组件中触发事件</p></li><li><p>在父组件中监听事件</p></li><li><p>原理</p><ol><li>事件触发<ol><li>子组件通过 $emit() 触发自定义事件</li><li>可传递数据作为第二个参数</li></ol></li><li>事件监听<ol><li>父组件使用 @事件名 语法监听</li><li>通过回调函数接收数据</li></ol></li><li>数据流向:子组件 -&gt; 触发事件 -&gt; 父组件接收 -&gt; 更新数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>发送消息到父组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br> <br>  &lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  选项式</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">     &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br><br>  &lt;!-- 组合式 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;message-event&#x27;</span>]);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ParentComponent</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>&lt;!-- 选项式 --&gt;<br>&lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title class_">ChildComponent</span><span class="hljs-comment">//注册组件</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">messageFromChild</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">handleMessageEvent</span>(<span class="hljs-params">message</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageFromChild</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br>&lt;!-- 组合式 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li><a href="#%E9%80%9A%E8%BF%87useroot%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">直接通过useRoot获取全局数据，想要谁就直接通过options属性获取</a></li><li>全局状态管理：使用 Vuex 或者 Pinia 来管理全局状态，适用于复杂的应用场景。如下介绍vuex</li><li>Provide&#x2F;Inject API：适用于跨级组件间传递数据。</li><li>事件总线：使用事件总线（Event Bus）来传递数据，但这种方式在 Vue 3 中不推荐使用。</li><li>Context API：在组合式 API 中，可以通过 context 来传递数据。</li></ol></li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><ul><li><p>安装：npm install vuex@next –save</p></li><li><p>核心概念</p><ol><li><p>创建和定义 store</p><ol><li>state: 存储状态信息<ol><li>store&#x2F;下定义状态信息</li><li>在组件中通过有三种方式获取state<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1内置函数computed (推荐)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 优点:</span><br><span class="hljs-comment"> 响应式: 状态变化时会自动更新视图</span><br><span class="hljs-comment"> 缓存: 计算结果会被缓存,只有依赖变化时才重新计算</span><br><span class="hljs-comment">*/</span><br><span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br><br><span class="hljs-comment">//2直接访问 (不推荐)</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  缺点:</span><br><span class="hljs-comment"> 非响应式: 状态变化时不会自动更新视图</span><br><span class="hljs-comment"> 需要手动触发更新</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-attr">count</span>: store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span><br><br><span class="hljs-comment">//3使用 ref + watch (特殊场景)</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 使用场景:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> 需要对状态变化做额外处理</span><br><span class="hljs-comment"> 需要本地维护状态副本</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br> count.<span class="hljs-property">value</span> = newVal<br> &#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>mutations: 同步修改状态<ol><li>store&#x2F;下定义修改状态的方法</li><li>当需要修改状态时，在组件中通过commit相应的mutation和参数(见store&#x2F;下定义修改状态的方法)触发重新处理&amp;赋值给state中的变量来实现状态更新</li></ol></li><li>actions: <a id="异步请求">异步操作</a><ol><li>异步请求是指发出请求后，不会立即得到结果，而是在未来某个时间点才会收到响应的操作。</li><li>为什么需要 Actions<ol><li>Mutations 必须是同步的</li><li>Actions 可以包含异步操作</li><li>Actions 可以组合多个 mutations</li></ol></li><li>使用场景          <ul><li>API 请求等延时操作</li><li>复杂的状态修改流程</li><li>需要组合多个 mutation</li><li>涉及异步操作的业务逻辑：比如定时器、延时操作、文件上传&#x2F;下载等</li></ul></li><li>特点:<ol><li>async 定义异步异步函数</li><li>通过 context 对象访问 store 实例的方法和属性</li><li>可以触发其他 actions (dispatch)</li><li>最终通过 commit 提交 mutation 修改状态</li></ol></li><li>在组件中通过dispatch提交action</li></ol> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br><span class="hljs-attr">state</span>: &#123;<br>   <span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span>,<br>   <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span><br>&#125;,<br><span class="hljs-attr">mutations</span>: &#123;<br>   <span class="hljs-title function_">setUserInfo</span>(<span class="hljs-params">state, info</span>) &#123;<br>      state.<span class="hljs-property">userInfo</span> = info<br>   &#125;,<br>   <span class="hljs-title function_">setLoading</span>(<span class="hljs-params">state, status</span>) &#123;<br>      state.<span class="hljs-property">loading</span> = status<br>   &#125;<br>&#125;,<br><span class="hljs-attr">actions</span>: &#123;<br>   <span class="hljs-comment">// 1. 处理异步操作</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, credentials</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">login</span>(credentials)<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUserInfo&#x27;</span>, response.<span class="hljs-property">data</span>)<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">false</span>)<br>      &#125;<br>   &#125;,<br><br>   <span class="hljs-comment">// 2. 复杂业务逻辑</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">checkout</span>(<span class="hljs-params">&#123; commit, state, dispatch &#125;</span>) &#123;<br>      <span class="hljs-comment">// 检查库存</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;checkStock&#x27;</span>)<br>      <span class="hljs-comment">// 创建订单</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;createOrder&#x27;</span>)<br>      <span class="hljs-comment">// 清空购物车</span><br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;clearCart&#x27;</span>)<br>   &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li>getters: 计算属性<ol><li>store&#x2F;下定义计算相关的方法</li><li>组件中通过store.getters调用相应的方法</li></ol></li><li>modules: 模块化管理状态<ol><li>针对不同联动事件之间有不同的关联状态和操作，因此划分成多个模块，每个模块管理相关的一部分的共享状态会更方便操作；<ol><li>比如Aside和headerNav之间的通信（联动）都是关于菜单的，于是将所有的菜单相关的状态（信息、操作等等）放在一个模块sotore&#x2F;menu.js中</li><li>需要在&#x2F;store&#x2F;index.js中导入所需模块，将创建的store导出；供main.js挂载和其他组件使用；同时模块中只需要定义被其他组件需要的state、mutations、actions、getters并导出</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/sotre/index.js </span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br> <span class="hljs-keyword">import</span> menu <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./menu&quot;</span>;<br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>       menu<br>    &#125;<br> &#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//menu.js</span><br><br><span class="hljs-keyword">const</span> state=&#123;<br>   <span class="hljs-attr">isCollapse</span>:<span class="hljs-literal">false</span>,<span class="hljs-comment">//是否折叠</span><br>   <span class="hljs-attr">selectMenu</span>:[]<span class="hljs-comment">//选中的菜单</span><br>&#125;<br><br><span class="hljs-keyword">const</span> mutations=&#123;<br>   <span class="hljs-title function_">collapseMenu</span>(<span class="hljs-params">state</span>)&#123;<br>      state.<span class="hljs-property">isCollapse</span>=!state.<span class="hljs-property">isCollapse</span><span class="hljs-comment">//取反</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">//从此模块中导出此需要的数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>      state,<br>      mutations<br>&#125;<br><br><br>           <br></code></pre></td></tr></table></figure></li><li>在vuex中如果有模块的话，组件在调用 state 时需要加上模块名，而调用 mutations、actions、getters 时则不需要加模块名。（在vue3_study_basic中亲测）   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span><br>    <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span><br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-comment">// 读取状态</span><br>       <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">count</span>),<br>       <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br>       <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">username</span>),<br>       newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span><br><br>       <span class="hljs-comment">// 状态修改：mutations</span><br>       <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br>       <span class="hljs-comment">// 重置用户名</span><br>       <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>       store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span><br>       newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span><br>       &#125;,<br>       <span class="hljs-comment">//action：异步操作</span><br>       <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span><br>    <br>    &#125;<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>在入口文件main.js中使用:</p><ol><li>创建 store 实例并挂载</li></ol></li><li><p>组件中通过 useStore() 访问和使用 </p><ol><li>如下是一个基础案例额</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br> <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>       <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br> &#125;,<br> <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">// 修改状态的方法</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>       state.<span class="hljs-property">count</span>++<br>    &#125;,<br>    <span class="hljs-title function_">setUsername</span>(<span class="hljs-params">state, username</span>) &#123;<br>       state.<span class="hljs-property">username</span> = username<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>       <span class="hljs-comment">// 模拟API调用</span><br>       <span class="hljs-comment">//使用 new Promise 和 setTimeout 模拟了一个耗时1秒的API调用</span><br>       <span class="hljs-comment">//await 会暂停执行，直到Promise完成</span><br>       <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br>       <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-comment">// 计算属性</span><br>    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params">state</span>) &#123;<br>       <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>    &#125;<br> &#125;<br> &#125;)<br><br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- main.<span class="hljs-property">js</span> --&gt;<br> <span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br> <span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br> <span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br> <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br> app.<span class="hljs-title function_">use</span>(store)<br> app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 组件.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Double Count: &#123;&#123; doubleCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Username: &#123;&#123; username || &#x27;未登录&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   </span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 点击按钮触发login方法,传入参数admin到login action --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login(&#x27;admin&#x27;)&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 添加重置按钮 --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;newUsername&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入新用户名&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">   &gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;resetUsername&quot;</span>&gt;</span>Reset User<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 读取状态</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">username</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 状态修改：mutations</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 重置用户名</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//action：异步操作</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="vuex持久化"><a href="#vuex持久化" class="headerlink" title="vuex持久化"></a><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%B7%BB%E5%8A%A0+vuex%E6%8C%81%E4%B9%85%E5%8C%96">vuex持久化</a></h4><ul><li><p>vuex-persistedstate 将 store 存储到浏览器的时机如下：这种机制确保了在页面刷新或重新打开后能够恢复之前的状态。</p></li><li><p>主要存储时机</p></li></ul><ol><li><p><strong>Store 发生变化时</strong></p><ul><li>当通过 mutation 修改 state 时</li><li>在每次 state 更新后自动触发</li></ul></li><li><p><strong>具体触发点</strong></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听 store 的变化</span><br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 将数据持久化到 localStorage</span><br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;vuex&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>存储行为特点</li></ul><ol><li><p><strong>实时性</strong></p><ul><li>同步执行，立即存储</li><li>不需要手动触发</li></ul></li><li><p><strong>选择性存储</strong></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> createPersistedState <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex-persistedstate&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">createPersistedState</span>(&#123;<br>      <span class="hljs-attr">paths</span>: [<span class="hljs-string">&#x27;需要持久化的state路径&#x27;</span>]  <span class="hljs-comment">// 可以选择性存储</span><br>    &#125;)<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>存储位置</strong><ul><li>默认使用 localStorage</li><li>可配置使用 sessionStorage 或其他存储方式</li></ul></li></ol><p><code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器。相反，它会从浏览器的存储（如<br>localStorage或 <code>sessionStorage</code>）中读取之前保存的状态，并将其恢复到 Vuex store 中。</p><ul><li>工作流程：</li></ul><ol><li><p><strong>页面加载时</strong>：</p><ul><li><code>vuex-persistedstate</code> 插件会从浏览器存储中读取之前保存的 Vuex 状态。</li><li>将读取到的状态合并到当前的 Vuex store 中。</li></ul></li><li><p><strong>状态变化时</strong>：</p><ul><li>当 Vuex store 中的状态发生变化时（通过 mutation），<code>vuex-persistedstate</code> 会将新的状态存储到浏览器中。</li></ul></li></ol><ul><li><p>总结：</p></li><li><p><strong>页面加载时</strong>：<code>vuex-persistedstate</code> 从浏览器存储中恢复状态到 Vuex store。</p></li><li><p><strong>状态变化时</strong>：<code>vuex-persistedstate</code> 将新的状态存储到浏览器中。</p></li></ul><p>因此，<code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器，而是从浏览器中读取之前保存的状态并恢复。</p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><ul><li><p>什么是<a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82">异步请求</a>？</p></li><li><p>Promise 是处理异步操作的一种方式，它代表一个异步操作的最终完成(或失败)及其结果值。</p><ul><li>基本用法</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 基础语法</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">if</span> (成功) &#123;<br>    <span class="hljs-title function_">resolve</span>(结果)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(错误)<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 2. 使用Promise</span><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理成功</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理失败</span><br>  &#125;)<br></code></pre></td></tr></table></figure><ul><li>实际示例</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 封装API请求</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(response.<span class="hljs-property">data</span>))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">reject</span>(error))<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 2. 使用async/await简化</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserData</span>(userId)<br>    <span class="hljs-keyword">return</span> data<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取用户数据失败:&#x27;</span>, error)<br>  &#125;<br>&#125;<br><span class="hljs-comment">//3. 延时</span><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>   <span class="hljs-comment">//延时1秒</span><br><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br><span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<span class="hljs-comment">//最终通过 commit 提交 mutation 修改状态</span><br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>凡是内部调用多个函数且要讲究执行顺序的的函数要用异步async申明；异步操作内部要使用await调用已存在的方法，外部也要用async申明参数，每一环都是如此；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//group/index.vue的提交弹窗逻辑</span><br><span class="hljs-keyword">const</span> localData=<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;pz_v3pz&#x27;</span>)<br><span class="hljs-keyword">import</span> &#123; computed, toRaw &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> routerList=<span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>store.<span class="hljs-property">state</span>.<span class="hljs-property">menu</span>.<span class="hljs-property">routerList</span>)<br><span class="hljs-comment">//内有异步操作</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">confirm</span>=<span class="hljs-keyword">async</span> (<span class="hljs-params">formEl</span>)=&gt;&#123;<br>  <span class="hljs-keyword">if</span> (!formEl) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">//内有异步操作</span><br>  <span class="hljs-keyword">await</span> formEl.<span class="hljs-title function_">validate</span>( <span class="hljs-title function_">async</span>(valid,fields)=&gt;&#123;<br>    <span class="hljs-keyword">if</span> (valid) &#123;<br>      <span class="hljs-comment">//根据APi文档可知，其中一个参数为permissions：string,故要将选中的权限字符串化</span><br>      <span class="hljs-keyword">const</span> permissions = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(treeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">getCheckedKeys</span>())<br>      <span class="hljs-comment">// console.log(permissions)</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1. 先执行 userSetMenu请求重新设置菜单数据</span><br><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">userSetMenu</span>(&#123;<br>          <span class="hljs-attr">name</span>: form.<span class="hljs-property">name</span>,<br>          permissions,<span class="hljs-comment">//参数名与变量名同名时，可以简写：一个即可，不需要：</span><br><br>          <span class="hljs-attr">id</span>: form.<span class="hljs-property">id</span><br>        &#125;)<br>        <br>        <span class="hljs-comment">// 2. 更新列表数据</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">getListData</span>()<br>        <br>        <span class="hljs-comment">// 3. 关闭弹窗</span><br>        <span class="hljs-title function_">beforeClose</span>()<br>        <br>        <span class="hljs-comment">// 4. 再执行 menuPermissions</span><br>        <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">menuPermissions</span>()<br>        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;dynamicMenu&#x27;</span>, data.<span class="hljs-property">data</span>)<br>        <br>        <span class="hljs-comment">// 5. 添加路由</span><br>        <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>, item)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;操作失败:&#x27;</span>, error)<br>      &#125;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error submit!&#x27;</span>,fields)<br>    &#125;<br>  &#125;)<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueKey</title>
    <link href="/2024/10/17/SE/VueKey/"/>
    <url>/2024/10/17/SE/VueKey/</url>
    
    <content type="html"><![CDATA[<blockquote><p>vue3核心语法</p></blockquote><span id="more"></span><h3 id="vue3核心语法"><a href="#vue3核心语法" class="headerlink" title="vue3核心语法"></a>vue3核心语法</h3><ul><li>hook<ul><li><p>简单来讲就是自定义的包&#x2F;库（python等各种语言中都有）；是Vue 3中的重要特性，通过组合式API实现了对状态和副作用的管理，使得逻辑复用变得更加简单和高效。与传统的mixins相比，Hooks提供了更好的灵活性和可维护性，是现代Vue开发中不可或缺的一部分。主要用于封装可重用的逻辑和管理组件的状态、生命周期以及副作用。允许开发者以函数的形式组织和复用代码，从而提高代码的可维护性和可读性。</p></li><li><p>Vue Hook的作用</p><ul><li><p><strong>状态逻辑复用</strong>：Vue Hook允许在多个组件之间共享状态逻辑，避免重复代码。例如，可以创建一个自定义Hook来处理表单输入状态，然后在多个表单组件中使用。</p></li><li><p><strong>生命周期管理</strong>：Hooks提供了一系列生命周期钩子函数，如<code>onMounted</code>、<code>onUpdated</code>、<code>onUnmounted</code>等，帮助开发者在组件不同阶段执行特定操作。例如，可以在组件挂载后发起数据请求，或在组件卸载前清理定时器。</p></li><li><p><strong>简化代码结构</strong>：通过将逻辑封装到Hooks中，可以使组件代码更简洁，逻辑更集中，便于理解和维护。这种方式比传统的mixins更清晰，因为Hooks是以函数形式存在，避免了命名冲突和逻辑散落的问题。</p></li><li><p><strong>响应式数据处理</strong>：使用Hooks时，可以利用Vue 3中的响应式API（如<code>ref</code>、<code>reactive</code>、<code>computed</code>）来创建响应式数据，使得状态管理更加直观和高效。</p></li></ul></li><li><p>自定义Hooks：是开发者根据需要创建的函数，通常以<code>use</code>开头，例如<code>useFetchData</code>。这些函数可以调用其他Hooks，并返回响应式数据或方法，以供组件使用。自定义Hooks的基本规范包括：</p><ul><li><p>函数名以<code>use</code>开头。</p></li><li><p>在组件的<code>setup</code>函数中调用自定义Hook。</p></li><li><p>返回响应式变量或方法，以便在组件中解构使用。</p><p>例如，一个简单的自定义Hook可以用于处理本地存储：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) &#123;<br>   <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(initialValue);<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)) &#123;<br>      data.<span class="hljs-property">value</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key));<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(initialValue));<br>   &#125;<br><br>   <span class="hljs-title function_">watch</span>(data, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newValue));<br>   &#125;);<br><br>   <span class="hljs-keyword">return</span> &#123; data &#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   1. **数据持久化存储**:</span><br><span class="hljs-comment">   if (localStorage.getItem(key)) &#123;</span><br><span class="hljs-comment">      data.value = JSON.parse(localStorage.getItem(key));</span><br><span class="hljs-comment">   &#125; else &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(initialValue));</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   - 当首次使用时，如果 localStorage 中不存在数据，则存入初始值</span><br><span class="hljs-comment">   - 如果已存在数据，则读取已保存的数据</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   2. **响应式数据管理**:</span><br><span class="hljs-comment">   const data = ref(initialValue);</span><br><span class="hljs-comment">   - 使用 ref创建响应式数据，可以在组件中实时反映数据变化</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   3. **自动同步到 localStorage**:</span><br><span class="hljs-comment">   watch(data, (newValue) =&gt; &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(newValue));</span><br><span class="hljs-comment">   &#125;);</span><br><span class="hljs-comment">   - 通过 watch监听数据变化</span><br><span class="hljs-comment">   - 当数据发生变化时，自动更新到 localStorage 中</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   使用示例(在src/view/try.vue中):</span><br><span class="hljs-comment">   const &#123; data &#125; = useLocalStorage(&#x27;myData&#x27;, &#123; name: &#x27;default&#x27; &#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   这样就创建了一个在组件和 localStorage 之间自动同步的响应式数据。</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><p>在组件中使用时，可以这样引入并使用这个Hook：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> useLocalStorage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useLocalStorage&#x27;</span>;<br><br><span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">&#x27;myData&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;default&#x27;</span> &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>&lt;RouterView /&gt; </code><a id="RouterView"></a><ul><li><p><code>&lt;RouterView /&gt;</code> 是 Vue Router 的核心组件之一，它的主要作用是作为路由匹配到的组件的渲染出口。是实现前端路由的关键组件，它让我们能够根据 URL 的变化动态渲染不同的组件内容。</p></li><li><p>主要作用</p><ol><li><p><strong>组件渲染容器</strong></p><ul><li>它会根据当前的路由路径（URL）</li><li>自动渲染与该路径匹配的组件</li><li>相当于一个动态组件的占位符</li></ul></li><li><p><strong>动态更新</strong></p><ul><li>当路由发生变化时<code>&lt;RouterView /&gt;</code> 会自动更新渲染的内容,无需手动干预</li></ul></li></ol></li><li><p>使用场景:内容需要根据路由变化而变化</p><ul><li>看他的上一级路由的组件的相应变化位置就是它的出口；<ul><li>比如项目中整个&#x2F;下的第一级路由的出口就在src\App.vue（在&#x2F;xx下随着路由整个页面都变化）</li><li>菜单嵌套路由的出口在src\view\Main.vue（Layout组件）中的el-main中；在&#x2F;path&#x2F;xx下切换路由只相应修改页面布局中的el-main中的内容</li></ul></li></ul><ol><li><p><strong>布局组件中</strong></p><ul><li>作为内容区域的容器</li><li>常见于后台管理系统的布局中</li></ul></li><li><p><strong>嵌套路由</strong></p><ul><li>当需要实现多层级路由时,父路由组件相应位置放置 <code>&lt;RouterView /&gt;</code>，子路由的组件会在这里渲染</li></ul></li><li><p><strong>路由过渡动画</strong></p><ul><li>可以配合 <code>&lt;transition&gt;</code> 使用</li><li>为路由切换添加动画效果</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;transition name=<span class="hljs-string">&quot;fade&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li>在 Vue 2、3 中，<code>@</code> 是 <code>v-on</code> 指令的简写，用于监听 DOM 事件并执行相应的 JavaScript 代码。在 Vue 3 中，使用 <code>:</code> 符号来表示属性绑定是一个重要的语法特性。这种写法源于 Vue 的响应式特性，允许开发者将组件的属性（props）与数据模型进行绑定，从而实现动态更新。<ul><li>注意绑定的值必须满足如下规则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//可行的情况</span><br> 变量：:value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//message必须是被定义过的变量</span><br> 表达式：:value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//count必须是被定义过的变量</span><br> 字符串字面量：:value=<span class="hljs-string">&quot;&#x27;hello&#x27;&quot;</span>（三个引号）<br> 对象：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span><br> 数组：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span><br> 布尔值：:disabled=<span class="hljs-string">&quot;false&quot;</span><br> <span class="hljs-comment">//不可行</span><br> :value=<span class="hljs-string">&#x27;hello&#x27;</span><br> :value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//但是message没有被定义</span><br> :value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//但是count没有被定义</span><br> <span class="hljs-comment">//举例说明:当我插入ep input组件时</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  :prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;显示不了，因为v-bing绑定了<span class="hljs-title class_">Search</span>但它没有被定义<br> <span class="hljs-comment">//其实我想要的search就是一个常量字符串，正确写法如下：去掉:或者使用三引号表示字符串常量</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;验证码&quot;</span>  <span class="hljs-attr">:prefix-icon</span>=<span class="hljs-string">&quot;&#x27;Search&#x27;&quot;</span> &gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><ul><li><p>属性绑定语法</p><ul><li><p>基本用法</p><ul><li><strong>属性绑定</strong>：使用 <code>:</code> 符号（相当于 <code>v-bind</code> 的简写）来将数据绑定到组件的属性上。例如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">:some-prop</span>=<span class="hljs-string">&quot;dataValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>   <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;width:&#x27;230px&#x27;&#125;&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>some-prop</code> 是子组件的一个 prop，而 <code>dataValue</code> 是父组件中的一个数据属性。</p><ul><li><p>动态绑定</p></li><li><p><strong>动态属性</strong>：可以使用表达式动态计算属性值。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;inputValue&quot;</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;isDisabled&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这里，<code>value</code> 和 <code>disabled</code> 属性会根据 <code>inputValue</code> 和 <code>isDisabled</code> 的值动态更新。</p><ul><li><p>使用对象语法</p></li><li><p><strong>对象语法</strong>：可以将多个属性一起绑定到组件上。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; propA: valueA, propB: valueB &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用这种方式，可以在一个对象中传递多个属性。</p></li></ul></li><li><p>事件处理语法</p><p>  <strong><strong>基本用法</strong></strong></p><ul><li><p><strong>监听事件</strong>：使用 <code>v-on</code> 指令（简写为 <code>@</code>）来监听事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 上述代码中的 <code>handleClick</code> 是一个在组件中定义的方法，当按钮被点击时，该方法将被调用。</p></li><li><p><strong>内联事件处理器</strong>：可以直接在模板中编写 JavaScript 代码，例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;alert(&#x27;Button clicked!&#x27;)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 在这个例子中，点击按钮会弹出一个警告框。</p></li></ul><p>  <strong><strong>事件参数</strong></strong></p><ul><li><p><strong>访问原生事件</strong>：在事件处理方法中，可以访问原生 DOM 事件对象。该对象会自动作为参数传递给方法。例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br><span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 输出触发事件的元素</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>$event</code></strong>：在内联处理器中，可以通过特殊变量 <code>$event</code> 来访问原生事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick($event)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>  <strong><strong>修饰符</strong></strong></p><p>  Vue 提供了一些修饰符来控制事件的行为，例如：</p><ul><li><p><strong><code>.stop</code></strong>：阻止事件冒泡。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>.prevent</code></strong>：阻止默认行为。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;submitForm&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>.self</code></strong>：仅当事件目标是元素本身时才触发处理器。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>Click me only if clicked on this div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>自定义事件</p></li></ul><p>  Vue 的组件之间可以通过自定义事件进行通信。子组件可以使用 <code>$emit</code> 方法向父组件发送事件。例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;custom-event&#x27;</span>, payload);<br></code></pre></td></tr></table></figure><p>  父组件则可以通过 <code>@custom-event</code> 来监听这个自定义事件：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">custom-event</span>=<span class="hljs-string">&quot;parentMethod&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>变量： Vue3 中变量的使用场景</p><ol><li>使用 <code>&#123;&#123; &#125;&#125;</code> 插值语法</li></ol><ul><li>在模板中显示变量值</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 显示数据 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count + 1 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; isActive ? &#x27;激活&#x27; : &#x27;未激活&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用单引号 <code>&#39;&#39;</code></li></ol><ul><li>字符串字面量</li><li>静态值</li><li>变量作各种参数，比如store.commit&#x2F;dispatch等等</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>使用 <code>:</code> 或 <code>v-bind</code></li></ol><ul><li>动态绑定属性</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 动态绑定 --&gt;<br>&lt;div :class=&quot;&#123;&#x27;click-enabled&#x27;: !flag&#125;&quot;&gt;//代表flag为false时，class为click-enabled，否则没有class<br>&lt;img :src=&quot;imgUrl&quot;&gt;<br>&lt;el-button :type=&quot;buttonType&quot;&gt;<br>&lt;div :style=&quot;&#123; width: width + &#x27;px&#x27; &#125;&quot;&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ol start="4"><li>使用 <code>@</code> 或 <code>v-on</code></li></ol><ul><li>事件绑定</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 事件绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;handleInput&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="5"><li>使用 <code>v-model</code></li></ol><ul><li>双向数据绑定</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 双向绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="6"><li>使用 <code>v-if/v-show</code></li></ol><ul><li>条件渲染</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><ul><li>总结：<ul><li><code>&#123;&#123; &#125;&#125;</code>: 显示变量值</li><li><code>&#39;&#39;</code>: 静态值</li><li><code>:</code>: 动态属性绑定</li><li><code>@</code>: 事件绑定</li><li><code>v-model</code>: 双向绑定</li><li><code>v-if/v-show</code>: 条件渲染</li></ul></li></ul></li></ul></li></ul><h4 id="nextTick-object-assign"><a href="#nextTick-object-assign" class="headerlink" title="nextTick&amp;object.assign "></a><a id="nextTick&object.assign">nextTick&amp;object.assign </a></h4><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><code>nextTick</code></h4><p><code>nextTick</code> 是 <strong>Vue.js</strong> 提供的一个方法，用于在下一次 DOM 更新循环结束之后执行延迟回调。在修改数据后立即使用 <code>nextTick</code>，可以在回调中获取更新后的 DOM。</p><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    count.<span class="hljs-property">value</span>++;<br>    <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 在这里可以访问更新后的 DOM</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM 已更新&#x27;</span>);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123; count, increment &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>当你在修改响应式数据后，需要在 DOM 更新完成后执行某些操作时，使用 <code>nextTick</code>。</li><li>常见场景包括获取更新后的 DOM 元素的尺寸或状态。</li></ul><hr><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h4><p><code>Object.assign</code> 是 <strong>JavaScript</strong> 中的一个静态方法，用于将一个或多个源对象的可枚举属性复制到目标对象中。返回目标对象。也称为合并对象。</p><p><strong>语法：</strong></p><ol><li>如果target存在source中的属性就会被重写赋值，如果不存在就会创造这个属性然后赋值过去；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, ...sources);<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：目标对象。</li><li><code>sources</code>：源对象。</li></ul><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//或者&#123;a:1&#125;,输出结果一样</span><br><span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source1, source2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target); <span class="hljs-comment">// 输出：&#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p><code>Object.assign</code> 常用于对象的合并或浅拷贝。</p></li><li><p>如果目标对象与源对象有相同的属性，后面的属性会覆盖前面的属性。</p></li><li><p>参考</p><ul><li><a href="https://www.bilibili.com/video/BV1nV411Q7RX/?vd_source=a02025349c3063d9c9143f9bd7489fdf">【2024最新版】3小时学会Vue3，小白零基础视频教程，web前端快速入门实战课程_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1oj411D7jk/?vd_source=a02025349c3063d9c9143f9bd7489fdf">30分钟学会Vue之核心语法 趁着暑假掌握一门技能 大学生前端实习毕业设计必备技能_哔哩哔哩_bilibili</a></li><li><a href="https://juejin.cn/post/7225267685763907621#heading-1">十分钟，带你了解 Vue3 的新写法最近因为项目需要，不得不学习一下 Vue3。于是花了 4 个小时，把 Vue3 过了 - 掘金</a></li><li><a href="https://juejin.cn/post/7122760155707473956?searchId=20241108152858B987C89A8A08662B99ED">超极速的Vue3上手指北笔者之前是Vue2+React开发者，因项目需要直接上手Vue3，所以快速学习一下，中间会对比一 - 掘金</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vueVite</title>
    <link href="/2024/10/16/SE/vueVite/"/>
    <url>/2024/10/16/SE/vueVite/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述使用Vite搭建Vue3项目的结构及其作用</p></blockquote><span id="more"></span><h2 id="项目结构及其作用"><a href="#项目结构及其作用" class="headerlink" title="项目结构及其作用"></a>项目结构及其作用</h2><ol><li>根目录：<ol><li>package.json：这个文件包含了项目的依赖项、脚本等信息，是整个项目的元数据。</li><li>vue.config.js：这是用于配置 Vite 的主要文件。在这里，你可以定义环境变量、设置插件、调整打包选项等。这是一个非常重要的配置文件，它会影响到你的开发体验和生产部署过程</li></ol></li><li>public：包含了一些静态资源，比如图标、favicon.ico、robots.txt 等。这些文件会被直接复制到构建目录中，不会经过 Vite 的处理。<ol><li>在组件中导入public中的静态资源时不需要完整的路径，直接&#x2F;文件名即可比如<code>import qrImg from &#39;/qr.png&#39;</code>;导入public中的二维码图片</li></ol></li><li>src 文件夹：在 Vite 中最核心的一个文件夹，因为它存放着所有的源代码： index.htm-main.js-index.js、App.vue-其他view、components组件-静态资源（图片、cdn等等）<ol><li>assets 文件夹：用来存储静态资源，如图片、样式表等，这些资源通常不会经常变化，可以直接复制到服务器上</li><li>components 文件夹：存放的是你写好的复用组件，每个子文件夹代表一类相关的组件，比如说有一个 base 或者 app 组件，然后再根据具体功能划分出不同的模块（例如：button、table 等）。在vue项目中可以将其中的文件称为vue文件：封装和组织组件的模板、逻辑和样式，使得组件的开发和管理更加高效和模块化（往往在components下创造组件，在view下的vue文件中引用组件），提高了代码的可维护性和复用性：其基础结构如下：<ol><li><p><code>&lt;template&gt;&lt;/template&gt;</code>:内含html代码，用于组成页面结构</p><ol><li>浏览器中不会存在<code>&lt;template&gt;</code>标签的原因是，Vue会在编译过程中将<code>&lt;template&gt;</code>中的内容转换为JavaScript渲染函数。在这个过程中，Vue会解析<code>&lt;template&gt;</code>的内容并生成虚拟DOM，而这个虚拟DOM最终会被渲染到实际的DOM中。</li><li>编译过程：<ol><li>解析模板：Vue使用vue-template-compiler库将<code>&lt;template&gt;</code>块中的HTML字符串解析为抽象语法树（AST），这表示了模板的结构。</li><li>生成渲染函数：AST会被转换为JavaScript代码，这些代码负责创建虚拟DOM节点。每当组件需要渲染时，Vue会调用这些渲染函数，而不是直接使用<code>&lt;template&gt;</code>中的内容。</li><li>更新DOM：当数据变化时，Vue会根据虚拟DOM的变化来更新实际的DOM。</li></ol></li></ol></li><li><p>调用组件</p><ol><li>引入组件有两种方式<ol><li>直接在要使用的页面中导入</li><li>在main.js中导入，然后app.component（”组件名称”,组件）注入全局这样就可以在全局使用了</li></ol></li><li>在组件中调用的组件名称也有两种方式<br>在 Vue.js 中，当您在 <code>main.js</code> 中全局注册组件时，例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PanelHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/PanelHead.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;PanelHead&#x27;</span>, <span class="hljs-title class_">PanelHead</span>);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><p>尽管您注册的组件名称是 <code>&#39;PanelHead&#39;</code>，但在模板中可以使用 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code> 或<code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code>的形式来引用，</p><p><strong>原因如下：</strong></p><ol start="3"><li><p><strong>组件名的大小写不敏感解析：</strong></p><p>Vue 在解析模板时，会将自定义组件标签名中的连字符形式（kebab-case）和大驼峰形式（PascalCase）都识别为同一个组件。例如：</p><ul><li><code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code></li><li><code>&lt;panel-head&gt;&lt;/panel-head&gt;</code></li></ul><p>上述两种写法都会被解析为注册的 <code>&#39;PanelHead&#39;</code> 组件。</p></li><li><p><strong>组件名的规范化：</strong></p><p>根据 Vue 的组件名解析规则，注册时的组件名会被标准化处理，模板中的标签名也会被转换为相应的格式，以进行匹配。</p><ul><li>注册组件时使用 PascalCase（大驼峰命名）的名称。</li><li>在模板中，可以使用 PascalCase 或 kebab-case（短横线命名）形式的组件标签。</li></ul></li><li><p><strong>HTML 中的大小写不敏感性：</strong></p><ul><li>在浏览器解析 HTML 时，标签名是大小写不敏感的。</li><li>为了遵循 HTML 规范，Vue 推荐在模板中使用 kebab-case 的组件名。</li></ul></li></ol><p><strong>总结：</strong></p><ul><li><strong>注册组件：</strong> 使用 PascalCase 命名，例如 <code>&#39;PanelHead&#39;</code>。</li><li><strong>在模板中引用：</strong> 可以使用 <code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code> 或 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，Vue 都能够正确解析。</li><li><strong>推荐使用：</strong> 在模板中使用 kebab-case 形式，即 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，以符合 HTML 规范和提高可读性。</li></ul></li><li><p><a id="vue3核心"></a>组合式API与选项式API的对比（本项目中使用组合式API）</p><ol><li><p>组合式API：Vue3提供了丰富的组合式API，帮助开发者管理组件的行为，核心功能如下：</p><ol><li><code>&lt;script setup&gt;</code> 是在单文件组件中使用组合式 API 的编译时语法糖。主要特点：<ol><li><p>顶层变量&#x2F;函数自动暴露给模板：意思是说<code>&lt;script setup&gt;</code> 中定义的变量和函数会自动暴露给当前组件的模板使用;这种暴露仅限于当前组件内部的 template 部分;</p><ol><li>无需 return 和 export 语句</li><li>引入的组件自动注册</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>   &lt;script setup&gt;<br>   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br>   <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span><br><br>   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++<br>   &lt;/script&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   <span class="hljs-string">``</span><span class="hljs-string">`              </span><br><span class="hljs-string">2. 组件实例的访问:父组件通过 ref 访问子组件时，访问的是子组件的实例;出于安全考虑，Vue 3 默认关闭了组件实例的属性访问需要通过 defineExpose 明确声明哪些属性/方法可以被父组件访问;</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br>      &lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)          <span class="hljs-comment">// ✅ 自动暴露给当前模板使用</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">defineExpose</span>(&#123; count &#125;) <span class="hljs-comment">// ✅ 显式暴露给父组件访问</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;&#123; count &#125;&#125;  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 count --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 increment --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 父组件 <span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// 访问子组件实例的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childRef.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>)        <span class="hljs-comment">// ✅ 可以访问（因为被 defineExpose 暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   childRef.<span class="hljs-property">value</span>.<span class="hljs-property">increment</span>          <span class="hljs-comment">// ❌ 不能访问（未被暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li><li><p>这种设计的目的是：</p><pre><code class="hljs">     提高代码的可维护性     增强组件的封装性     避免父组件随意访问和修改子组件的内部状态</code></pre></li></ol></li><li>响应式系统：数据变更自动触发视图更新</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// ref 基本类型响应式</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>count.<span class="hljs-property">value</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br><br><span class="hljs-comment">// reactive 对象响应式</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;)<br>state.<span class="hljs-property">age</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br></code></pre></td></tr></table></figure><ol start="3"><li><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html">生命周期钩子</a>(选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子。组合式 API：需要手动导入所需的响应式函数和生命周期钩子，从而提供更灵活和模块化的代码结构，他们俩周期钩子也有差别；比如组合式没有beforecreate，把setup当created用，其它就当改了个名)</li></ol><p><img src="/2024/10/16/SE/vueVite/note_vue/1731056688357.png" alt="1731056688357"></p><p><img src="/2024/10/16/SE/vueVite/note_vue/image.png" alt="alt text"><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span></span><br><span class="language-xml">      增加 1</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">import</span> &#123; ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染之前调用的时beforeMount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染完成调用的时mounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之前调用的时beforeUpdate函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之后调用的时updated函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之前调用的时beforeUnmount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之后调用的时unmounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><br> 4. 响应式监听<br>    1. watch的两个参数<br>       1. watch 的第一个参数需要是一个响应式数据（可以是多个），或者是一个返回值的函数。（比如返回一个对象obj的属性() &#x3D;&gt; obj.age）<br>       2. 箭头函数(newValue,oldValue) &#x3D;&gt; {}<br>          1. oldValue：监听的值在变化之前的值<br>          2. newValue：监听的值在变化之后的值<br>    2. watch的触发条件<br>       1. 要让 watch 监听器生效，需要在运行时修改被监听的响应式数据。直接在代码中修改变量的初始值（即在组件加载前设置的值）并不会触发 watch 的回调函数。watch 的作用是监听响应式数据的变化，当数据在运行时发生改变时（例如用户点击按钮触发事件函数），watch 才会检测到这种变化并执行回调函数。<br>    3.  watch的两个属性：<br>       1. immediate（获取初始化）：当设置为 true 时，监听器会在绑定后立即触发回调函数。这意味着在初始化阶段，即使被监听的值没有发生变化，回调函数也会被调用一次。作用如下<br>          1. 在组件加载时，需要根据初始值执行一些操作，例如根据初始参数请求数据。而不必等待被监听的值发生变化。<br>          2. 在组件创建时，需要将某些响应式数据同步到其他地方<br>          3. 在初始化组件的时候oldValue是undefined，newValue是当前值(初始值)<br>       2. deep：true<br>          1.  Vue3 的 reactive 会自动对对象进行深层代理（Proxy），所以：当直接修改 监听对象的内置嵌套对象时，两个监听器都会触发<br>          2.  deep: true 主要用于以下场景：<br>              1.  当你使用 reactive 对象作为 watch 的源，且需要在对象被整个替换时触发监听<br>              2.  当监听的是一个返回非响应式对象的 getter 函数时<br>            <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> deep = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,<br>   <span class="hljs-attr">info</span>: &#123;<br>      <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>      <span class="hljs-attr">contacts</span>: &#123;<br>         <span class="hljs-attr">phone</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>         <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;test@example.com&#x27;</span><br>      &#125;<br>&#125;<br>&#125;)<br><span class="hljs-title function_">watch</span>(deep, <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj changed&#x27;</span>)<br>&#125;)<span class="hljs-comment">//vue3自带不需要deep</span><br><br><span class="hljs-comment">// 如果是这种情况，则需要 deep: true：当改变的是 deep.info时，returnNonReactiveObj会被整个替换</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">returnNonReactiveObj</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br><span class="hljs-attr">info</span>: deep.<span class="hljs-property">info</span><br>&#125;)<br><span class="hljs-title function_">watch</span>(returnNonReactiveObj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;non-reactive obj changed:&#x27;</span>, newValue)<br>&#125;, &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;)<br><br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br> <span class="hljs-keyword">import</span> &#123; ref, reactive, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br> <span class="hljs-keyword">const</span> counter1 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-keyword">const</span> counter2 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-comment">// 监听多个</span><br> <span class="hljs-title function_">watch</span>([counter1, counter2], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter1 value is: &#x27;</span> + counter1.<span class="hljs-property">value</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter2 value is: &#x27;</span> + counter2.<span class="hljs-property">value</span>)<br> &#125;)<br><br> <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br> &#125;)<br> <span class="hljs-comment">//监听初始化值</span><br> <span class="hljs-title function_">watch</span>(obj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br> <span class="hljs-comment">// watch监听单个属性</span><br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">name</span>, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br><br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>计算属性:更加灵活，可以在定义响应式变量时声明;<code>computed</code> 可以用于任何类型的数据处理，不仅限于数值计算。</p><ol><li>核心优势<ul><li>可处理任何数据类型</li><li>自动跟踪依赖关系</li><li>具有缓存机制</li><li>提高代码可读性和维护性</li></ul></li><li>以下是一些常见用例<ol><li><strong>字符串处理</strong></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串转换</span><br><span class="hljs-keyword">const</span> upperCase = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> name.<span class="hljs-property">value</span>.<span class="hljs-title function_">toUpperCase</span>())<br><span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;firstName.value&#125;</span> <span class="hljs-subst">$&#123;lastName.value&#125;</span>`</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>数组处理</strong></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数组过滤</span><br><span class="hljs-keyword">const</span> activeTodos = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>))<br><span class="hljs-comment">// 数组排序</span><br><span class="hljs-keyword">const</span> sortedList = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> items.<span class="hljs-property">value</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>))<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>对象处理</strong></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象转换</span><br><span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;user.value.firstName&#125;</span> <span class="hljs-subst">$&#123;user.value.lastName&#125;</span>`</span>,<br>  <span class="hljs-attr">age</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span>,<br>  <span class="hljs-attr">isAdult</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span><br>&#125;))<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>复杂逻辑</strong></li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 购物车计算</span><br><span class="hljs-keyword">const</span> cartTotal = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> cart.<span class="hljs-property">value</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> total + (item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li>字符倒序</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;this is a value&#x27;</span>)<br><br><span class="hljs-comment">// 注意这里</span><br><span class="hljs-keyword">const</span> reversedValue = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// 使用 ref 需要 .value</span><br><span class="hljs-keyword">return</span> value.<span class="hljs-property">value</span><br>   .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>条件渲染和列表渲染</p><ol><li><p>v-for的参数</p><ol><li>如下代码中的v-for&#x3D;”(item, index) in props.menuData” 中：这个 index 是 Vue 提供的数组索引值，是 v-for 指令内置提供的第二个参数表示当前遍历项在数组中的索引值(从0开始)是可选参数,如果不需要索引值，可以省略</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">!-- 假设 props.<span class="hljs-property">menuData</span> 是这样的数组 --&gt;<br>  [<br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单1&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 0</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单2&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 1</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单3&#x27;</span> &#125; &#125;   <span class="hljs-comment">// index = 2</span><br>  ]                       <br>   v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, index) in array&quot;</span><br>  <span class="hljs-comment">// item: 当前项</span><br>  <span class="hljs-comment">// index: 当前项的索引</span><br>                       <br></code></pre></td></tr></table></figure></li><li><p>v-if 中 index 和 key</p><ol><li><p>index&#x3D;”<code>$&#123;index&#125;-$&#123;item.meta.id&#125;</code>“</p><ol><li>这是 Element Plus 菜单组件特有的属性</li><li>用于标识每个菜单项的唯一路径</li><li>帮助菜单组件追踪当前选中的菜单项</li><li>通常用于控制菜单的激活状态</li></ol></li><li><p><code>key</code> 属性:</p></li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">:key=&quot;`$&#123;index&#125;-$&#123;item.meta.id&#125;`&quot;<br></code></pre></td></tr></table></figure><ul><li>这是 Vue 框架要求的特殊属性</li><li>用于给 v-for 循环中的每个元素一个唯一标识</li><li>帮助 Vue 在虚拟 DOM 更新时准确识别节点</li><li>提高渲染性能和准确性</li></ul><p>  它们的主要区别：</p><ul><li><code>index</code> 是功能性的唯一标识，用于菜单组件的功能实现</li><li><code>key</code> 是结构性的唯一标识，用于 Vue 框架的 DOM 更新优化</li></ul></li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 项目中的菜单组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in props.menuData&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 无子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.children || item.children.length == 0&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:indx</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 结合路由信息以及动态元素实现图标渲染 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 菜单标题 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 有子菜单：分两个部分：标题+递归调用子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-sub-menu</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-else</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 标题区域的内容： #title是 Element Plus 的 el-sub-menu 组件预定义的插槽名称 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 递归调用此组件实现子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- index：1  1-2  1-3 实现每个菜单项的唯一标识 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">SubMenu</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:menuData</span>=<span class="hljs-string">&quot;item.children&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-sub-menu</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="hljs-string">``</span><span class="hljs-string">`                   </span><br><span class="hljs-string"></span><br><span class="hljs-string"> `</span><span class="hljs-string">``</span>js<br>&lt;template&gt;<br>   &lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>显示内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>其他内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   &lt;!-- 列表渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="language-xml">         &#123;&#123; item.name &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目1&#x27;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目2&#x27;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   ])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>v-if和v-show的区别</p><ul><li><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue.js 中用于条件渲染的指令，但它们有不同的作用和使用场景。</p></li><li><p>总结：</p><ul><li>使用 <code>v-if</code> 时，元素在条件为假时不会存在于 DOM 中。</li><li>使用 <code>v-show</code> 时，元素始终存在于 DOM 中，只是通过 CSS 控制显示或隐藏。</li></ul></li><li><p><code>v-if</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来有条件地渲染元素。</li><li><strong>特点</strong>：元素及其绑定的事件和子组件在条件为假时不会被渲染或销毁。</li><li><strong>性能</strong>：初始渲染时有更高的开销，因为需要添加或删除 DOM 元素。</li></ul></li><li><p><code>v-show</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来切换元素的显示状态。</li><li><strong>特点</strong>：元素始终会被渲染并保留在 DOM 中，只是通过 CSS 的 <code>display</code> 属性来控制显示或隐藏。</li><li><strong>性能</strong>：初始渲染开销较小，但频繁切换显示状态时性能更好。</li></ul></li><li><p>使用场景</p><ul><li><strong><code>v-if</code></strong>：适用于在运行时条件很少改变的场景，因为它会在条件变化时进行 DOM 的添加和删除。</li><li><strong><code>v-show</code></strong>：适用于需要频繁切换显示状态的场景，因为它只会切换 <code>display</code> 属性。</li></ul></li><li><p>示例</p></li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;!-- v-<span class="hljs-keyword">if</span> 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>  &lt;!-- v-show 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isShow</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isVisible</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>事件处理与双向绑定</p><ol><li><code>v-model</code> 的用途:获取表单中的输入数据赋值给变量；<code>v-model</code> 是 Vue.js 中用于创建<strong>双向数据绑定</strong>的指令，主要用于表单输入元素与应用状态之间的同步。主要功能如下<ol><li><p><strong>双向绑定</strong>：</p><ul><li>自动将用户输入的值同步到组件的状态（如 <code>data</code> 或 <code>ref</code>）。</li><li>同时，当状态发生变化时，更新输入元素的显示值。</li></ul></li><li><p><strong>简化代码</strong>：</p><ul><li>替代手动编写 <code>:value</code> 和 <code>@input</code> 事件处理器，实现更简洁的双向绑定。</li></ul></li></ol></li><li>常见用法</li></ol><ul><li><strong>文本输入</strong>：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>复选框</strong>：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input type=&quot;checkbox&quot; v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>选择框</strong>：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">      &lt;select v-model=&quot;变量名&quot;&gt;<br>         &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt;<br>         &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt;<br>      &lt;/select&gt;<br><br> ```js<br>&lt;template&gt;<br>      &lt;input v-model=&quot;username&quot; /&gt;<br>   &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const username = ref(&#x27;&#x27;)<br>const handleClick = () =&gt; &#123;<br>console.log(username.value)<br>&#125;<br>&lt;/script&gt;<br>/*<br>   - **`v-model=&quot;username&quot;`**：<br>   - 将输入框的值与 `username` 变量绑定。<br>   - 用户在输入框中输入内容时，`username` 会自动更新。<br>   - 如果在代码中修改 `username` 的值，输入框的显示内容也会相应更新。<br><br>*/<br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>对比一下选项式API：在 Vue 2 和 Vue 3 的选项式 API 中的<code>&lt;script&gt;</code>中需要 return 和 export 的原因：(这些在组合式API中都不用考虑)</p><ol><li>export default 的目的：<ol><li>将组件配置对象导出，使其可以被其他组件引入使用</li><li>这是 ES6 模块系统的要求</li><li>Vue 通过这个导出的对象来创建组件实例</li></ol></li><li>return 的目的：<ol><li>在 data() 函数中返回数据对象，使其成为响应式数据</li><li>每个组件实例都需要独立的数据副本，避免数据共享</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-comment">// 选项式 API</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyComponent&#x27;</span>,<br><br><span class="hljs-comment">// data 必须是函数并返回对象，确保每个组件实例有独立的数据副本</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">methods</span>: &#123;<br>   <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">computed</span>: &#123;<br>   <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>   &#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br><span class="hljs-comment">// ❌ 错误示例</span><br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//组合式API中：组合式API基础语法</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 方式1：使用 ref() 定义基础类型</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><br><span class="hljs-comment">// 方式2：使用 reactive() 定义对象类型</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 使用时：(在template之外)</span><br><span class="hljs-comment">// ref 需要 .value </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>)<br><br><span class="hljs-comment">// reactive 直接使用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">message</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在模板中使用 ref 不需要 .value --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- reactive 对象的使用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li><li><p>选项式与组合式API的区别（除了上述之外）： </p><ol><li>选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子等等。</li><li>组合式 API：需要手动导入所需的响应式函数和生命周期钩子等等，从而提供更灵活和模块化的代码结构。（除了编译器宏比如defineProps，编译器宏：由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 ‘vue’ 中导入。自动可用：在<code>&lt;script setup&gt;</code>块内，defineProps 会被自动识别并处理。）</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//拿子传父举例</span><br><span class="hljs-comment">// 选项式 API</span><br>&lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);<span class="hljs-comment">//自动处理this.$emit</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// 组合式 API</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>选项式 API 和 组合式 API 的主要区别补充：</p><ol><li><p><strong>组织代码的方式</strong></p><ul><li><strong>选项式 API</strong>：通过选项（如 <code>data</code>、<code>methods</code>、<code>computed</code> 等）组织代码，适合简单组件。</li><li><strong>组合式 API</strong>：通过组合函数（如 <code>setup</code>）组织代码，更适合复杂逻辑和代码复用。</li></ul></li><li><p><strong>逻辑复用</strong></p><ul><li><strong>选项式 API</strong>：依赖混入（mixins）和高阶组件（HOCs），可能导致命名冲突和难以追踪。</li><li><strong>组合式 API</strong>：使用组合函数（composables）实现逻辑复用，结构更清晰，避免命名冲突。</li></ul></li><li><p><strong>类型推导和 TypeScript 支持</strong></p><ul><li><strong>选项式 API</strong>：TypeScript 支持有限，类型推导较复杂。</li><li><strong>组合式 API</strong>：与 TypeScript 集成更好，提供更精准的类型推导。</li></ul></li><li><p><strong>代码组织与可维护性</strong></p><ul><li><strong>选项式 API</strong>：按选项分割，功能分散，难以管理大型组件。</li><li><strong>组合式 API</strong>：按功能分割，相关逻辑集中，提升可维护性。</li></ul></li><li><p><strong>生命周期钩子</strong></p><ul><li><strong>选项式 API</strong>：通过选项直接定义生命周期钩子（如 <code>mounted</code>、<code>created</code>）。</li><li><strong>组合式 API</strong>：在 <code>setup</code> 内使用函数（如 <code>onMounted</code>、<code>onCreated</code>）定义生命周期钩子。</li></ul></li><li><p><strong>响应式系统</strong></p><ul><li><strong>选项式 API</strong>：使用 <code>data</code> 对象进行响应式管理，自动处理响应式属性。</li><li><strong>组合式 API</strong>：使用 <code>ref</code>、<code>reactive</code> 等函数显式创建响应式数据，更灵活。</li></ul></li><li><p><strong>学习曲线</strong></p></li></ol><ul><li><strong>选项式 API</strong>：更直观，适合 Vue 新手。</li><li><strong>组合式 API</strong>：需要理解响应式原理和组合函数，学习曲线稍陡。</li></ul><ol start="8"><li><strong>调试和测试</strong></li></ol><ul><li><strong>选项式 API</strong>：由于逻辑分散，单独测试某一功能较困难。</li><li><strong>组合式 API</strong>：逻辑集中，单元测试和调试更容易。</li></ul></li><li><p>最后总结一下两者的异同：</p><ol><li>同：无论是选项式还是组合式API，都得遵循js的规范，比如任何变量使用前必须申明，否则会报错；调用其他组件时都需要导入相应文件；</li><li>异：<ol><li>选项式需要export default导出组件对象，并在其中使用components申明导入的组件、data（）函数return 返回数据变量&#x2F;对象（定义申明）以实现相应，而组合式直接ref&#x2F;reactive即可；</li><li>组合式中需要导入响应式函数和生命周期钩子等等，而选项式不需要；（除了编译器宏比如defineProps之外）</li></ol></li><li>在这个项目中我主要使用组合式，往后就不管选项式了</li></ol></li></ol></li><li><p><code>&lt;style scoped&gt;&lt;/style&gt;</code>：用于定义组件的样式。开发者可以使用CSS或预处理器（如Sass、Less、Tailwind CSS，问perplexity）编写样式：</p><ol><li><code>&lt;style&gt;</code> 标签内编写的 CSS 样式默认是全局作用域，会影响到其他路由页面。要使样式仅作用于当前组件，需要在 <code>&lt;style&gt;</code> 标签上添加 scoped 属性：</li></ol>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style lang=<span class="hljs-string">&quot;less&quot;</span> scoped&gt;<br> <span class="hljs-comment">/* 在这里添加样式 */</span><br> .<span class="hljs-property">logo</span>-lg &#123;<br> font-<span class="hljs-attr">size</span>: 20px;<br> text-<span class="hljs-attr">align</span>: center;<br> <span class="hljs-attr">height</span>: 50px;<br> line-<span class="hljs-attr">height</span>: 50px;<br> <span class="hljs-attr">color</span>: style<br> &#125;<br> &lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li></ol></li><li>根组件App.vue:包含了整个应用程序的布局结构<ol><li>页面渲染的入口点。所有其他组件都会嵌套在App.vue中</li><li>通常会与Vue Router的组件<code>&lt;RouterView /&gt;</code>结合使用，处理页面之间的导航和路由，实现不同页面的切换和展示；如果使用了路由，但是App.vue中没有<code>&lt;RouterView /&gt;</code>，则路由无法正常工作;经典内容如下：</li></ol>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><br>&lt;template&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li><li>Vue应用的入口文件main.js：初始化Vue实例并将其挂载到DOM中，导出了整个应用程序所需的全局状态和方法。一般来说，在这里初始化一些全局变量或函数，以便于后续操作，其基础操作如下：<ol><li>导入router实例<code>import router from &#39;./router&#39;</code>；(访问router&#x2F;index.js文件)</li><li>创建app实例<code>const app = createApp(App)</code>，这里的App是根组件App.vue;</li><li>挂载router实例<code>app.use(router)</code></li><li>挂载app实例到指定ID的div元素上：<code>app.mount(&#39;#app&#39;)</code><ol><li>这里的#app是index.html中的一个div元素的id，Vue会将app实例挂载到这个元素上，从而渲染整个应用</li><li>你也可以将app实例挂载到其他元素上,但要在index.html中添加相应的元素以及id属性</li><li>默认使用#app的原因<ol><li>约定俗成：使用id&#x3D;”app”是Vue文档和许多示例中的常见做法，主要是为了简化学习和开发过程。开发者可以快速识别出这是Vue应用的挂载点。</li><li>避免冲突：在大型应用中，使用特定的id可以帮助避免与其他JavaScript库或框架的冲突，确保Vue应用的DOM元素明确且独特。</li></ol></li></ol></li></ol></li><li>router文件夹：<ol><li>功能：路由管理<ol><li>导入组件，定义路由规则,控制页面间的跳转逻辑</li><li>定义 URL 路径与组件的对应关系</li><li>管理路由参数传递</li><li>router&#x2F;index.js负责初始化和配置Vue应用; 主要功能如下<ol><li>定义路由routes</li><li>创造并导出router实例</li></ol></li><li>注意：不能重复导入同一个组件，否则会导致组件重复注册，从而引发错误</li></ol></li><li>典型结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router/index.js</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span><br><span class="hljs-keyword">const</span> routes = [<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Home.vue&#x27;</span>)<br>&#125;,<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/About.vue&#x27;</span>)<br>&#125;<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>routes<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br><br></code></pre></td></tr></table></figure></li><li>View文件夹：<ol><li>视图功能:负责页面渲染<ol><li>存放页面级别的组件</li><li>对应具体的路由页面</li><li>组合和管理其他小组件</li></ol></li><li>与components的区别<ol><li>views：负责页面级别的组件，对应具体路由逻辑的页面（也就是说路由怎么设置的，view下就要有相应的页面组件），组合和管理其他小组件（可嵌入components中或者view中子组件）</li><li>components：负责通用的小组件，可以在多个页面中复用，不涉及具体的路由逻辑</li></ol></li><li>举例 Main.vue<ol><li>作用：主要负责页面的整体布局和结构，包含了整个页面的主要内容</li><li>典型结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- views/<span class="hljs-title class_">Main</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Aside</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><pre><code class="hljs"> 1.  services ：存放业务逻辑层面的代码，包括多个组件共用的服务端接口调用函数等 2.  utils：存放通用工具函数，不同的地方不重复书写相同的代码片段</code></pre><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ul><li>当启动应用程序时，Vite 会按照如下顺序加载和处理这些文件：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">读取 package<span class="hljs-selector-class">.json</span>：获取项目依赖项和脚本信息。<br>解析 vue<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>：配置Vite的行为，包括环境变量管理、插件注册等。<br>载入 <span class="hljs-attribute">src</span>/App<span class="hljs-selector-class">.vue</span>：作为应用程序的根组件，负责渲染页面结构。<br>执行 <span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>：初始化应用程序，全局状态和方法的创建。<br>递归查找并加载各个组件：从根组件开始，逐级向下寻找并注入子组件，形成完整的DOM树结构。<br>优化与缓存处理：利用Vite提供的内置优化机制，对JS/CSS进行压缩混淆，以及对第三方库进行tree-shaking以减少无效代码。<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vueWatch</title>
    <link href="/2024/10/15/SE/vueWatch&amp;deep/"/>
    <url>/2024/10/15/SE/vueWatch&amp;deep/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简单讲讲vue3的watch函数和:deep伪类选择器</p></blockquote><span id="more"></span><h2 id="watch-函数说明"><a href="#watch-函数说明" class="headerlink" title="watch 函数说明"></a>watch 函数说明</h2><ol><li><code>watch</code> 是 Vue 3 的组合式 API 之一，用于监听响应式数据的变化</li><li>它接收两个主要参数：<ul><li>第一个参数：要监听的数据源（这里是一个返回 <code>route.params.id</code> 的箭头函数）</li><li>第二个参数：当数据变化时触发的回调函数</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>,  <span class="hljs-comment">// 监听路由参数中的id变化</span><br>  <span class="hljs-function">(<span class="hljs-params">newId</span>) =&gt;</span> &#123;           <span class="hljs-comment">// newId 是变化后的新值</span><br>    <span class="hljs-keyword">if</span> (newId) &#123;<br>      <span class="hljs-title function_">fetchData</span>()        <span class="hljs-comment">// 当id变化时重新获取数据</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;重新获取推荐视频&quot;</span>)<br>    &#125;<br>  &#125;<br>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/videoDetail&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> &#125;<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;<br>    videoInfo.<span class="hljs-property">value</span> = data.<span class="hljs-property">result</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;视频详情数据&#x27;</span>, data.<span class="hljs-property">result</span>)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个典型的用例，常用于需要根据路由参数重新获取数据的场景。</p><ul><li><code>newId</code> 在这里指的是路由参数中的 <code>id</code> 的新值</li><li>这段代码的作用是监听视频的 ID 变化（通常在 URL 中），当用户切换到不同的视频时：<ol><li>路由参数 <code>id</code> 发生变化</li><li>watch 检测到变化，触发回调函数</li><li>执行 <code>fetchData()</code> 获取新视频的推荐内容</li></ol></li></ul><h3 id="key动态监测变化，自动重新渲染组件"><a href="#key动态监测变化，自动重新渲染组件" class="headerlink" title="key动态监测变化，自动重新渲染组件"></a>key动态监测变化，自动重新渲染组件</h3><ul><li>接着上面的例子，当检测到路由id变化后通过fetchData重新获数据后，还需要通过组件标签中的key属性实现组件自动重新渲染；如下例子所示，路由变化后嵌入的视频会自动更新；</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-play&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span></span><br><span class="hljs-tag">     <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;videoInfo.videoSrc&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;videoInfo.videoSrc&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="deep-选择器"><a href="#deep-选择器" class="headerlink" title=":deep() 选择器"></a>:deep() 选择器</h2><p><code>:deep()</code> 是 Vue 3 中的深度选择器，用于穿透 scoped CSS 的作用域限制。</p><ol><li>当使用 <code>&lt;style scoped&gt;</code> 时，Vue 会为组件的元素添加一个唯一的属性（如 data-v-hash）</li><li>样式会被编译为带有这个属性选择器的形式，从而将样式限制在当前组件内</li><li>但有时我们需要修改子组件或第三方组件的内部元素样式，这时就需要 <code>:deep()</code></li></ol><ul><li>另外值得注意的事，:deep属性最好选择class，不要选择组件名</li><li>使用示例</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 不使用 :deep 时（只能影响当前组件的元素）</span><br><span class="hljs-selector-class">.tabs</span> <span class="hljs-selector-class">.van-tab</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-comment">// 使用 :deep 后（可以影响子组件内部元素）</span><br><span class="hljs-selector-class">.tabs</span> :<span class="hljs-selector-tag">deep</span>(.van-tab) &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如说在vue项目中修改组件中引入的vant组件：<code>:deep(.van-tab--active)</code> 就是为了修改 Vant 组件库中 Tab 组件的激活状态样式。</p>]]></content>
    
    
    <categories>
      
      <category>SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建过程</title>
    <link href="/2024/10/02/SE/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/10/02/SE/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>博客搭建全过程和方案展示</p></blockquote><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><ul><li>使用hexo搭建博客；具体参考<ul><li><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></li><li><a href="https://blog.csdn.net/cat_bayi/article/details/128725230">https://blog.csdn.net/cat_bayi/article/details/128725230</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide">https://fluid-dev.github.io/hexo-fluid-docs/guide</a></li></ul></li></ul><ol><li><p>关联github page的仓存到本地</p></li><li><p>安装hexo</p></li><li><p>配置主题</p><ol><li>选择的是这个：<a href="https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file">https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file</a></li></ol></li><li><p>安装hexo-deployer-git插件实现自动远程部署：npm install hexo-deployer-git –save</p></li><li><p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p><pre><code class="hljs">  deploy:     type: git     repository: git@github.com:用户名/用户名.github.io.git     branch: main</code></pre></li><li><p>关联域名： <a href="https://github.com/wcool1/wcool1.github.io/settings/pages">打开github上博客仓库的设置</a>: 重新设置Custom domain:[<a href="http://www.tolsz];并开启https;(github给的权益)">www.tolsz];并开启https;(github给的权益)</a></p><ul><li>为什么github pages部署hexo之后每次hexo g -d后关联的域名都会失效,每次都要在github上手动设置吗;<ul><li><a href="https://whybee.blog.csdn.net/article/details/140328361?spm=1001.2014.3001.5502">参考链接</a>：</li></ul><ol><li>不需要，只需要在github的该仓库中创建一个CNAME文件并将域名写入即可；等个1min就好了；但这样再下一次推送后CNAME文件又会失踪；原因如下</li><li>偶然中发现，刚开始还未部署hexo时本地仓库整个文件夹都和远程git仓库是关联同步的，包括CNAME和README.md都是同步的；但是部署hexo之后，远程仓库中只含有博客项目下的.deploy_git下的文件夹；每次更新使用hexo g 会根据本地内容（source中的文件）生成相应页面到pulic中， 然后hexo d进行部署时，会将public中的文件同步deploy_git下同时推送到远程的github仓库；即source下所有的文件内容对应public;比如source&#x2F;A hexo -g之后就会在public&#x2F;A 生成相应内容；</li><li>这也是为什么1中操作下CNAME文件会消失，因为public下没有CNAME文件，所以推送到远端时，自然也没有；解决办法就是在source文件夹下创建CNAME文件添加不含http前缀的域名，然后hexo g -d即可；</li><li>由于dns缓存的原因，每次更新并部署后需要过一会（20s-60s）才能看到新的内容，样式与本地的markdown看到的几乎一样；</li></ol></li></ul></li><li><p>常用命令：</p><pre><code class="hljs">  hexo new &quot;name&quot;       # 新建文章  hexo new page &quot;name&quot;  # 新建页面  hexo g                # 生成页面  hexo d                # 部署  hexo g -d             # 生成页面并部署  hexo s                # 本地预览  hexo clean            # 每次更新前使用：清除缓存文件: 删除 public 文件夹、db.json 文件以及 _config.yml 中配置的 public_dir 目录下的所有文件。确保生成干净的网站文件: 清除缓存后，下次运行 hexo generate 命令时，会重新生成所有网站文件，避免旧文件的影响。这样会导致你直接在Public下对文件做的修改比如更换Img、html等等都会被撤销；因此，强调修改任何东西都是在source、配置文件下才是正确稳妥的；  hexo help             # 帮助</code></pre></li><li><p>基本操作</p><ol><li><p>删除&#x2F;删除页面：直接在本地source &#x2F; _post 文件夹中删除&#x2F;修改相应文件然后hexo clean; hexo g -d即可</p></li><li><p>图片操作：</p><ol><li>插入图片时需要考虑其大小以及排版在此博客系统上的效果，一般使用html标签调整，设置width&#x2F;height为百分比；eg:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://alexcld.com/images/pengyuyan.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;25%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;25%&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>实际上，hexo渲染一篇post的工作流程是：</p><pre><code class="hljs">  拿到一个markdown文件，  根据这个文件的layout类型，  进行样式排版，生成html文件，  最终展示到网页端。</code></pre></li><li><p>发布一篇博客的操作流程</p><ol><li>进入本地git所在根目录</li><li>hexo new ‘title’</li><li>在生成的title文件夹下放入所需要的静态资源，比如tolsz\source_posts\周末北京武汉往返随机放入所有的图片&#x2F;pdf，然后就在这个文件夹下创建一个md文档，进行博客的创建（相当于草稿），图片等静态资源的导入方式举例如下，这样你在编辑草稿的时候就能实时看到了，最后再编辑好之后，将内容复制到文件夹外一级的同名md文件中，删除此草稿md文档。（如果你在发布后还想修改，那就同理再创建一个草稿md文件，实时预览静态资源，编辑后再删除）</li></ol><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">图片：![图片 text]<span class="hljs-comment">(图片.jpg)</span><br>pdf: &#123;<span class="hljs-meta">%</span> pdf 名称.pdf <span class="hljs-meta">%</span>&#125;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>hexo clean</li><li>hexo g -d<ol><li>或者先hexo g在本地生成</li><li>hexo s本地预览 <a href="http://localhost:4000,而且是热加载，可以一边改一边预览">http://localhost:4000,而且是热加载，可以一边改一边预览</a></li><li>最后发布hexo d</li></ol></li></ol></li></ol></li></ol><h2 id="hexo使用技巧"><a href="#hexo使用技巧" class="headerlink" title="hexo使用技巧"></a>hexo使用技巧</h2><ol><li>设置文章摘要和标签操作举例如下：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">hello</span> <span class="hljs-string">hexo</span> <span class="hljs-string">markdown</span><br><span class="hljs-attr">date:</span> <br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hello</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">我是短小精悍的文章摘要(๑•̀ㅂ•́)</span> <span class="hljs-string">✧</span><br><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><br><span class="hljs-string">紧接着文章摘要的正文内容</span><br><br><br></code></pre></td></tr></table></figure><ol start="2"><li>很多用法比如如何布局多张照片，代码折叠、标签样式、mermaid渲染等等见<a href="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6">https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6</a></li><li>资源引用：除了url的绝对引用外，相对引用可以使用 Hexo 提供的资源文件夹功能:使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。Hexo 将会在我们每一次通过 hexo new title 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章中所引用的相关资源比如截图放到这个同名文件夹下，然后通过相对路径引用；不针对封面等与文章内容无关的资源；<ol><li>强调一下hexo g时，只会将source目录下的img文件夹、_posts下的new出来的md文件以及资源引用开启后下的同名文件夹下的资源文件复制到public下，其他的文件不会复制到public下；因此直接复制图片粘贴到md中的资源图片，vscode会默认在当前目录下创建一个img&#x2F;{title}文件夹用以存放截图，但是此文件夹不会被hexo g复制到public下，因此需要手动将其复制粘贴一份到资源引用功能开启后的同名（title）文件夹下，然后hexo g -d即可；</li></ol></li><li>分类与标签：<ol><li>二者区别：分类具有顺序性和层次性而标签没有顺序和层次；可忽略不计</li><li>在scaffolds&#x2F;post.md设置默认的文章模板如下，生成之后再加入分类&#x2F;标签即可，分类比较好用：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">标签</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">类别</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li><li>自定制、美化博客<ol><li>参考：<ol><li><a href="https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/">https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/</a></li><li><a href="https://blog.csdn.net/weixin_51545953/article/details/128499341">https://blog.csdn.net/weixin_51545953/article/details/128499341</a></li></ol></li><li>配置：包括所有图片、导航栏的title、标题等等都在_conflg.主题.yml中设置,其优先级最高,然后考虑_config.yml;</li><li>修改banner图：<ol><li>在网上查找免费开源的风景图片并下载下来（避免版权纠纷）推荐几个免费开源的图片网站<ol><li><a href="https://pixabay.com/">https://pixabay.com/</a></li><li><a href="https://unsplash.com/">https://unsplash.com/</a></li><li><a href="https://www.pexels.com/">https://www.pexels.com/</a></li></ol></li><li>不知为何在配置中修改默认banner_img的属性不生效，但是可以分步设置各个分页的banner图，<a href="https://s81679.github.io/2020/02/25/hexo-theme-fluid/#%E4%B8%BB%E9%A0%81-Banner-%E5%A4%A7%E5%9C%96">参考</a></li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 首页</span><br><span class="hljs-symbol">index:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>banner.jpg  <span class="hljs-meta"># 首页 Banner 头图，以下相同</span><br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">100</span>  <span class="hljs-meta"># 头图高度，屏幕百分比，available: 0 - 100</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-meta"># 文章頁</span><br><span class="hljs-meta"># Archive Page</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-symbol">archive:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>articles.jpg<br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-meta"># available: 0 - 100</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-meta"># 分類頁</span><br><span class="hljs-meta"># Categories Page</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-symbol">category:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>categories.jpg<br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-meta"># available: 0 - 100</span><br></code></pre></td></tr></table></figure></li><li>设置文章在首页中的封面图：<ol><li>设置模版scaffolds&#x2F;post中添加index_img: &#x2F;img&#x2F;cover&#x2F;<code>&#123;&#123; title &#125;&#125;</code>.png；</li><li>在source&#x2F;img下创建cover文件夹,将new的文章的封面移动到其中，并改为{title}.png</li><li>hexo clean ;hexo g -d</li></ol></li><li>同理，banner_img: &#x2F;img&#x2F;cover&#x2F;<code>&#123;&#123; title &#125;&#125; </code>.png设置文章的banner图</li></ol></li></ol><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li><p>图片无法加载</p><ul><li>参考   <ul><li><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></li></ul></li><li>解决办法：<ul><li><p>md文件中的图片路径只能是文件名，并将相应的图片放到其同名文件夹下，也就是说要想在云端能看到图片，那么在本地就看不到；</p></li><li><p>谷歌也没有发现更好的办法，也许这就是hexo的bug；</p></li><li><p>2025.11，AI发展太快太好用了，在windsurf问了下gemini就立刻解决了（之前谷歌很久都找不到答案）；</p><ul><li>npm install hexo-renderer-marked@latest –save</li><li>_config.yml中写入<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">marked:</span><br>   <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>文章图片的导入方式使用相对路径<code> &lt;img src=&quot;./周末北京武汉往返随机/IMG_20251122_080702.jpg&quot; /&gt;</code>这样本地和网页上都能看到了</p></li></ul></li></ul></li><li><p>如何设置图片的大小</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">- 等比例缩放<br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;./12.jpg&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;zoom:15%&quot;</span> /&gt;<br>- 直接设置宽高<br>&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;./12.jpg&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;width:300px;height:300px&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><ul><li>也许在本地看起来不是居中的，但是博客主题会使得发布后网站显示的图片都是居中的。</li></ul><h2 id="分享方式"><a href="#分享方式" class="headerlink" title="分享方式"></a>分享方式</h2><ul><li>直接分享博客地址似乎不太好，那你可以截博客文章长图发到qq空间&#x2F;朋友圈然后附上博客地址，举例如下：<br><img src="/images/README/image-2.png" alt="alt text"></li><li>如何在本地进行分类管理<ul><li>直接在tolsz\source_posts下创建类型文件夹，其他同上:<ul><li>hexo new ‘tltle’然后将文章和同名文件夹手动移到类型文件夹即可</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>SE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>testOCR</title>
    <link href="/2025/01/02/testOCR/"/>
    <url>/2025/01/02/testOCR/</url>
    
    <content type="html"><![CDATA[<blockquote><p>摘要<br>测试两款开源OCR工具以及百度飞桨在线产品PP-OCRv4的识别效果</p></blockquote><span id="more"></span><ul><li><p>先说结论：百度的飞桨在线产品<a href="https://aistudio.baidu.com/community/app/91660/webUI">PP-OCRv4</a> 对文字、数字、排版的识别都很不错；开源paddleOCR和Umi-OCR对文字、数字的识别效果都还可以，但是对排版的识别效果都不太好，二者差不多，相同与不同如下；</p></li><li><p>相同点：</p><ul><li>都可批量OCR</li><li>对文本、数字等等效果比较好，但对布局格式识别、输出顺序不太行。</li><li>对图片、pdf等文件都可以识别</li></ul></li><li><p>不同之处</p><ul><li>Umi-OCR通过应用程序鼠标点击进行操作</li><li>PaddleOCR通过命令行&#x2F;python进行操作,输出结果中含有置信度</li><li>Umi-OCR可识别二维码</li></ul></li><li><p>如下是测试过程：</p></li></ul><h3 id="Umi-OCR"><a href="#Umi-OCR" class="headerlink" title="Umi-OCR"></a><a href="https://github.com/hiroi-sora/Umi-OCR">Umi-OCR</a></h3><ul><li>设置规则<ul><li>多栏：自动识别多栏布局输出</li><li>单栏：不识别布局，从上往下按照一行行的顺序识别和输出</li></ul></li></ul><p><img src="/images/image-15.png" alt="alt text"></p><h4 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h4><ul><li>效果很好，连格式几乎都一样，除了有些缩进和换行被忽略了；<br><img src="/images/image-7.png" alt="alt text"></li></ul><h4 id="发票1"><a href="#发票1" class="headerlink" title="发票1"></a>发票1</h4><p><img src="/images/image-13.png" alt="alt text"></p><ul><li>多栏-按自然段换行：最上面盖章处，识别有少许偏差，上面中间部分一行行识别和输出效果还可以，下面列与列之间间隙较大，就变成了一列列识别和输出，键与值之间错位，不方便对应；最右下角可能是光线不好，没识别出来；</li></ul><p><img src="/images/image-14.png" alt="alt text"></p><ul><li>多栏，总是换行：识别效果和顺序和上方差不多，但每识别一段就换行；</li></ul><p><img src="/images/image-16.png" alt="alt text"></p><ul><li>单栏：自然换行：从上往下按照一行行的顺序识别和输出，但是遇到一些格式不一样的一起识别就会出现顺序问题</li></ul><p><img src="/images/image-17.png" alt="alt text"></p><h4 id="发票2"><a href="#发票2" class="headerlink" title="发票2"></a>发票2</h4><p><img src="/images/image-10.png" alt="alt text"></p><ul><li>多栏-按自然段换行：尽管除了少数和印章重叠的字识别有误之外（蓝色圈出），文字和数字都识别出来了，但是识别和输出格式和输出顺序很糟糕，整体上也是从左向右一列列识别和输出，但他并不是以每列相同的宽度去读取的，像圈1和圈4所在列就比较规则，所以它也能准确读出来，但有些列的宽度并不能包含相应格式的数据保证他们的连贯性；（如图中圈3）</li></ul><p><img src="/images/image-12.png" alt="alt text"></p><ul><li>单栏：自然换行 ：从上往下按照一行行的顺序识别和输出，语意不连贯，键值不对应，盖章文字未识别出；</li></ul><p><img src="/images/image-18.png" alt="alt text"></p><ul><li>总结：对纯文本效果比较好，但对布局格式识别不太行；</li></ul><h3 id="开源PaddleOCR"><a href="#开源PaddleOCR" class="headerlink" title="开源PaddleOCR"></a><a href="https://paddlepaddle.github.io/PaddleOCR/latest/ppocr/quick_start.html#3">开源PaddleOCR</a></h3><h4 id="纯文本-1"><a href="#纯文本-1" class="headerlink" title="纯文本"></a>纯文本</h4><p><img src="/images/image-27.png" alt="alt text"><br><img src="/images/image-29.png" alt="alt text"></p><h4 id="发票1-1"><a href="#发票1-1" class="headerlink" title="发票1"></a>发票1</h4><p><img src="/images/image-21.png" alt="alt text"></p><h4 id="发票2-1"><a href="#发票2-1" class="headerlink" title="发票2"></a>发票2</h4><p><img src="/images/image-28.png" alt="alt text"></p><ul><li>总结：和前者效果差不多：对纯文本效果比较好，但对布局格式识别不太行；</li></ul><h3 id="PP-OCRv4-在线"><a href="#PP-OCRv4-在线" class="headerlink" title="PP-OCRv4 在线"></a><a href="https://aistudio.baidu.com/community/app/91660/webUI">PP-OCRv4 在线</a></h3><ul><li>对文本、数字、布局、排版格式等等识别的都很好；唯一缺点就是印章重叠处的文字识别不太精准；</li></ul><h4 id="纯文本-2"><a href="#纯文本-2" class="headerlink" title="纯文本"></a>纯文本</h4><p><img src="/images/image-23.png" alt="alt text"></p><h4 id="发票"><a href="#发票" class="headerlink" title="发票"></a>发票</h4><p><img src="/images/image-22.png" alt="alt text"><br><img src="/images/image-24.png" alt="alt text"><br><img src="/images/image-30.png" alt="alt text"></p>]]></content>
    
    
    
    <tags>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署项目</title>
    <link href="/2024/11/15/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/11/15/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述如何使用Vercel部署前端项目</p></blockquote><span id="more"></span><h2 id="上线前端静态项目"><a href="#上线前端静态项目" class="headerlink" title="上线前端静态项目"></a>上线前端静态项目</h2><h4 id="vercel"><a href="#vercel" class="headerlink" title="vercel"></a>vercel</h4><ol><li>登录<a href="https://vercel.com/new">https://vercel.com/new</a> 注册账号（需要绑定手机号输入验证码）并绑定github</li><li>将项目上传到github上，不要上传依赖node_modules，在 Vercel 部署项目时会自动安装项目依赖、执行构建命令，并将构建结果上传到其服务器。</li><li>在vercel中new project，导入相应的仓库，然后vercel会自动识别框架，你只需要点击下一步和deploy即可部署成功</li><li>部署成功后可在vercel中看到项目的域名，状态等信息<ol><li>默认域名格式：项目名-github账号名-projects.vercel.app</li></ol></li><li>在 Vercel 的控制面板中，可以管理项目，包括查看日志、配置环境变量、设置 HTTPS 等，还可以将自定义域名绑定到 Vercel 项目。</li><li>如果想修改项目，直接本地修改代码然后上传到github即可</li><li>最大的问题就是域名vercel.app在国内背墙了，无法访问，解决办法有如下两种<ol><li>换一个国内可以访问的域名然后通过进行cloudflare解析。<ul><li>如果是使用国内的域名需要Cloudflare解析海外的服务器，因为国内的阿里云腾讯云免费DNS不支持直接解析海外服务器,步骤如下：<ol><li>注册 Cloudfare</li><li>把自己购买的域名添加到cloudfare，然后选择免费计划。</li><li>点进该域名的配置面板，增加 DNS 配置。（76.223.126.88 是 vercel 贴心为墙内用户准备的 IP。添加@记录后，保存后显示的是你的域名.）</li><li>把cloudflare名称服务器下的两行代码，直接复制粘贴到你所购买域名平台相应的DNS管理中修改，将域名的DNS解析服务转移到Cloudflare;需要稍等一会（记住DNS的相关操作是具有迟缓性的，也许半个小时甚至更久才能起作用，不要心急）</li><li>转移需要一些时间，等邮箱通知激活成功；</li></ol></li></ul></li><li>github学生包还有很多权益，其中就包括很多免费的域名，全球可访；</li></ol></li></ol><h4 id="利用github学生包免费获得https-get-tech-的-tech域名"><a href="#利用github学生包免费获得https-get-tech-的-tech域名" class="headerlink" title="利用github学生包免费获得https://get.tech 的.tech域名"></a>利用github学生包免费获得<a href="https://get.tech/">https://get.tech</a> 的.tech域名</h4><ol><li>进入官网，选择一个域名mylsz.tech，然后绑定github,价格会变成0元，购买；时效1年</li><li>购买前需要注册账号<ol><li>谷歌账号、</li><li>范式：tech</li></ol></li><li>namecheap可以直接在其中进行域名解析绑定服务器，此网站也可以，不过它是通过邮箱的方式告诉你地址（刚开始我还纳闷为什么一个卖域名的网站居然没有解析服务）<ol><li>.tech是在全球可访问的，无需使用cloudflare，直接通过<a href="https://controlpanel.tech/servlet/ViewDomainServlet?orderid=116516920&referrerkey=MmNvTVlSTzYvWEZMUzRLRTJLdHdJczM3cTVtc3NyT1lnWWpiaEhsWW9nbzRvQXE5L1gxTllYR0QxRk1rVHJsV3V1VjdiOUZ2Wk5nPQ==#domorder">此链接</a> 管理DNS解析域名：76.223.126.88  是 vercel 贴心为墙内用户准备的 IP（不要用vercel控制台提供的76.76.21.21，这个国内访问不了）。添加A记录后，DNS缓存需要稍等一会</li></ol></li></ol><ul><li>参考<ul><li><a href="https://www.nbmao.com/archives/6702">https://www.nbmao.com/archives/6702</a></li><li><a href="https://blog.csdn.net/ll_renlong/article/details/141395626">https://blog.csdn.net/ll_renlong/article/details/141395626</a></li><li><a href="https://juejin.cn/post/7383894687302434825#heading-5">https://juejin.cn/post/7383894687302434825#heading-5</a></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>router</title>
    <link href="/2024/10/20/router/"/>
    <url>/2024/10/20/router/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Vue3 Router</p></blockquote><span id="more"></span><h3 id="Router路由管理"><a href="#Router路由管理" class="headerlink" title="Router路由管理"></a>Router路由管理</h3><p>在 Vue 3 中，<code>useRoute</code> 和 <code>useRouter</code> 都是 Vue Router 提供的组合式 API，用于在组合式函数中访问路由。</p><p><strong>区别：</strong></p><ul><li><code>useRoute</code> 用于访问当前路由的状态，是只读的。</li><li><code>useRouter</code> 用于执行路由操作，如导航、切换、添加路由等。</li></ul><hr><ul><li><p><strong><code>useRoute</code></strong></p><ul><li><p>返回当前激活的路由信息，是一个只读的响应式对象。</p></li><li><p>可以获取路由的‘meta’、 <code>path</code>、<code>params</code>、<code>query</code>、<code>name</code> 等属性。</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">path</span>) <span class="hljs-comment">// 输出当前路径</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>) <span class="hljs-comment">// 获取路由参数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>useRouter</code></strong></p><ul><li><p>返回当前组件的路由实例对象，可以使用它进行添加路由、导航等操作。</p></li><li><p>提供了‘addRoute’、 <code>push</code>、<code>replace</code> 等方法</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">goHome</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span> &#125;) <span class="hljs-comment">// 导航到名为 &#x27;Home&#x27; 的路由</span><br>  <span class="hljs-comment">//遍历数据中的路由信息添加到main路由下</span><br>  <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>,item)<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transData</title>
    <link href="/2024/10/19/transData/"/>
    <url>/2024/10/19/transData/</url>
    
    <content type="html"><![CDATA[<blockquote><p>讲述Vue3中数据传输的方法以及异步操作</p></blockquote><span id="more"></span><h2 id="Vue3中的数据传递"><a href="#Vue3中的数据传递" class="headerlink" title="Vue3中的数据传递"></a>Vue3中的数据传递</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ol><li>是组件间传递数据的主流方式，尤其是在父子组件关系明确且数据流向单一的情况下。这种方式简单且直观，适合大多数场景。</li><li>子组件使用 props 属性接收父组件传递的数据；</li><li>语法：<code>&lt;子组件 :属性名=&quot;父组件数据&quot;  :属性名=&quot;父组件数据&quot;/&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">   &lt;!-- 父组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;parentMessage&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>   &lt;!-- 选项式 --&gt;<br>&lt;script&gt;<br>   import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>   export default &#123;<br>   data() &#123;<br>      return &#123;<br>         parentMessage: &#x27;Hello from parent&#x27;<br>      &#125;;<br>   &#125;,<br>   components: &#123; ChildComponent &#125;<br>       /* 这行代码是关于组件注册的,必要的，但是如果使用&lt;script setup&gt;则可以省略<br>      组件注册目的：<br><br>      告诉 Vue 这个父组件要使用 ChildComponent 子组件<br>      建立组件间的关联关系<br>      为什么必要：<br><br>      Vue 规定必须先注册组件才能在模板中使用<br>      如果不注册就直接在模板中使用 &lt;ChildComponent&gt;，Vue 会报错<br><br>      */<br>   <br>   &#125;;<br>&lt;/script&gt;<br>&lt;!-- 组合式API --&gt;<br><br>&lt;script setup&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>const parentMessage = &#x27;Hello, Child!&#x27;;<br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 选项式<span class="hljs-variable constant_">API</span><br>   &lt;script &gt;<br>   <br>   <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>      <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;message&#x27;</span>]<br>   &#125;;<br>   &lt;/script&gt; --&gt;<br><br>   &lt;!-- 组合式<span class="hljs-variable constant_">API</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   //编译器宏：defineProps 是由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 &#x27;vue&#x27; 中导入。自动可用：在 <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"> 块内，defineProps 会被自动识别并处理。</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-comment">// 使用 defineProps 声明 props</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-attr">message</span>: &#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;);</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   </span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">   </span><br></code></pre></td></tr></table></figure></li></ol><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><ol><li><p>在子组件中触发事件</p></li><li><p>在父组件中监听事件</p></li><li><p>原理</p><ol><li>事件触发<ol><li>子组件通过 $emit() 触发自定义事件</li><li>可传递数据作为第二个参数</li></ol></li><li>事件监听<ol><li>父组件使用 @事件名 语法监听</li><li>通过回调函数接收数据</li></ol></li><li>数据流向:子组件 -&gt; 触发事件 -&gt; 父组件接收 -&gt; 更新数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>发送消息到父组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br> <br>  &lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  选项式</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">     &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br><br>  &lt;!-- 组合式 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;message-event&#x27;</span>]);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ParentComponent</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>&lt;!-- 选项式 --&gt;<br>&lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title class_">ChildComponent</span><span class="hljs-comment">//注册组件</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">messageFromChild</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">handleMessageEvent</span>(<span class="hljs-params">message</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageFromChild</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br>&lt;!-- 组合式 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li><a href="#%E9%80%9A%E8%BF%87useroot%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">直接通过useRoot获取全局数据，想要谁就直接通过options属性获取</a></li><li>全局状态管理：使用 Vuex 或者 Pinia 来管理全局状态，适用于复杂的应用场景。如下介绍vuex</li><li>Provide&#x2F;Inject API：适用于跨级组件间传递数据。</li><li>事件总线：使用事件总线（Event Bus）来传递数据，但这种方式在 Vue 3 中不推荐使用。</li><li>Context API：在组合式 API 中，可以通过 context 来传递数据。</li></ol></li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><ul><li><p>安装：npm install vuex@next –save</p></li><li><p>核心概念</p><ol><li><p>创建和定义 store</p><ol><li>state: 存储状态信息<ol><li>store&#x2F;下定义状态信息</li><li>在组件中通过有三种方式获取state<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1内置函数computed (推荐)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 优点:</span><br><span class="hljs-comment"> 响应式: 状态变化时会自动更新视图</span><br><span class="hljs-comment"> 缓存: 计算结果会被缓存,只有依赖变化时才重新计算</span><br><span class="hljs-comment">*/</span><br><span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br><br><span class="hljs-comment">//2直接访问 (不推荐)</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  缺点:</span><br><span class="hljs-comment"> 非响应式: 状态变化时不会自动更新视图</span><br><span class="hljs-comment"> 需要手动触发更新</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-attr">count</span>: store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span><br><br><span class="hljs-comment">//3使用 ref + watch (特殊场景)</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 使用场景:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> 需要对状态变化做额外处理</span><br><span class="hljs-comment"> 需要本地维护状态副本</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br> count.<span class="hljs-property">value</span> = newVal<br> &#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>mutations: 同步修改状态<ol><li>store&#x2F;下定义修改状态的方法</li><li>当需要修改状态时，在组件中通过commit相应的mutation和参数(见store&#x2F;下定义修改状态的方法)触发重新处理&amp;赋值给state中的变量来实现状态更新</li></ol></li><li>actions: <a id="异步请求">异步操作</a><ol><li>异步请求是指发出请求后，不会立即得到结果，而是在未来某个时间点才会收到响应的操作。</li><li>为什么需要 Actions<ol><li>Mutations 必须是同步的</li><li>Actions 可以包含异步操作</li><li>Actions 可以组合多个 mutations</li></ol></li><li>使用场景          <ul><li>API 请求等延时操作</li><li>复杂的状态修改流程</li><li>需要组合多个 mutation</li><li>涉及异步操作的业务逻辑：比如定时器、延时操作、文件上传&#x2F;下载等</li></ul></li><li>特点:<ol><li>async 定义异步异步函数</li><li>通过 context 对象访问 store 实例的方法和属性</li><li>可以触发其他 actions (dispatch)</li><li>最终通过 commit 提交 mutation 修改状态</li></ol></li><li>在组件中通过dispatch提交action <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br><span class="hljs-attr">state</span>: &#123;<br>   <span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span>,<br>   <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span><br>&#125;,<br><span class="hljs-attr">mutations</span>: &#123;<br>   <span class="hljs-title function_">setUserInfo</span>(<span class="hljs-params">state, info</span>) &#123;<br>      state.<span class="hljs-property">userInfo</span> = info<br>   &#125;,<br>   <span class="hljs-title function_">setLoading</span>(<span class="hljs-params">state, status</span>) &#123;<br>      state.<span class="hljs-property">loading</span> = status<br>   &#125;<br>&#125;,<br><span class="hljs-attr">actions</span>: &#123;<br>   <span class="hljs-comment">// 1. 处理异步操作</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, credentials</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">login</span>(credentials)<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUserInfo&#x27;</span>, response.<span class="hljs-property">data</span>)<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">false</span>)<br>      &#125;<br>   &#125;,<br><br>   <span class="hljs-comment">// 2. 复杂业务逻辑</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">checkout</span>(<span class="hljs-params">&#123; commit, state, dispatch &#125;</span>) &#123;<br>      <span class="hljs-comment">// 检查库存</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;checkStock&#x27;</span>)<br>      <span class="hljs-comment">// 创建订单</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;createOrder&#x27;</span>)<br>      <span class="hljs-comment">// 清空购物车</span><br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;clearCart&#x27;</span>)<br>   &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>getters: 计算属性<ol><li>store&#x2F;下定义计算相关的方法</li><li>组件中通过store.getters调用相应的方法</li></ol></li><li>modules: 模块化管理状态<ol><li>针对不同联动事件之间有不同的关联状态和操作，因此划分成多个模块，每个模块管理相关的一部分的共享状态会更方便操作；<ol><li>比如Aside和headerNav之间的通信（联动）都是关于菜单的，于是将所有的菜单相关的状态（信息、操作等等）放在一个模块sotore&#x2F;menu.js中</li><li>需要在&#x2F;store&#x2F;index.js中导入所需模块，将创建的store导出；供main.js挂载和其他组件使用；同时模块中只需要定义被其他组件需要的state、mutations、actions、getters并导出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/sotre/index.js </span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br> <span class="hljs-keyword">import</span> menu <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./menu&quot;</span>;<br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>       menu<br>    &#125;<br> &#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//menu.js</span><br><br><span class="hljs-keyword">const</span> state=&#123;<br>   <span class="hljs-attr">isCollapse</span>:<span class="hljs-literal">false</span>,<span class="hljs-comment">//是否折叠</span><br>   <span class="hljs-attr">selectMenu</span>:[]<span class="hljs-comment">//选中的菜单</span><br>&#125;<br><br><span class="hljs-keyword">const</span> mutations=&#123;<br>   <span class="hljs-title function_">collapseMenu</span>(<span class="hljs-params">state</span>)&#123;<br>      state.<span class="hljs-property">isCollapse</span>=!state.<span class="hljs-property">isCollapse</span><span class="hljs-comment">//取反</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">//从此模块中导出此需要的数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>      state,<br>      mutations<br>&#125;<br><br><br>           <br></code></pre></td></tr></table></figure></li></ol></li><li>在vuex中如果有模块的话，组件在调用 state 时需要加上模块名，而调用 mutations、actions、getters 时则不需要加模块名。（在vue3_study_basic中亲测）   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span><br>    <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span><br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-comment">// 读取状态</span><br>       <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">count</span>),<br>       <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br>       <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">username</span>),<br>       newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span><br><br>       <span class="hljs-comment">// 状态修改：mutations</span><br>       <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br>       <span class="hljs-comment">// 重置用户名</span><br>       <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>       store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span><br>       newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span><br>       &#125;,<br>       <span class="hljs-comment">//action：异步操作</span><br>       <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span><br>    <br>    &#125;<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>在入口文件main.js中使用:</p><ol><li>创建 store 实例并挂载</li></ol></li><li><p>组件中通过 useStore() 访问和使用 </p><ol><li>如下是一个基础案例额</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br> <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>       <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br> &#125;,<br> <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">// 修改状态的方法</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>       state.<span class="hljs-property">count</span>++<br>    &#125;,<br>    <span class="hljs-title function_">setUsername</span>(<span class="hljs-params">state, username</span>) &#123;<br>       state.<span class="hljs-property">username</span> = username<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>       <span class="hljs-comment">// 模拟API调用</span><br>       <span class="hljs-comment">//使用 new Promise 和 setTimeout 模拟了一个耗时1秒的API调用</span><br>       <span class="hljs-comment">//await 会暂停执行，直到Promise完成</span><br>       <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br>       <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-comment">// 计算属性</span><br>    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params">state</span>) &#123;<br>       <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>    &#125;<br> &#125;<br> &#125;)<br><br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- main.<span class="hljs-property">js</span> --&gt;<br> <span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br> <span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br> <span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br> <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br> app.<span class="hljs-title function_">use</span>(store)<br> app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 组件.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Double Count: &#123;&#123; doubleCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Username: &#123;&#123; username || &#x27;未登录&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   </span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 点击按钮触发login方法,传入参数admin到login action --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login(&#x27;admin&#x27;)&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 添加重置按钮 --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;newUsername&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入新用户名&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">   &gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;resetUsername&quot;</span>&gt;</span>Reset User<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 读取状态</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">username</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 状态修改：mutations</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 重置用户名</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//action：异步操作</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="vuex持久化"><a href="#vuex持久化" class="headerlink" title="vuex持久化"></a><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%B7%BB%E5%8A%A0+vuex%E6%8C%81%E4%B9%85%E5%8C%96">vuex持久化</a></h4><ul><li><p>vuex-persistedstate 将 store 存储到浏览器的时机如下：这种机制确保了在页面刷新或重新打开后能够恢复之前的状态。</p></li><li><p>主要存储时机</p></li></ul><ol><li><p><strong>Store 发生变化时</strong></p><ul><li>当通过 mutation 修改 state 时</li><li>在每次 state 更新后自动触发</li></ul></li><li><p><strong>具体触发点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听 store 的变化</span><br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 将数据持久化到 localStorage</span><br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;vuex&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><ul><li>存储行为特点</li></ul><ol><li><p><strong>实时性</strong></p><ul><li>同步执行，立即存储</li><li>不需要手动触发</li></ul></li><li><p><strong>选择性存储</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> createPersistedState <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex-persistedstate&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">createPersistedState</span>(&#123;<br>      <span class="hljs-attr">paths</span>: [<span class="hljs-string">&#x27;需要持久化的state路径&#x27;</span>]  <span class="hljs-comment">// 可以选择性存储</span><br>    &#125;)<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>存储位置</strong></p><ul><li>默认使用 localStorage</li><li>可配置使用 sessionStorage 或其他存储方式</li></ul></li></ol><p><code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器。相反，它会从浏览器的存储（如<br>localStorage或 <code>sessionStorage</code>）中读取之前保存的状态，并将其恢复到 Vuex store 中。</p><ul><li>工作流程：</li></ul><ol><li><p><strong>页面加载时</strong>：</p><ul><li><code>vuex-persistedstate</code> 插件会从浏览器存储中读取之前保存的 Vuex 状态。</li><li>将读取到的状态合并到当前的 Vuex store 中。</li></ul></li><li><p><strong>状态变化时</strong>：</p><ul><li>当 Vuex store 中的状态发生变化时（通过 mutation），<code>vuex-persistedstate</code> 会将新的状态存储到浏览器中。</li></ul></li></ol><ul><li><p>总结：</p></li><li><p><strong>页面加载时</strong>：<code>vuex-persistedstate</code> 从浏览器存储中恢复状态到 Vuex store。</p></li><li><p><strong>状态变化时</strong>：<code>vuex-persistedstate</code> 将新的状态存储到浏览器中。</p></li></ul><p>因此，<code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器，而是从浏览器中读取之前保存的状态并恢复。</p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><ul><li><p>什么是<a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82">异步请求</a>？</p></li><li><p>Promise 是处理异步操作的一种方式，它代表一个异步操作的最终完成(或失败)及其结果值。</p><ul><li><p>基本用法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 基础语法</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">if</span> (成功) &#123;<br>    <span class="hljs-title function_">resolve</span>(结果)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(错误)<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 2. 使用Promise</span><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理成功</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理失败</span><br>  &#125;)<br></code></pre></td></tr></table></figure></li><li><p>实际示例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 封装API请求</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(response.<span class="hljs-property">data</span>))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">reject</span>(error))<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 2. 使用async/await简化</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserData</span>(userId)<br>    <span class="hljs-keyword">return</span> data<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取用户数据失败:&#x27;</span>, error)<br>  &#125;<br>&#125;<br><span class="hljs-comment">//3. 延时</span><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>   <span class="hljs-comment">//延时1秒</span><br><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br><span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<span class="hljs-comment">//最终通过 commit 提交 mutation 修改状态</span><br> &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>凡是内部调用多个函数且要讲究执行顺序的的函数要用异步async申明；异步操作内部要使用await调用已存在的方法，外部也要用async申明参数，每一环都是如此；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//group/index.vue的提交弹窗逻辑</span><br><span class="hljs-keyword">const</span> localData=<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;pz_v3pz&#x27;</span>)<br><span class="hljs-keyword">import</span> &#123; computed, toRaw &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> routerList=<span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>store.<span class="hljs-property">state</span>.<span class="hljs-property">menu</span>.<span class="hljs-property">routerList</span>)<br><span class="hljs-comment">//内有异步操作</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">confirm</span>=<span class="hljs-keyword">async</span> (<span class="hljs-params">formEl</span>)=&gt;&#123;<br>  <span class="hljs-keyword">if</span> (!formEl) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">//内有异步操作</span><br>  <span class="hljs-keyword">await</span> formEl.<span class="hljs-title function_">validate</span>( <span class="hljs-title function_">async</span>(valid,fields)=&gt;&#123;<br>    <span class="hljs-keyword">if</span> (valid) &#123;<br>      <span class="hljs-comment">//根据APi文档可知，其中一个参数为permissions：string,故要将选中的权限字符串化</span><br>      <span class="hljs-keyword">const</span> permissions = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(treeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">getCheckedKeys</span>())<br>      <span class="hljs-comment">// console.log(permissions)</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1. 先执行 userSetMenu请求重新设置菜单数据</span><br><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">userSetMenu</span>(&#123;<br>          <span class="hljs-attr">name</span>: form.<span class="hljs-property">name</span>,<br>          permissions,<span class="hljs-comment">//参数名与变量名同名时，可以简写：一个即可，不需要：</span><br><br>          <span class="hljs-attr">id</span>: form.<span class="hljs-property">id</span><br>        &#125;)<br>        <br>        <span class="hljs-comment">// 2. 更新列表数据</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">getListData</span>()<br>        <br>        <span class="hljs-comment">// 3. 关闭弹窗</span><br>        <span class="hljs-title function_">beforeClose</span>()<br>        <br>        <span class="hljs-comment">// 4. 再执行 menuPermissions</span><br>        <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">menuPermissions</span>()<br>        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;dynamicMenu&#x27;</span>, data.<span class="hljs-property">data</span>)<br>        <br>        <span class="hljs-comment">// 5. 添加路由</span><br>        <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>, item)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;操作失败:&#x27;</span>, error)<br>      &#125;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error submit!&#x27;</span>,fields)<br>    &#125;<br>  &#125;)<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEO</title>
    <link href="/2024/10/18/SEO/"/>
    <url>/2024/10/18/SEO/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Talk about SEO </p></blockquote><span id="more"></span><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><ul><li><p>对 SEO 的理解<br>  - <code>SEO</code> :“<a href="https://zhida.zhihu.com/search?content_id=247338801&content_type=Article&match_order=1&q=%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96&zhida_source=entity">搜索引擎优化</a>”（<code>Search Engine Optimization</code>）。</p><p>  - 旨在提高网站在<a href="https://zhida.zhihu.com/search?content_id=247338801&content_type=Article&match_order=1&q=%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%9C%E9%A1%B5%E9%9D%A2&zhida_source=entity">搜索引擎结果页面</a>（<code>SERP</code>）中可见性和排名的技术和策略。</p><p>  - 主要目标是增加有机（非付费）流量，也就是通过自然搜索结果吸引访问者，而不是通过付费广告获取流量。</p></li><li><p>如何做好SEO</p><ul><li>技术方面<ul><li>html中<ul><li>设置目标客群最常搜寻的关键字，推荐承载3-5个关键词</li><li>使用包含关键字的具有吸引力的标题、并在内容中自然地融入关键字；</li><li>写好description尽可能完整精确地地描述网站的内容；</li></ul></li><li>多使用html语义化标签布局页面比如Nav,h5、Aside、footer等等 建立清晰的网站架构，方便搜寻引擎爬虫抓取</li><li>结构化资料： 帮助搜寻引擎更好地理解网站内容</li><li>提高用户的体验感<ul><li>优化网站的速度、性能</li></ul></li><li>获得其他网站的连结，提升网站权威性</li></ul></li></ul></li><li><p>其余方面</p><ul><li>把网站内容丰富起来，控制好内容质量（比如stackflow），网站内容越丰富、质量越高，用户在上面停留的时间越长，搜索引擎就会将其放在越前面；其实谷歌搜索引擎影响结果占比权重最高的就是用户在搜索对应关键词时停留在页面上的时间，所有很多哪怕是在谷歌工作过的大牛，他们都明白谷歌的搜索引擎是没有漏洞可以钻的，最好的方式就是提高网站的内容质量和丰富性，让用户在你的网站停留的时间越长，你的网站在搜索结果中的排名就越高；<ul><li>网站内容质量高，也会被其他的网站大量引入链接、提高曝光率吸引流量</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>FontEnd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueKey</title>
    <link href="/2024/10/17/VueKey/"/>
    <url>/2024/10/17/VueKey/</url>
    
    <content type="html"><![CDATA[<blockquote><p>vue3核心语法</p></blockquote><span id="more"></span><h3 id="vue3核心语法"><a href="#vue3核心语法" class="headerlink" title="vue3核心语法"></a>vue3核心语法</h3><ul><li>hook<ul><li><p>简单来讲就是自定义的包&#x2F;库（python等各种语言中都有）；是Vue 3中的重要特性，通过组合式API实现了对状态和副作用的管理，使得逻辑复用变得更加简单和高效。与传统的mixins相比，Hooks提供了更好的灵活性和可维护性，是现代Vue开发中不可或缺的一部分。主要用于封装可重用的逻辑和管理组件的状态、生命周期以及副作用。允许开发者以函数的形式组织和复用代码，从而提高代码的可维护性和可读性。</p></li><li><p>Vue Hook的作用</p><ul><li><p><strong>状态逻辑复用</strong>：Vue Hook允许在多个组件之间共享状态逻辑，避免重复代码。例如，可以创建一个自定义Hook来处理表单输入状态，然后在多个表单组件中使用。</p></li><li><p><strong>生命周期管理</strong>：Hooks提供了一系列生命周期钩子函数，如<code>onMounted</code>、<code>onUpdated</code>、<code>onUnmounted</code>等，帮助开发者在组件不同阶段执行特定操作。例如，可以在组件挂载后发起数据请求，或在组件卸载前清理定时器。</p></li><li><p><strong>简化代码结构</strong>：通过将逻辑封装到Hooks中，可以使组件代码更简洁，逻辑更集中，便于理解和维护。这种方式比传统的mixins更清晰，因为Hooks是以函数形式存在，避免了命名冲突和逻辑散落的问题。</p></li><li><p><strong>响应式数据处理</strong>：使用Hooks时，可以利用Vue 3中的响应式API（如<code>ref</code>、<code>reactive</code>、<code>computed</code>）来创建响应式数据，使得状态管理更加直观和高效。</p></li></ul></li><li><p>自定义Hooks：是开发者根据需要创建的函数，通常以<code>use</code>开头，例如<code>useFetchData</code>。这些函数可以调用其他Hooks，并返回响应式数据或方法，以供组件使用。自定义Hooks的基本规范包括：</p><ul><li><p>函数名以<code>use</code>开头。</p></li><li><p>在组件的<code>setup</code>函数中调用自定义Hook。</p></li><li><p>返回响应式变量或方法，以便在组件中解构使用。</p><p>例如，一个简单的自定义Hook可以用于处理本地存储：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) &#123;<br>   <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(initialValue);<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)) &#123;<br>      data.<span class="hljs-property">value</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key));<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(initialValue));<br>   &#125;<br><br>   <span class="hljs-title function_">watch</span>(data, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newValue));<br>   &#125;);<br><br>   <span class="hljs-keyword">return</span> &#123; data &#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   1. **数据持久化存储**:</span><br><span class="hljs-comment">   if (localStorage.getItem(key)) &#123;</span><br><span class="hljs-comment">      data.value = JSON.parse(localStorage.getItem(key));</span><br><span class="hljs-comment">   &#125; else &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(initialValue));</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   - 当首次使用时，如果 localStorage 中不存在数据，则存入初始值</span><br><span class="hljs-comment">   - 如果已存在数据，则读取已保存的数据</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   2. **响应式数据管理**:</span><br><span class="hljs-comment">   const data = ref(initialValue);</span><br><span class="hljs-comment">   - 使用 ref创建响应式数据，可以在组件中实时反映数据变化</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   3. **自动同步到 localStorage**:</span><br><span class="hljs-comment">   watch(data, (newValue) =&gt; &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(newValue));</span><br><span class="hljs-comment">   &#125;);</span><br><span class="hljs-comment">   - 通过 watch监听数据变化</span><br><span class="hljs-comment">   - 当数据发生变化时，自动更新到 localStorage 中</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   使用示例(在src/view/try.vue中):</span><br><span class="hljs-comment">   const &#123; data &#125; = useLocalStorage(&#x27;myData&#x27;, &#123; name: &#x27;default&#x27; &#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   这样就创建了一个在组件和 localStorage 之间自动同步的响应式数据。</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><p>在组件中使用时，可以这样引入并使用这个Hook：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> useLocalStorage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useLocalStorage&#x27;</span>;<br><br><span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">&#x27;myData&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;default&#x27;</span> &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>&lt;RouterView /&gt; </code><a id="RouterView"></a><ul><li><p><code>&lt;RouterView /&gt;</code> 是 Vue Router 的核心组件之一，它的主要作用是作为路由匹配到的组件的渲染出口。是实现前端路由的关键组件，它让我们能够根据 URL 的变化动态渲染不同的组件内容。</p></li><li><p>主要作用</p><ol><li><p><strong>组件渲染容器</strong></p><ul><li>它会根据当前的路由路径（URL）</li><li>自动渲染与该路径匹配的组件</li><li>相当于一个动态组件的占位符</li></ul></li><li><p><strong>动态更新</strong></p><ul><li>当路由发生变化时<code>&lt;RouterView /&gt;</code> 会自动更新渲染的内容,无需手动干预</li></ul></li></ol></li><li><p>使用场景:内容需要根据路由变化而变化</p><ul><li>看他的上一级路由的组件的相应变化位置就是它的出口；<ul><li>比如项目中整个&#x2F;下的第一级路由的出口就在src\App.vue（在&#x2F;xx下随着路由整个页面都变化）</li><li>菜单嵌套路由的出口在src\view\Main.vue（Layout组件）中的el-main中；在&#x2F;path&#x2F;xx下切换路由只相应修改页面布局中的el-main中的内容</li></ul></li></ul><ol><li><p><strong>布局组件中</strong></p><ul><li>作为内容区域的容器</li><li>常见于后台管理系统的布局中</li></ul></li><li><p><strong>嵌套路由</strong></p><ul><li>当需要实现多层级路由时,父路由组件相应位置放置 <code>&lt;RouterView /&gt;</code>，子路由的组件会在这里渲染</li></ul></li><li><p><strong>路由过渡动画</strong></p><ul><li>可以配合 <code>&lt;transition&gt;</code> 使用</li><li>为路由切换添加动画效果</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;transition name=<span class="hljs-string">&quot;fade&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li>在 Vue 2、3 中，<code>@</code> 是 <code>v-on</code> 指令的简写，用于监听 DOM 事件并执行相应的 JavaScript 代码。在 Vue 3 中，使用 <code>:</code> 符号来表示属性绑定是一个重要的语法特性。这种写法源于 Vue 的响应式特性，允许开发者将组件的属性（props）与数据模型进行绑定，从而实现动态更新。<ul><li><p>注意绑定的值必须满足如下规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//可行的情况</span><br> 变量：:value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//message必须是被定义过的变量</span><br> 表达式：:value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//count必须是被定义过的变量</span><br> 字符串字面量：:value=<span class="hljs-string">&quot;&#x27;hello&#x27;&quot;</span>（三个引号）<br> 对象：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span><br> 数组：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span><br> 布尔值：:disabled=<span class="hljs-string">&quot;false&quot;</span><br> <span class="hljs-comment">//不可行</span><br> :value=<span class="hljs-string">&#x27;hello&#x27;</span><br> :value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//但是message没有被定义</span><br> :value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//但是count没有被定义</span><br> <span class="hljs-comment">//举例说明:当我插入ep input组件时</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  :prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;显示不了，因为v-bing绑定了<span class="hljs-title class_">Search</span>但它没有被定义<br> <span class="hljs-comment">//其实我想要的search就是一个常量字符串，正确写法如下：去掉:或者使用三引号表示字符串常量</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;验证码&quot;</span>  <span class="hljs-attr">:prefix-icon</span>=<span class="hljs-string">&quot;&#x27;Search&#x27;&quot;</span> &gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure></li><li><p>属性绑定语法</p><ul><li><p>基本用法</p><ul><li><strong>属性绑定</strong>：使用 <code>:</code> 符号（相当于 <code>v-bind</code> 的简写）来将数据绑定到组件的属性上。例如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">:some-prop</span>=<span class="hljs-string">&quot;dataValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>   <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;width:&#x27;230px&#x27;&#125;&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>some-prop</code> 是子组件的一个 prop，而 <code>dataValue</code> 是父组件中的一个数据属性。</p><ul><li><p>动态绑定</p></li><li><p><strong>动态属性</strong>：可以使用表达式动态计算属性值。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;inputValue&quot;</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;isDisabled&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这里，<code>value</code> 和 <code>disabled</code> 属性会根据 <code>inputValue</code> 和 <code>isDisabled</code> 的值动态更新。</p><ul><li><p>使用对象语法</p></li><li><p><strong>对象语法</strong>：可以将多个属性一起绑定到组件上。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; propA: valueA, propB: valueB &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用这种方式，可以在一个对象中传递多个属性。</p></li></ul></li><li><p>事件处理语法</p><p>  <strong><strong>基本用法</strong></strong></p><ul><li><p><strong>监听事件</strong>：使用 <code>v-on</code> 指令（简写为 <code>@</code>）来监听事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 上述代码中的 <code>handleClick</code> 是一个在组件中定义的方法，当按钮被点击时，该方法将被调用。</p></li><li><p><strong>内联事件处理器</strong>：可以直接在模板中编写 JavaScript 代码，例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;alert(&#x27;Button clicked!&#x27;)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 在这个例子中，点击按钮会弹出一个警告框。</p></li></ul><p>  <strong><strong>事件参数</strong></strong></p><ul><li><p><strong>访问原生事件</strong>：在事件处理方法中，可以访问原生 DOM 事件对象。该对象会自动作为参数传递给方法。例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br><span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 输出触发事件的元素</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>**使用 <code>$event</code>**：在内联处理器中，可以通过特殊变量 <code>$event</code> 来访问原生事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick($event)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>  <strong><strong>修饰符</strong></strong></p><p>  Vue 提供了一些修饰符来控制事件的行为，例如：</p><ul><li><p>**<code>.stop</code>**：阻止事件冒泡。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>.prevent</code>**：阻止默认行为。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;submitForm&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>.self</code>**：仅当事件目标是元素本身时才触发处理器。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>Click me only if clicked on this div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>自定义事件</p></li></ul><p>  Vue 的组件之间可以通过自定义事件进行通信。子组件可以使用 <code>$emit</code> 方法向父组件发送事件。例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;custom-event&#x27;</span>, payload);<br></code></pre></td></tr></table></figure><p>  父组件则可以通过 <code>@custom-event</code> 来监听这个自定义事件：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">custom-event</span>=<span class="hljs-string">&quot;parentMethod&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>变量： Vue3 中变量的使用场景</p><ol><li>使用 <code>&#123;&#123; &#125;&#125;</code> 插值语法</li></ol><ul><li>在模板中显示变量值 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 显示数据 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count + 1 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; isActive ? &#x27;激活&#x27; : &#x27;未激活&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>使用单引号 <code>&#39;&#39;</code></li></ol><ul><li>字符串字面量</li><li>静态值</li><li>变量作各种参数，比如store.commit&#x2F;dispatch等等 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>使用 <code>:</code> 或 <code>v-bind</code></li></ol><ul><li>动态绑定属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 动态绑定 --&gt;<br>&lt;div :class=&quot;&#123;&#x27;click-enabled&#x27;: !flag&#125;&quot;&gt;//代表flag为false时，class为click-enabled，否则没有class<br>&lt;img :src=&quot;imgUrl&quot;&gt;<br>&lt;el-button :type=&quot;buttonType&quot;&gt;<br>&lt;div :style=&quot;&#123; width: width + &#x27;px&#x27; &#125;&quot;&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>使用 <code>@</code> 或 <code>v-on</code></li></ol><ul><li>事件绑定 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 事件绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;handleInput&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>使用 <code>v-model</code></li></ol><ul><li>双向数据绑定 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 双向绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li>使用 <code>v-if/v-show</code></li></ol><ul><li><p>条件渲染</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>总结：</p><ul><li><code>&#123;&#123; &#125;&#125;</code>: 显示变量值</li><li><code>&#39;&#39;</code>: 静态值</li><li><code>:</code>: 动态属性绑定</li><li><code>@</code>: 事件绑定</li><li><code>v-model</code>: 双向绑定</li><li><code>v-if/v-show</code>: 条件渲染</li></ul></li></ul></li></ul></li></ul><h4 id="nextTick-object-assign"><a href="#nextTick-object-assign" class="headerlink" title="nextTick&amp;object.assign "></a><a id="nextTick&object.assign">nextTick&amp;object.assign </a></h4><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><code>nextTick</code></h4><p><code>nextTick</code> 是 <strong>Vue.js</strong> 提供的一个方法，用于在下一次 DOM 更新循环结束之后执行延迟回调。在修改数据后立即使用 <code>nextTick</code>，可以在回调中获取更新后的 DOM。</p><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    count.<span class="hljs-property">value</span>++;<br>    <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 在这里可以访问更新后的 DOM</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM 已更新&#x27;</span>);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123; count, increment &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>当你在修改响应式数据后，需要在 DOM 更新完成后执行某些操作时，使用 <code>nextTick</code>。</li><li>常见场景包括获取更新后的 DOM 元素的尺寸或状态。</li></ul><hr><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h4><p><code>Object.assign</code> 是 <strong>JavaScript</strong> 中的一个静态方法，用于将一个或多个源对象的可枚举属性复制到目标对象中。返回目标对象。也称为合并对象。</p><p><strong>语法：</strong></p><ol><li>如果target存在source中的属性就会被重写赋值，如果不存在就会创造这个属性然后赋值过去；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, ...sources);<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：目标对象。</li><li><code>sources</code>：源对象。</li></ul><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//或者&#123;a:1&#125;,输出结果一样</span><br><span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source1, source2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target); <span class="hljs-comment">// 输出：&#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p><code>Object.assign</code> 常用于对象的合并或浅拷贝。</p></li><li><p>如果目标对象与源对象有相同的属性，后面的属性会覆盖前面的属性。</p></li><li><p>参考</p><ul><li><a href="https://www.bilibili.com/video/BV1nV411Q7RX/?vd_source=a02025349c3063d9c9143f9bd7489fdf">【2024最新版】3小时学会Vue3，小白零基础视频教程，web前端快速入门实战课程_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1oj411D7jk/?vd_source=a02025349c3063d9c9143f9bd7489fdf">30分钟学会Vue之核心语法 趁着暑假掌握一门技能 大学生前端实习毕业设计必备技能_哔哩哔哩_bilibili</a></li><li><a href="https://juejin.cn/post/7225267685763907621#heading-1">十分钟，带你了解 Vue3 的新写法最近因为项目需要，不得不学习一下 Vue3。于是花了 4 个小时，把 Vue3 过了 - 掘金</a></li><li><a href="https://juejin.cn/post/7122760155707473956?searchId=20241108152858B987C89A8A08662B99ED">超极速的Vue3上手指北笔者之前是Vue2+React开发者，因项目需要直接上手Vue3，所以快速学习一下，中间会对比一 - 掘金</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vueVite</title>
    <link href="/2024/10/16/vueVite/"/>
    <url>/2024/10/16/vueVite/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述使用Vite搭建Vue3项目的结构及其作用</p></blockquote><span id="more"></span><h2 id="项目结构及其作用"><a href="#项目结构及其作用" class="headerlink" title="项目结构及其作用"></a>项目结构及其作用</h2><ol><li>根目录：<ol><li>package.json：这个文件包含了项目的依赖项、脚本等信息，是整个项目的元数据。</li><li>vue.config.js：这是用于配置 Vite 的主要文件。在这里，你可以定义环境变量、设置插件、调整打包选项等。这是一个非常重要的配置文件，它会影响到你的开发体验和生产部署过程</li></ol></li><li>public：包含了一些静态资源，比如图标、favicon.ico、robots.txt 等。这些文件会被直接复制到构建目录中，不会经过 Vite 的处理。<ol><li>在组件中导入public中的静态资源时不需要完整的路径，直接&#x2F;文件名即可比如<code>import qrImg from &#39;/qr.png&#39;</code>;导入public中的二维码图片</li></ol></li><li>src 文件夹：在 Vite 中最核心的一个文件夹，因为它存放着所有的源代码： index.htm-main.js-index.js、App.vue-其他view、components组件-静态资源（图片、cdn等等）<ol><li>assets 文件夹：用来存储静态资源，如图片、样式表等，这些资源通常不会经常变化，可以直接复制到服务器上</li><li>components 文件夹：存放的是你写好的复用组件，每个子文件夹代表一类相关的组件，比如说有一个 base 或者 app 组件，然后再根据具体功能划分出不同的模块（例如：button、table 等）。在vue项目中可以将其中的文件称为vue文件：封装和组织组件的模板、逻辑和样式，使得组件的开发和管理更加高效和模块化（往往在components下创造组件，在view下的vue文件中引用组件），提高了代码的可维护性和复用性：其基础结构如下：<ol><li><p><code>&lt;template&gt;&lt;/template&gt;</code>:内含html代码，用于组成页面结构</p><ol><li>浏览器中不会存在<code>&lt;template&gt;</code>标签的原因是，Vue会在编译过程中将<code>&lt;template&gt;</code>中的内容转换为JavaScript渲染函数。在这个过程中，Vue会解析<code>&lt;template&gt;</code>的内容并生成虚拟DOM，而这个虚拟DOM最终会被渲染到实际的DOM中。</li><li>编译过程：<ol><li>解析模板：Vue使用vue-template-compiler库将<code>&lt;template&gt;</code>块中的HTML字符串解析为抽象语法树（AST），这表示了模板的结构。</li><li>生成渲染函数：AST会被转换为JavaScript代码，这些代码负责创建虚拟DOM节点。每当组件需要渲染时，Vue会调用这些渲染函数，而不是直接使用<code>&lt;template&gt;</code>中的内容。</li><li>更新DOM：当数据变化时，Vue会根据虚拟DOM的变化来更新实际的DOM。</li></ol></li></ol></li><li><p>调用组件</p><ol><li>引入组件有两种方式<ol><li>直接在要使用的页面中导入</li><li>在main.js中导入，然后app.component（”组件名称”,组件）注入全局这样就可以在全局使用了</li></ol></li><li>在组件中调用的组件名称也有两种方式<br>在 Vue.js 中，当您在 <code>main.js</code> 中全局注册组件时，例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PanelHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/PanelHead.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;PanelHead&#x27;</span>, <span class="hljs-title class_">PanelHead</span>);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><p>尽管您注册的组件名称是 <code>&#39;PanelHead&#39;</code>，但在模板中可以使用 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code> 或<code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code>的形式来引用，</p><p><strong>原因如下：</strong></p><ol start="3"><li><p><strong>组件名的大小写不敏感解析：</strong></p><p>Vue 在解析模板时，会将自定义组件标签名中的连字符形式（kebab-case）和大驼峰形式（PascalCase）都识别为同一个组件。例如：</p><ul><li><code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code></li><li><code>&lt;panel-head&gt;&lt;/panel-head&gt;</code></li></ul><p>上述两种写法都会被解析为注册的 <code>&#39;PanelHead&#39;</code> 组件。</p></li><li><p><strong>组件名的规范化：</strong></p><p>根据 Vue 的组件名解析规则，注册时的组件名会被标准化处理，模板中的标签名也会被转换为相应的格式，以进行匹配。</p><ul><li>注册组件时使用 PascalCase（大驼峰命名）的名称。</li><li>在模板中，可以使用 PascalCase 或 kebab-case（短横线命名）形式的组件标签。</li></ul></li><li><p><strong>HTML 中的大小写不敏感性：</strong></p><ul><li>在浏览器解析 HTML 时，标签名是大小写不敏感的。</li><li>为了遵循 HTML 规范，Vue 推荐在模板中使用 kebab-case 的组件名。</li></ul></li></ol><p><strong>总结：</strong></p><ul><li><strong>注册组件：</strong> 使用 PascalCase 命名，例如 <code>&#39;PanelHead&#39;</code>。</li><li><strong>在模板中引用：</strong> 可以使用 <code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code> 或 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，Vue 都能够正确解析。</li><li><strong>推荐使用：</strong> 在模板中使用 kebab-case 形式，即 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，以符合 HTML 规范和提高可读性。</li></ul></li><li><p><a id="vue3核心"></a>组合式API与选项式API的对比（本项目中使用组合式API）</p><ol><li><p>组合式API：Vue3提供了丰富的组合式API，帮助开发者管理组件的行为，核心功能如下：</p><ol><li><code>&lt;script setup&gt;</code> 是在单文件组件中使用组合式 API 的编译时语法糖。主要特点：<ol><li><p>顶层变量&#x2F;函数自动暴露给模板：意思是说<code>&lt;script setup&gt;</code> 中定义的变量和函数会自动暴露给当前组件的模板使用;这种暴露仅限于当前组件内部的 template 部分;</p><ol><li>无需 return 和 export 语句</li><li>引入的组件自动注册<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>   &lt;script setup&gt;<br>   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br>   <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span><br><br>   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++<br>   &lt;/script&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   <span class="hljs-string">``</span><span class="hljs-string">`              </span><br><span class="hljs-string">2. 组件实例的访问:父组件通过 ref 访问子组件时，访问的是子组件的实例;出于安全考虑，Vue 3 默认关闭了组件实例的属性访问需要通过 defineExpose 明确声明哪些属性/方法可以被父组件访问;</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br>      &lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)          <span class="hljs-comment">// ✅ 自动暴露给当前模板使用</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">defineExpose</span>(&#123; count &#125;) <span class="hljs-comment">// ✅ 显式暴露给父组件访问</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;&#123; count &#125;&#125;  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 count --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 increment --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 父组件 <span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// 访问子组件实例的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childRef.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>)        <span class="hljs-comment">// ✅ 可以访问（因为被 defineExpose 暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   childRef.<span class="hljs-property">value</span>.<span class="hljs-property">increment</span>          <span class="hljs-comment">// ❌ 不能访问（未被暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>这种设计的目的是：</p><pre><code class="hljs">     提高代码的可维护性     增强组件的封装性     避免父组件随意访问和修改子组件的内部状态</code></pre></li></ol></li><li>响应式系统：数据变更自动触发视图更新 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// ref 基本类型响应式</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>count.<span class="hljs-property">value</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br><br><span class="hljs-comment">// reactive 对象响应式</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;)<br>state.<span class="hljs-property">age</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br></code></pre></td></tr></table></figure></li><li><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html">生命周期钩子</a>(选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子。组合式 API：需要手动导入所需的响应式函数和生命周期钩子，从而提供更灵活和模块化的代码结构，他们俩周期钩子也有差别；比如组合式没有beforecreate，把setup当created用，其它就当改了个名)</li></ol><p><img src="/2024/10/16/vueVite/note_vue/1731056688357.png" alt="1731056688357"></p><p><img src="/2024/10/16/vueVite/note_vue/image.png" alt="alt text"><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span></span><br><span class="language-xml">      增加 1</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">import</span> &#123; ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染之前调用的时beforeMount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染完成调用的时mounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之前调用的时beforeUpdate函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之后调用的时updated函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之前调用的时beforeUnmount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之后调用的时unmounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><br> 4. 响应式监听<br>    1. watch的两个参数<br>       1. watch 的第一个参数需要是一个响应式数据（可以是多个），或者是一个返回值的函数。（比如返回一个对象obj的属性() &#x3D;&gt; obj.age）<br>       2. 箭头函数(newValue,oldValue) &#x3D;&gt; {}<br>          1. oldValue：监听的值在变化之前的值<br>          2. newValue：监听的值在变化之后的值<br>    2. watch的触发条件<br>       1. 要让 watch 监听器生效，需要在运行时修改被监听的响应式数据。直接在代码中修改变量的初始值（即在组件加载前设置的值）并不会触发 watch 的回调函数。watch 的作用是监听响应式数据的变化，当数据在运行时发生改变时（例如用户点击按钮触发事件函数），watch 才会检测到这种变化并执行回调函数。<br>    3.  watch的两个属性：<br>       1. immediate（获取初始化）：当设置为 true 时，监听器会在绑定后立即触发回调函数。这意味着在初始化阶段，即使被监听的值没有发生变化，回调函数也会被调用一次。作用如下<br>          1. 在组件加载时，需要根据初始值执行一些操作，例如根据初始参数请求数据。而不必等待被监听的值发生变化。<br>          2. 在组件创建时，需要将某些响应式数据同步到其他地方<br>          3. 在初始化组件的时候oldValue是undefined，newValue是当前值(初始值)<br>       2. deep：true<br>          1.  Vue3 的 reactive 会自动对对象进行深层代理（Proxy），所以：当直接修改 监听对象的内置嵌套对象时，两个监听器都会触发<br>          2.  deep: true 主要用于以下场景：<br>              1.  当你使用 reactive 对象作为 watch 的源，且需要在对象被整个替换时触发监听<br>              2.  当监听的是一个返回非响应式对象的 getter 函数时<br>            <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> deep = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,<br>   <span class="hljs-attr">info</span>: &#123;<br>      <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>      <span class="hljs-attr">contacts</span>: &#123;<br>         <span class="hljs-attr">phone</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>         <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;test@example.com&#x27;</span><br>      &#125;<br>&#125;<br>&#125;)<br><span class="hljs-title function_">watch</span>(deep, <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj changed&#x27;</span>)<br>&#125;)<span class="hljs-comment">//vue3自带不需要deep</span><br><br><span class="hljs-comment">// 如果是这种情况，则需要 deep: true：当改变的是 deep.info时，returnNonReactiveObj会被整个替换</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">returnNonReactiveObj</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br><span class="hljs-attr">info</span>: deep.<span class="hljs-property">info</span><br>&#125;)<br><span class="hljs-title function_">watch</span>(returnNonReactiveObj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;non-reactive obj changed:&#x27;</span>, newValue)<br>&#125;, &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;)<br><br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br> <span class="hljs-keyword">import</span> &#123; ref, reactive, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br> <span class="hljs-keyword">const</span> counter1 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-keyword">const</span> counter2 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-comment">// 监听多个</span><br> <span class="hljs-title function_">watch</span>([counter1, counter2], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter1 value is: &#x27;</span> + counter1.<span class="hljs-property">value</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter2 value is: &#x27;</span> + counter2.<span class="hljs-property">value</span>)<br> &#125;)<br><br> <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br> &#125;)<br> <span class="hljs-comment">//监听初始化值</span><br> <span class="hljs-title function_">watch</span>(obj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br> <span class="hljs-comment">// watch监听单个属性</span><br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">name</span>, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br><br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>计算属性:更加灵活，可以在定义响应式变量时声明;<code>computed</code> 可以用于任何类型的数据处理，不仅限于数值计算。</p><ol><li>核心优势<ul><li>可处理任何数据类型</li><li>自动跟踪依赖关系</li><li>具有缓存机制</li><li>提高代码可读性和维护性</li></ul></li><li>以下是一些常见用例<ol><li><p><strong>字符串处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串转换</span><br><span class="hljs-keyword">const</span> upperCase = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> name.<span class="hljs-property">value</span>.<span class="hljs-title function_">toUpperCase</span>())<br><span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;firstName.value&#125;</span> <span class="hljs-subst">$&#123;lastName.value&#125;</span>`</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>数组处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数组过滤</span><br><span class="hljs-keyword">const</span> activeTodos = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>))<br><span class="hljs-comment">// 数组排序</span><br><span class="hljs-keyword">const</span> sortedList = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> items.<span class="hljs-property">value</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>))<br></code></pre></td></tr></table></figure></li><li><p><strong>对象处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象转换</span><br><span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;user.value.firstName&#125;</span> <span class="hljs-subst">$&#123;user.value.lastName&#125;</span>`</span>,<br>  <span class="hljs-attr">age</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span>,<br>  <span class="hljs-attr">isAdult</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span><br>&#125;))<br></code></pre></td></tr></table></figure></li><li><p><strong>复杂逻辑</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 购物车计算</span><br><span class="hljs-keyword">const</span> cartTotal = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> cart.<span class="hljs-property">value</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> total + (item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>字符倒序</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;this is a value&#x27;</span>)<br><br><span class="hljs-comment">// 注意这里</span><br><span class="hljs-keyword">const</span> reversedValue = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// 使用 ref 需要 .value</span><br><span class="hljs-keyword">return</span> value.<span class="hljs-property">value</span><br>   .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>条件渲染和列表渲染</p><ol><li><p>v-for的参数</p><ol><li>如下代码中的v-for&#x3D;”(item, index) in props.menuData” 中：这个 index 是 Vue 提供的数组索引值，是 v-for 指令内置提供的第二个参数表示当前遍历项在数组中的索引值(从0开始)是可选参数,如果不需要索引值，可以省略<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">!-- 假设 props.<span class="hljs-property">menuData</span> 是这样的数组 --&gt;<br>  [<br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单1&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 0</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单2&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 1</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单3&#x27;</span> &#125; &#125;   <span class="hljs-comment">// index = 2</span><br>  ]                       <br>   v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, index) in array&quot;</span><br>  <span class="hljs-comment">// item: 当前项</span><br>  <span class="hljs-comment">// index: 当前项的索引</span><br>                       <br></code></pre></td></tr></table></figure></li></ol></li><li><p>v-if 中 index 和 key</p><ol><li><p>index&#x3D;”<code>$&#123;index&#125;-$&#123;item.meta.id&#125;</code>“</p><ol><li>这是 Element Plus 菜单组件特有的属性</li><li>用于标识每个菜单项的唯一路径</li><li>帮助菜单组件追踪当前选中的菜单项</li><li>通常用于控制菜单的激活状态</li></ol></li><li><p><code>key</code> 属性:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">:key=&quot;`$&#123;index&#125;-$&#123;item.meta.id&#125;`&quot;<br></code></pre></td></tr></table></figure></li></ol><ul><li>这是 Vue 框架要求的特殊属性</li><li>用于给 v-for 循环中的每个元素一个唯一标识</li><li>帮助 Vue 在虚拟 DOM 更新时准确识别节点</li><li>提高渲染性能和准确性</li></ul><p>  它们的主要区别：</p><ul><li><code>index</code> 是功能性的唯一标识，用于菜单组件的功能实现</li><li><code>key</code> 是结构性的唯一标识，用于 Vue 框架的 DOM 更新优化</li></ul></li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 项目中的菜单组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in props.menuData&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 无子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.children || item.children.length == 0&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:indx</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 结合路由信息以及动态元素实现图标渲染 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 菜单标题 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 有子菜单：分两个部分：标题+递归调用子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-sub-menu</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-else</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 标题区域的内容： #title是 Element Plus 的 el-sub-menu 组件预定义的插槽名称 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 递归调用此组件实现子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- index：1  1-2  1-3 实现每个菜单项的唯一标识 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">SubMenu</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:menuData</span>=<span class="hljs-string">&quot;item.children&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-sub-menu</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="hljs-string">``</span><span class="hljs-string">`                   </span><br><span class="hljs-string"></span><br><span class="hljs-string"> `</span><span class="hljs-string">``</span>js<br>&lt;template&gt;<br>   &lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>显示内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>其他内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   &lt;!-- 列表渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="language-xml">         &#123;&#123; item.name &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目1&#x27;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目2&#x27;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   ])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>v-if和v-show的区别</p><ul><li><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue.js 中用于条件渲染的指令，但它们有不同的作用和使用场景。</p></li><li><p>总结：</p><ul><li>使用 <code>v-if</code> 时，元素在条件为假时不会存在于 DOM 中。</li><li>使用 <code>v-show</code> 时，元素始终存在于 DOM 中，只是通过 CSS 控制显示或隐藏。</li></ul></li><li><p><code>v-if</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来有条件地渲染元素。</li><li><strong>特点</strong>：元素及其绑定的事件和子组件在条件为假时不会被渲染或销毁。</li><li><strong>性能</strong>：初始渲染时有更高的开销，因为需要添加或删除 DOM 元素。</li></ul></li><li><p><code>v-show</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来切换元素的显示状态。</li><li><strong>特点</strong>：元素始终会被渲染并保留在 DOM 中，只是通过 CSS 的 <code>display</code> 属性来控制显示或隐藏。</li><li><strong>性能</strong>：初始渲染开销较小，但频繁切换显示状态时性能更好。</li></ul></li><li><p>使用场景</p><ul><li>**<code>v-if</code>**：适用于在运行时条件很少改变的场景，因为它会在条件变化时进行 DOM 的添加和删除。</li><li>**<code>v-show</code>**：适用于需要频繁切换显示状态的场景，因为它只会切换 <code>display</code> 属性。</li></ul></li><li><p>示例</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;!-- v-<span class="hljs-keyword">if</span> 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>  &lt;!-- v-show 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isShow</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isVisible</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>事件处理与双向绑定</p><ol><li><code>v-model</code> 的用途:获取表单中的输入数据赋值给变量；<code>v-model</code> 是 Vue.js 中用于创建<strong>双向数据绑定</strong>的指令，主要用于表单输入元素与应用状态之间的同步。主要功能如下<ol><li><p><strong>双向绑定</strong>：</p><ul><li>自动将用户输入的值同步到组件的状态（如 <code>data</code> 或 <code>ref</code>）。</li><li>同时，当状态发生变化时，更新输入元素的显示值。</li></ul></li><li><p><strong>简化代码</strong>：</p><ul><li>替代手动编写 <code>:value</code> 和 <code>@input</code> 事件处理器，实现更简洁的双向绑定。</li></ul></li></ol></li><li>常见用法</li></ol><ul><li><p><strong>文本输入</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>复选框</strong>：</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input type=&quot;checkbox&quot; v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>选择框</strong>：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">      &lt;select v-model=&quot;变量名&quot;&gt;<br>         &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt;<br>         &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt;<br>      &lt;/select&gt;<br><br> ```js<br>&lt;template&gt;<br>      &lt;input v-model=&quot;username&quot; /&gt;<br>   &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const username = ref(&#x27;&#x27;)<br>const handleClick = () =&gt; &#123;<br>console.log(username.value)<br>&#125;<br>&lt;/script&gt;<br>/*<br>   - **`v-model=&quot;username&quot;`**：<br>   - 将输入框的值与 `username` 变量绑定。<br>   - 用户在输入框中输入内容时，`username` 会自动更新。<br>   - 如果在代码中修改 `username` 的值，输入框的显示内容也会相应更新。<br><br>*/<br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>对比一下选项式API：在 Vue 2 和 Vue 3 的选项式 API 中的<code>&lt;script&gt;</code>中需要 return 和 export 的原因：(这些在组合式API中都不用考虑)</p><ol><li>export default 的目的：<ol><li>将组件配置对象导出，使其可以被其他组件引入使用</li><li>这是 ES6 模块系统的要求</li><li>Vue 通过这个导出的对象来创建组件实例</li></ol></li><li>return 的目的：<ol><li>在 data() 函数中返回数据对象，使其成为响应式数据</li><li>每个组件实例都需要独立的数据副本，避免数据共享<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-comment">// 选项式 API</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyComponent&#x27;</span>,<br><br><span class="hljs-comment">// data 必须是函数并返回对象，确保每个组件实例有独立的数据副本</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">methods</span>: &#123;<br>   <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">computed</span>: &#123;<br>   <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>   &#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br><span class="hljs-comment">// ❌ 错误示例</span><br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//组合式API中：组合式API基础语法</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 方式1：使用 ref() 定义基础类型</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><br><span class="hljs-comment">// 方式2：使用 reactive() 定义对象类型</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 使用时：(在template之外)</span><br><span class="hljs-comment">// ref 需要 .value </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>)<br><br><span class="hljs-comment">// reactive 直接使用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">message</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在模板中使用 ref 不需要 .value --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- reactive 对象的使用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>选项式与组合式API的区别（除了上述之外）： </p><ol><li><p>选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子等等。</p></li><li><p>组合式 API：需要手动导入所需的响应式函数和生命周期钩子等等，从而提供更灵活和模块化的代码结构。（除了编译器宏比如defineProps，编译器宏：由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 ‘vue’ 中导入。自动可用：在<code>&lt;script setup&gt;</code>块内，defineProps 会被自动识别并处理。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//拿子传父举例</span><br><span class="hljs-comment">// 选项式 API</span><br>&lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);<span class="hljs-comment">//自动处理this.$emit</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// 组合式 API</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>选项式 API 和 组合式 API 的主要区别补充：</p><ol><li><p><strong>组织代码的方式</strong></p><ul><li><strong>选项式 API</strong>：通过选项（如 <code>data</code>、<code>methods</code>、<code>computed</code> 等）组织代码，适合简单组件。</li><li><strong>组合式 API</strong>：通过组合函数（如 <code>setup</code>）组织代码，更适合复杂逻辑和代码复用。</li></ul></li><li><p><strong>逻辑复用</strong></p><ul><li><strong>选项式 API</strong>：依赖混入（mixins）和高阶组件（HOCs），可能导致命名冲突和难以追踪。</li><li><strong>组合式 API</strong>：使用组合函数（composables）实现逻辑复用，结构更清晰，避免命名冲突。</li></ul></li><li><p><strong>类型推导和 TypeScript 支持</strong></p><ul><li><strong>选项式 API</strong>：TypeScript 支持有限，类型推导较复杂。</li><li><strong>组合式 API</strong>：与 TypeScript 集成更好，提供更精准的类型推导。</li></ul></li><li><p><strong>代码组织与可维护性</strong></p><ul><li><strong>选项式 API</strong>：按选项分割，功能分散，难以管理大型组件。</li><li><strong>组合式 API</strong>：按功能分割，相关逻辑集中，提升可维护性。</li></ul></li><li><p><strong>生命周期钩子</strong></p><ul><li><strong>选项式 API</strong>：通过选项直接定义生命周期钩子（如 <code>mounted</code>、<code>created</code>）。</li><li><strong>组合式 API</strong>：在 <code>setup</code> 内使用函数（如 <code>onMounted</code>、<code>onCreated</code>）定义生命周期钩子。</li></ul></li><li><p><strong>响应式系统</strong></p><ul><li><strong>选项式 API</strong>：使用 <code>data</code> 对象进行响应式管理，自动处理响应式属性。</li><li><strong>组合式 API</strong>：使用 <code>ref</code>、<code>reactive</code> 等函数显式创建响应式数据，更灵活。</li></ul></li><li><p><strong>学习曲线</strong></p></li></ol><ul><li><strong>选项式 API</strong>：更直观，适合 Vue 新手。</li><li><strong>组合式 API</strong>：需要理解响应式原理和组合函数，学习曲线稍陡。</li></ul><ol start="8"><li><strong>调试和测试</strong></li></ol><ul><li><strong>选项式 API</strong>：由于逻辑分散，单独测试某一功能较困难。</li><li><strong>组合式 API</strong>：逻辑集中，单元测试和调试更容易。</li></ul></li><li><p>最后总结一下两者的异同：</p><ol><li>同：无论是选项式还是组合式API，都得遵循js的规范，比如任何变量使用前必须申明，否则会报错；调用其他组件时都需要导入相应文件；</li><li>异：<ol><li>选项式需要export default导出组件对象，并在其中使用components申明导入的组件、data（）函数return 返回数据变量&#x2F;对象（定义申明）以实现相应，而组合式直接ref&#x2F;reactive即可；</li><li>组合式中需要导入响应式函数和生命周期钩子等等，而选项式不需要；（除了编译器宏比如defineProps之外）</li></ol></li><li>在这个项目中我主要使用组合式，往后就不管选项式了</li></ol></li></ol></li></ol></li><li><p><code>&lt;style scoped&gt;&lt;/style&gt;</code>：用于定义组件的样式。开发者可以使用CSS或预处理器（如Sass、Less、Tailwind CSS，问perplexity）编写样式：</p><ol><li><code>&lt;style&gt;</code> 标签内编写的 CSS 样式默认是全局作用域，会影响到其他路由页面。要使样式仅作用于当前组件，需要在 <code>&lt;style&gt;</code> 标签上添加 scoped 属性：   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style lang=<span class="hljs-string">&quot;less&quot;</span> scoped&gt;<br> <span class="hljs-comment">/* 在这里添加样式 */</span><br> .<span class="hljs-property">logo</span>-lg &#123;<br> font-<span class="hljs-attr">size</span>: 20px;<br> text-<span class="hljs-attr">align</span>: center;<br> <span class="hljs-attr">height</span>: 50px;<br> line-<span class="hljs-attr">height</span>: 50px;<br> <span class="hljs-attr">color</span>: style<br> &#125;<br> &lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>根组件App.vue:包含了整个应用程序的布局结构<ol><li>页面渲染的入口点。所有其他组件都会嵌套在App.vue中</li><li>通常会与Vue Router的组件<code>&lt;RouterView /&gt;</code>结合使用，处理页面之间的导航和路由，实现不同页面的切换和展示；如果使用了路由，但是App.vue中没有<code>&lt;RouterView /&gt;</code>，则路由无法正常工作;经典内容如下：   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><br>&lt;template&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li><li>Vue应用的入口文件main.js：初始化Vue实例并将其挂载到DOM中，导出了整个应用程序所需的全局状态和方法。一般来说，在这里初始化一些全局变量或函数，以便于后续操作，其基础操作如下：<ol><li>导入router实例<code>import router from &#39;./router&#39;</code>；(访问router&#x2F;index.js文件)</li><li>创建app实例<code>const app = createApp(App)</code>，这里的App是根组件App.vue;</li><li>挂载router实例<code>app.use(router)</code></li><li>挂载app实例到指定ID的div元素上：<code>app.mount(&#39;#app&#39;)</code><ol><li>这里的#app是index.html中的一个div元素的id，Vue会将app实例挂载到这个元素上，从而渲染整个应用</li><li>你也可以将app实例挂载到其他元素上,但要在index.html中添加相应的元素以及id属性</li><li>默认使用#app的原因<ol><li>约定俗成：使用id&#x3D;”app”是Vue文档和许多示例中的常见做法，主要是为了简化学习和开发过程。开发者可以快速识别出这是Vue应用的挂载点。</li><li>避免冲突：在大型应用中，使用特定的id可以帮助避免与其他JavaScript库或框架的冲突，确保Vue应用的DOM元素明确且独特。</li></ol></li></ol></li></ol></li><li>router文件夹：<ol><li>功能：路由管理<ol><li>导入组件，定义路由规则,控制页面间的跳转逻辑</li><li>定义 URL 路径与组件的对应关系</li><li>管理路由参数传递</li><li>router&#x2F;index.js负责初始化和配置Vue应用; 主要功能如下<ol><li>定义路由routes</li><li>创造并导出router实例</li></ol></li><li>注意：不能重复导入同一个组件，否则会导致组件重复注册，从而引发错误</li></ol></li><li>典型结构<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router/index.js</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span><br><span class="hljs-keyword">const</span> routes = [<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Home.vue&#x27;</span>)<br>&#125;,<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/About.vue&#x27;</span>)<br>&#125;<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>routes<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br><br></code></pre></td></tr></table></figure></li></ol></li><li>View文件夹：<ol><li>视图功能:负责页面渲染<ol><li>存放页面级别的组件</li><li>对应具体的路由页面</li><li>组合和管理其他小组件</li></ol></li><li>与components的区别<ol><li>views：负责页面级别的组件，对应具体路由逻辑的页面（也就是说路由怎么设置的，view下就要有相应的页面组件），组合和管理其他小组件（可嵌入components中或者view中子组件）</li><li>components：负责通用的小组件，可以在多个页面中复用，不涉及具体的路由逻辑</li></ol></li><li>举例 Main.vue<ol><li>作用：主要负责页面的整体布局和结构，包含了整个页面的主要内容</li><li>典型结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- views/<span class="hljs-title class_">Main</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Aside</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><pre><code class="hljs"> 1.  services ：存放业务逻辑层面的代码，包括多个组件共用的服务端接口调用函数等 2.  utils：存放通用工具函数，不同的地方不重复书写相同的代码片段</code></pre><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ul><li>当启动应用程序时，Vite 会按照如下顺序加载和处理这些文件：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">读取 package<span class="hljs-selector-class">.json</span>：获取项目依赖项和脚本信息。<br>解析 vue<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>：配置Vite的行为，包括环境变量管理、插件注册等。<br>载入 <span class="hljs-attribute">src</span>/App<span class="hljs-selector-class">.vue</span>：作为应用程序的根组件，负责渲染页面结构。<br>执行 <span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>：初始化应用程序，全局状态和方法的创建。<br>递归查找并加载各个组件：从根组件开始，逐级向下寻找并注入子组件，形成完整的DOM树结构。<br>优化与缓存处理：利用Vite提供的内置优化机制，对JS/CSS进行压缩混淆，以及对第三方库进行tree-shaking以减少无效代码。<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vueWatch</title>
    <link href="/2024/10/15/vueWatch&amp;deep/"/>
    <url>/2024/10/15/vueWatch&amp;deep/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简单讲讲vue3的watch函数和:deep伪类选择器</p></blockquote><span id="more"></span><h2 id="watch-函数说明"><a href="#watch-函数说明" class="headerlink" title="watch 函数说明"></a>watch 函数说明</h2><ol><li><code>watch</code> 是 Vue 3 的组合式 API 之一，用于监听响应式数据的变化</li><li>它接收两个主要参数：<ul><li>第一个参数：要监听的数据源（这里是一个返回 <code>route.params.id</code> 的箭头函数）</li><li>第二个参数：当数据变化时触发的回调函数</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>,  <span class="hljs-comment">// 监听路由参数中的id变化</span><br>  <span class="hljs-function">(<span class="hljs-params">newId</span>) =&gt;</span> &#123;           <span class="hljs-comment">// newId 是变化后的新值</span><br>    <span class="hljs-keyword">if</span> (newId) &#123;<br>      <span class="hljs-title function_">fetchData</span>()        <span class="hljs-comment">// 当id变化时重新获取数据</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;重新获取推荐视频&quot;</span>)<br>    &#125;<br>  &#125;<br>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/videoDetail&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> &#125;<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;<br>    videoInfo.<span class="hljs-property">value</span> = data.<span class="hljs-property">result</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;视频详情数据&#x27;</span>, data.<span class="hljs-property">result</span>)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个典型的用例，常用于需要根据路由参数重新获取数据的场景。</p><ul><li><code>newId</code> 在这里指的是路由参数中的 <code>id</code> 的新值</li><li>这段代码的作用是监听视频的 ID 变化（通常在 URL 中），当用户切换到不同的视频时：<ol><li>路由参数 <code>id</code> 发生变化</li><li>watch 检测到变化，触发回调函数</li><li>执行 <code>fetchData()</code> 获取新视频的推荐内容</li></ol></li></ul><h3 id="key动态监测变化，自动重新渲染组件"><a href="#key动态监测变化，自动重新渲染组件" class="headerlink" title="key动态监测变化，自动重新渲染组件"></a>key动态监测变化，自动重新渲染组件</h3><ul><li>接着上面的例子，当检测到路由id变化后通过fetchData重新获数据后，还需要通过组件标签中的key属性实现组件自动重新渲染；如下例子所示，路由变化后嵌入的视频会自动更新；<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-play&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span></span><br><span class="hljs-tag">     <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;videoInfo.videoSrc&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;videoInfo.videoSrc&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="deep-选择器"><a href="#deep-选择器" class="headerlink" title=":deep() 选择器"></a>:deep() 选择器</h2><p><code>:deep()</code> 是 Vue 3 中的深度选择器，用于穿透 scoped CSS 的作用域限制。</p><ol><li>当使用 <code>&lt;style scoped&gt;</code> 时，Vue 会为组件的元素添加一个唯一的属性（如 data-v-hash）</li><li>样式会被编译为带有这个属性选择器的形式，从而将样式限制在当前组件内</li><li>但有时我们需要修改子组件或第三方组件的内部元素样式，这时就需要 <code>:deep()</code></li></ol><ul><li>另外值得注意的事，:deep属性最好选择class，不要选择组件名</li><li>使用示例<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 不使用 :deep 时（只能影响当前组件的元素）</span><br><span class="hljs-selector-class">.tabs</span> <span class="hljs-selector-class">.van-tab</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-comment">// 使用 :deep 后（可以影响子组件内部元素）</span><br><span class="hljs-selector-class">.tabs</span> :<span class="hljs-selector-tag">deep</span>(.van-tab) &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>比如说在vue项目中修改组件中引入的vant组件：<code>:deep(.van-tab--active)</code> 就是为了修改 Vant 组件库中 Tab 组件的激活状态样式。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create my blog</title>
    <link href="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章讲述搭建博客的原因、过程以及使用hexo的技巧</p></blockquote><span id="more"></span><h2 id="为什么搭建博客？"><a href="#为什么搭建博客？" class="headerlink" title="为什么搭建博客？"></a>为什么搭建博客？</h2><p>学习的步骤可以分为输入、处理、输出三步，每一步都很重要，如果你学完某些内容却没有输出任何东西，那么它带给你受益是微乎其微的，随着时间的流逝，趋近于0；而写博客是一个非常方便的输出方式，写作的过程和内容也能体现出一个人的思考以及体会，更能帮助其更深一步理解所学知识；</p><p>对于一名计算机类专业的学生，我们接受的输入本身就大得多（相较大部分专业）；输出的重要性不言而喻，我下了面从5点论述，为什么写作对于程序员非常重要。</p><ol><li><p>写作&#x3D;协作，良好的写作能力促进人与人之间的交流，让整个团队的知识成果以文档的形式沉淀下来，使得项目更好更久地运行下去以及拓展；在大公司中越是职位越高的人越能出口成章流畅输出观点，他们的影响力也越大</p><div align="center"><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/创建博客/1730185605407.png" width="300" height="200"></div></li><li><p>写作是学习的催化剂：写作不仅是向别人解释某个概念，它还能帮助我们更深入地思考问题，让思路更清晰；一旦养成写作的习惯，就会慢慢形成正循环。</p><div align="center"><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/创建博客/1730185650216.png" width="300" height="200"></div></li><li><p>温故而知新：写作需要大量的阅读的资料作为支撑，所以写作也会让你更精确，更注重细节和刨根问底，帮助你复盘学习过程，并揭示看似理解了实际上却并不理解的知识，当你意识到当前的某些知识是在模糊不稳定的基础之上时，你就会开始寻找缺失的部分，获得更深的理解；</p></li><li><p>写代码和写文章有很多共同之处，顶尖的工程师往往也是好的文章作者，他们的文章和代码一样有逻辑性、行文流畅、优雅且工整;</p><center><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/创建博客/1730190710172.png" width="300" height="200"><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/创建博客/1730190889437.png" width="300" height="200"></center></li><li><p>博客是写文章的一种很好的载体，坚持下去，无论有多少人看，收益最大的人一定是自己；</p></li></ol><ul><li><a href="https://www.bilibili.com/video/BV1eb421e7Ui/?share_source=copy_web&vd_source=7f150cf40745ac06f41469483a60fc41">参考</a></li></ul><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><ul><li>使用hexo搭建博客；具体参考<ul><li><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></li><li><a href="https://blog.csdn.net/cat_bayi/article/details/128725230">https://blog.csdn.net/cat_bayi/article/details/128725230</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide">https://fluid-dev.github.io/hexo-fluid-docs/guide</a></li></ul></li></ul><ol><li><p>关联github page的仓存到本地</p></li><li><p>安装hexo</p></li><li><p>配置主题</p><ol><li>选择的是这个：<a href="https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file">https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file</a></li></ol></li><li><p>安装hexo-deployer-git插件实现自动远程部署：npm install hexo-deployer-git –save</p></li><li><p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p><pre><code class="hljs">  deploy:     type: git     repository: git@github.com:用户名/用户名.github.io.git     branch: main</code></pre></li><li><p>关联域名： <a href="https://github.com/wcool1/wcool1.github.io/settings/pages">打开github上博客仓库的设置</a>: 重新设置Custom domain:[<a href="http://www.tolsz];并开启https;(github给的权益)">www.tolsz];并开启https;(github给的权益)</a></p><ul><li>为什么github pages部署hexo之后每次hexo g -d后关联的域名都会失效,每次都要在github上手动设置吗;<ul><li><a href="https://whybee.blog.csdn.net/article/details/140328361?spm=1001.2014.3001.5502">参考链接</a>：</li></ul><ol><li>不需要，只需要在github的该仓库中创建一个CNAME文件并将域名写入即可；等个1min就好了；但这样再下一次推送后CNAME文件又会失踪；原因如下</li><li>偶然中发现，刚开始还未部署hexo时本地仓库整个文件夹都和远程git仓库是关联同步的，包括CNAME和README.md都是同步的；但是部署hexo之后，远程仓库中只含有博客项目下的.deploy_git下的文件夹；每次更新使用hexo g 会根据本地内容（source中的文件）生成相应页面到pulic中， 然后hexo d进行部署时，会将public中的文件同步deploy_git下同时推送到远程的github仓库；即source下所有的文件内容对应public;比如source&#x2F;A hexo -g之后就会在public&#x2F;A 生成相应内容；</li><li>这也是为什么1中操作下CNAME文件会消失，因为public下没有CNAME文件，所以推送到远端时，自然也没有；解决办法就是在source文件夹下创建CNAME文件添加不含http前缀的域名，然后hexo g -d即可；</li><li>由于dns缓存的原因，每次更新并部署后需要过一会（20s-60s）才能看到新的内容，样式与本地的markdown看到的几乎一样；</li></ol></li></ul></li><li><p>常用命令：</p><pre><code class="hljs">  hexo new &quot;name&quot;       # 新建文章  hexo new page &quot;name&quot;  # 新建页面  hexo g                # 生成页面  hexo d                # 部署  hexo g -d             # 生成页面并部署  hexo s                # 本地预览  hexo clean            # 每次更新前使用：清除缓存文件: 删除 public 文件夹、db.json 文件以及 _config.yml 中配置的 public_dir 目录下的所有文件。确保生成干净的网站文件: 清除缓存后，下次运行 hexo generate 命令时，会重新生成所有网站文件，避免旧文件的影响。这样会导致你直接在Public下对文件做的修改比如更换Img、html等等都会被撤销；因此，强调修改任何东西都是在source、配置文件下才是正确稳妥的；  hexo help             # 帮助</code></pre></li><li><p>基本操作</p><ol><li><p>删除&#x2F;删除页面：直接在本地source &#x2F; _post 文件夹中删除&#x2F;修改相应文件然后hexo clean; hexo g -d即可</p></li><li><p>图片操作：</p><ol><li>插入图片时需要考虑其大小以及排版在此博客系统上的效果，一般使用html标签调整，设置width&#x2F;height为百分比；eg:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://alexcld.com/images/pengyuyan.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;25%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;25%&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>实际上，hexo渲染一篇post的工作流程是：</p><pre><code class="hljs">  拿到一个markdown文件，  根据这个文件的layout类型，  进行样式排版，生成html文件，  最终展示到网页端。</code></pre></li><li><p>发布一篇博客的操作流程</p><ol><li>进入本地git所在根目录</li><li>hexo new ‘title’</li><li>hexo clean</li><li>hexo g -d</li></ol></li></ol></li></ol><h2 id="hexo使用技巧"><a href="#hexo使用技巧" class="headerlink" title="hexo使用技巧"></a>hexo使用技巧</h2><ol><li>设置文章摘要和标签操作举例如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">hello</span> <span class="hljs-string">hexo</span> <span class="hljs-string">markdown</span><br><span class="hljs-attr">date:</span> <br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hello</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">我是短小精悍的文章摘要(๑•̀ㅂ•́)</span> <span class="hljs-string">✧</span><br><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><br><span class="hljs-string">紧接着文章摘要的正文内容</span><br><br><br></code></pre></td></tr></table></figure></li><li>资源引用：除了url的绝对引用外，相对引用可以使用 Hexo 提供的资源文件夹功能:使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。Hexo 将会在我们每一次通过 hexo new title 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章中所引用的相关资源比如截图放到这个同名文件夹下，然后通过相对路径引用；不针对封面等与文章内容无关的资源；<ol><li>强调一下hexo g时，只会将source目录下的img文件夹、_posts下的new出来的md文件以及资源引用开启后下的同名文件夹下的资源文件复制到public下，其他的文件不会复制到public下；因此直接复制图片粘贴到md中的资源图片，vscode会默认在当前目录下创建一个img&#x2F;{title}文件夹用以存放截图，但是此文件夹不会被hexo g复制到public下，因此需要手动将其复制粘贴一份到资源引用功能开启后的同名（title）文件夹下，然后hexo g -d即可；</li></ol></li><li>分类与标签：<ol><li>二者区别：分类具有顺序性和层次性而标签没有顺序和层次；可忽略不计</li><li>在scaffolds&#x2F;post.md设置默认的文章模板如下，生成之后再加入分类&#x2F;标签即可，分类比较好用：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">标签</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">类别</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li></ol></li><li>自定制、美化博客<ol><li>参考：<ol><li><a href="https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/">https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/</a></li><li><a href="https://blog.csdn.net/weixin_51545953/article/details/128499341">https://blog.csdn.net/weixin_51545953/article/details/128499341</a></li></ol></li><li>配置：包括所有图片、导航栏的title、标题等等都在_conflg.主题.yml中设置,其优先级最高,然后考虑_config.yml;</li><li>修改banner图：<ol><li>在网上查找免费开源的风景图片并下载下来（避免版权纠纷）推荐几个免费开源的图片网站<ol><li><a href="https://pixabay.com/">https://pixabay.com/</a></li><li><a href="https://unsplash.com/">https://unsplash.com/</a></li><li><a href="https://www.pexels.com/">https://www.pexels.com/</a></li></ol></li><li>不知为何在配置中修改默认banner_img的属性不生效，但是可以分步设置各个分页的banner图，<a href="https://s81679.github.io/2020/02/25/hexo-theme-fluid/#%E4%B8%BB%E9%A0%81-Banner-%E5%A4%A7%E5%9C%96">参考</a><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 首页</span><br><span class="hljs-symbol">index:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>banner.jpg  <span class="hljs-meta"># 首页 Banner 头图，以下相同</span><br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">100</span>  <span class="hljs-meta"># 头图高度，屏幕百分比，available: 0 - 100</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-meta"># 文章頁</span><br><span class="hljs-meta"># Archive Page</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-symbol">archive:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>articles.jpg<br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-meta"># available: 0 - 100</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-meta"># 分類頁</span><br><span class="hljs-meta"># Categories Page</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-symbol">category:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>categories.jpg<br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-meta"># available: 0 - 100</span><br></code></pre></td></tr></table></figure></li></ol></li><li>设置文章在首页中的封面图：<ol><li>设置模版scaffolds&#x2F;post中添加index_img: &#x2F;img&#x2F;cover&#x2F;<code>&#123;&#123; title &#125;&#125;</code>.png；</li><li>在source&#x2F;img下创建cover文件夹,将new的文章的封面移动到其中，并改为{title}.png</li><li>hexo clean ;hexo g -d</li></ol></li><li>同理，banner_img: &#x2F;img&#x2F;cover&#x2F;<code>&#123;&#123; title &#125;&#125; </code>.png设置文章的banner图</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

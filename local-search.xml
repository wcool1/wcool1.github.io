<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>周末北京武汉往返随记</title>
    <link href="/2025/11/24/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/"/>
    <url>/2025/11/24/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>日记</p></blockquote><span id="more"></span><p>得益于祖国的高速发展，从北京到武汉只需要在复兴号上睡上一晚，第二天睁眼便抵达了。<br>刚下高铁，南北的气候差异便在一呼一吸之间具象化了，</p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>周末北京武汉往返随记</title>
    <link href="/2025/11/24/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/"/>
    <url>/2025/11/24/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>日记</p></blockquote><span id="more"></span><p>得益于祖国的高速发展，从北京到武汉只需要在复兴号上睡上一晚，第二天睁眼便抵达了。<br>刚下高铁，南北的气候差异便在一呼一吸之间具象化了，</p><p><img src="/2025/11/24/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/%E5%91%A8%E6%9C%AB%E5%8C%97%E4%BA%AC%E6%AD%A6%E6%B1%89%E5%BE%80%E8%BF%94%E9%9A%8F%E6%9C%BA/IMG_20251122_080702.jpg" alt="alt text"></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Whisper&amp;deepseek</title>
    <link href="/2025/03/01/Whisper-deepseek/"/>
    <url>/2025/03/01/Whisper-deepseek/</url>
    
    <content type="html"><![CDATA[<blockquote><p>whispher转写会议音频+deepseek总结项目记录</p></blockquote><span id="more"></span><ul><li>目前通过脚本实现与用户的简单交互：.&#x2F;start.sh 一行命令回车进行录音，再回车结束录音后，Whisper进行转写，deepseek进行总结；效果如下</li></ul><p><img src="/2025/03/01/Whisper-deepseek/1742200862032.png" alt="1742200862032"></p><p><img src="/2025/03/01/Whisper-deepseek/1742200884249.png" alt="1742200884249"></p><p>结果生成在&#x2F;data&#x2F;VAproject&#x2F;output&#x2F;时间戳目录下</p><p><img src="/2025/03/01/Whisper-deepseek/1742201037170.png" alt="1742201037170"></p><p>1h40min会议音频测试结果展示在文章末尾，用户也可以通过如下步骤自定义生成docx文件的模版样式（通过pypandoc库实现）；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 打开office word/wps，新建一个空白docx文档<br><span class="hljs-bullet">2.</span> 设置想要的样式，比如标题1、标题2、正文等<br><span class="hljs-bullet">3.</span> 保存样式：修改原样式，勾选基于此模版的新文档<br><span class="hljs-bullet">4.</span> 将文件命名为reference.docx，上传到到盒子中localApp.py的同级目录下<br></code></pre></td></tr></table></figure><ul><li><p>项目整体达到可使用的水平，但还现存一些模型能力带来的小问题</p><ol><li>极少数情况下，某些段落总结中会夹杂着少许英文，添加提示词强调中文输出无用，不明显；</li><li>通过修改模型参数generation_mode&#x3D;’greedy’为“penalty_sample”，可以避免无限输出重复内容的问题，但少数情况下，模型并不按照我的提示词模版进行输出；</li></ol><p><img src="/2025/03/01/Whisper-deepseek/1742201533116.png" alt="1742201533116"><br><img src="/2025/03/01/Whisper-deepseek/1742201699988.png" alt="1742201699988"><br><img src="/2025/03/01/Whisper-deepseek/1742201750479.png" alt="1742201750479"></p></li></ul><div class="row">    <embed src="1h08min.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目预处理初步测试效果</title>
    <link href="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/"/>
    <url>/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如下是目前项目的初步测试结果，包含了对pdf、docx、doc、ppt、png、jpg、bmp、xls、xlsx等各类文档的批处理；</p></blockquote><span id="more"></span><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p><img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image.png" alt="alt text"></p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="发票-pdf"><a href="#发票-pdf" class="headerlink" title="发票.pdf"></a>发票.pdf</h4><p><img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-12.png" alt="alt text"><br><img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-11.png" alt="alt text"></p><h4 id="风景图-lake-jpg"><a href="#风景图-lake-jpg" class="headerlink" title="风景图 lake.jpg"></a>风景图 lake.jpg</h4><p>   <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-3.png" alt="alt text"></p><p>   <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-22.png" alt="alt text"></p><h4 id="动作图-png"><a href="#动作图-png" class="headerlink" title="动作图.png"></a>动作图.png</h4><p>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-14.png" alt="alt text"><br>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-21.png" alt="alt text"></p><h4 id="attention-pdf，着重看其中的图片处理"><a href="#attention-pdf，着重看其中的图片处理" class="headerlink" title="attention.pdf，着重看其中的图片处理"></a>attention.pdf，着重看其中的图片处理</h4><p>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-4.png" alt="alt text"><br>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-13.png" alt="alt text"></p><h4 id="wind-xls"><a href="#wind-xls" class="headerlink" title="wind.xls"></a>wind.xls</h4><p>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-5.png" alt="alt text"><br>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-6.png" alt="alt text"></p><h4 id="word-docx"><a href="#word-docx" class="headerlink" title="word.docx"></a>word.docx</h4><p>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-16.png" alt="alt text"><br>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-17.png" alt="alt text"></p><h4 id="z9-bmp"><a href="#z9-bmp" class="headerlink" title="z9.bmp"></a>z9.bmp</h4><p>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-9.png" alt="alt text"><br>  <img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-10.png" alt="alt text"></p><h4 id="pptx-ppt"><a href="#pptx-ppt" class="headerlink" title="pptx&#x2F;ppt"></a>pptx&#x2F;ppt</h4><p><img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-18.png" alt="alt text"><br><img src="/2025/02/17/OCR%E9%A1%B9%E7%9B%AE%E5%88%9D%E6%AD%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C/image-19.png" alt="alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ollama-minicpm-v</title>
    <link href="/2025/02/13/Ollama-minicpm-v/"/>
    <url>/2025/02/13/Ollama-minicpm-v/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Ollama-minicpm-v是一个基于minicpm的开源项目，本文是对该模型视觉识别效果的简单介绍和使用说明。</p></blockquote><span id="more"></span><h3 id="测评"><a href="#测评" class="headerlink" title="测评"></a>测评</h3><ul><li><p>对图片的描述：描述全面、细节到位；</p><ul><li>风景</li></ul><p>  <img src="/2025/02/13/Ollama-minicpm-v/image-2.png" alt="alt text"><br>  <img src="/2025/02/13/Ollama-minicpm-v/image-3.png" alt="alt text"></p><ul><li>动作</li></ul><p>  <img src="/2025/02/13/Ollama-minicpm-v/image.png" alt="alt text"><br>  <img src="/2025/02/13/Ollama-minicpm-v/image-1.png" alt="alt text"></p><ul><li><p>流程图的理解：基本看懂了这个流程图</p><p> <img src="/2025/02/13/Ollama-minicpm-v/image-6.png" alt="alt text"><br> <img src="/2025/02/13/Ollama-minicpm-v/image-5.png" alt="alt text"></p></li></ul></li><li><p>对图片的OCR：虽然不是完全复原布局，但是该有的信息以及总结都有，也满足Markdown格式</p><p><img src="/2025/02/13/Ollama-minicpm-v/image-8.png" alt="alt text"><br><img src="/2025/02/13/Ollama-minicpm-v/image-10.png" alt="alt text"></p></li><li><p>优点，识别效果远高于其他Ollama中的视觉模型</p></li><li><p>缺点：每次回答结果都不太一样，不太稳定，有时回答不了；</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br><span class="hljs-keyword">import</span> ollama<br><br>response = ollama.chat(<br>    model=<span class="hljs-string">&#x27;minicpm-v&#x27;</span>,<br><br>    messages=[&#123;<br>        <span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>,<br>        <span class="hljs-string">&#x27;content&#x27;</span>: <span class="hljs-string">&#x27;请你识别这种图片，如果这张图片内容大多是文字，直接以Markdown格式给出OCR结果（完整还原布局和信息），否则如果是风景图/流程图等文字量较少的图片，描述一下这张图的内容(特征和细节），使用中文回答&#x27;</span>,<br>        <span class="hljs-string">&#x27;images&#x27;</span>: [<span class="hljs-string">&#x27;1.png&#x27;</span>]<br>    &#125;]<br>)<br><br><span class="hljs-comment"># 只打印消息内容</span><br><span class="hljs-built_in">print</span>(response[<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>]) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExtractThinker</title>
    <link href="/2025/02/06/ExtractThinker/"/>
    <url>/2025/02/06/ExtractThinker/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li>流程：doclingOCR文件生成Markdown文本——llm进行识别并判断是自定义类型中的哪一种——llm进行提取相应类型所需的数据——存入数据库</li><li>参考、<ul><li><a href="https://pub.towardsai.net/building-an-on-premise-document-intelligence-stack-with-docling-ollama-phi-4-extractthinker-6ab60b495751">https://pub.towardsai.net/building-an-on-premise-document-intelligence-stack-with-docling-ollama-phi-4-extractthinker-6ab60b495751</a></li><li><a href="https://github.com/enoch3712/ExtractThinker">https://github.com/enoch3712/ExtractThinker</a></li></ul></li><li>效果如下</li></ul><p><img src="/2025/02/06/ExtractThinker/image.png" alt="alt text"></p><p><img src="/2025/02/06/ExtractThinker/image-1.png" alt="alt text"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>极空间探索</title>
    <link href="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/"/>
    <url>/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>探索极空间的功能</p></blockquote><span id="more"></span><ul><li><p>创建离线账号</p><ul><li>点击用户中心，创建账号&gt;创建本地离线账号，进行离线账号的创建 ，防止万一服务器问题导致的nas不可用</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-1.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-48.png" alt="alt text"></p></li></ul><h3 id="AI功能"><a href="#AI功能" class="headerlink" title="AI功能"></a>AI功能</h3><ul><li>极相册下载AI引擎、打开AI功能</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-4.png" alt="alt text"></p><h4 id="图片OCR"><a href="#图片OCR" class="headerlink" title="图片OCR"></a>图片OCR</h4><ul><li>效果还行就是没排版，和微信&#x2F;qq自带的OCR差不多</li><li>由于滚动条没办法长截屏，所以只能拼接出结果展示；</li><li>我试着用OCR结果中的数字4200061620去搜索，还真搜到了这张图片，这说明确实是使用OCR预处理文件后进行搜索的，估计和我们的产品逻辑大致相同</li></ul><p>  <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-41.png" alt="alt text"><br>  <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-40.png" alt="alt text"><br>  <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-53.png" alt="alt text"></p><h4 id="AI智能搜索图片"><a href="#AI智能搜索图片" class="headerlink" title="AI智能搜索图片"></a>AI智能搜索图片</h4><ul><li><p>以文搜图： 从结果来看，识别率还是不错的，前几个照片基本就是我们所需的图片，但是他范围抓的不精准，不能只给出和关键词相关的图片，总有些无关的图片跟在后面；</p><ul><li>身份证</li></ul><p> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-49.png" alt="alt text"></p><ul><li>火车票</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-12.png" alt="alt text"></p><ul><li><p>发票：</p><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-14.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-15.png" alt="alt text"></p></li><li><p>数学</p></li></ul><p> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-10.png" alt="alt text"><br> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-9.png" alt="alt text">    </p><ul><li><p>总统&#x2F;创业者</p><ul><li>如下结果说明它还是能识别出图片中的名人是谁；</li></ul><p> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-21.png" alt="alt text"><br> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-19.png" alt="alt text"><br> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-24.png" alt="alt text"><br> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-27.png" alt="alt text"></p></li></ul></li><li><p>人像识别</p><ul><li>功能如下</li></ul><p>  <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-5.png" alt="alt text"></p><ul><li><p>我存的图片<br>  <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-23.png" alt="alt text"></p></li><li><p>在人像识别结果中它只识别到了两个人，在未定义标签前他知道哪些照片是同一个人，说明它确实“认识”</p><p>  <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-52.png" alt="alt text"><br>  <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-51.png" alt="alt text"></p><ul><li><p>也可通过给人物划定标签进行精准分类</p><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-50.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-30.png" alt="alt text"></p></li></ul></li></ul></li><li><p>宠物识别</p><ul><li>我存了猫和狗各三种的图片，但它只识别出了两类猫和一类狗，可能这些种类特征比较明显吧</li></ul><p> <img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-22.png" alt="alt text"></p></li><li><p>组合关键词：“女孩抱着猫”</p><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-32.png" alt="alt text"></p></li><li><p>视频搜索</p><ul><li>一个是关于M2固态硬盘的安装视频，一个是Z4pro极空间的安装视频，移动到相册的储存位置，然后进行搜索</li><li>经过测试无结果，由于算力要求，目前暂时还无法支持视频搜索；</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-36.png" alt="alt text"></p></li><li><p>高级搜索文件</p><ul><li>无AI功能，作用类似Everything，通过字符快速寻找名称含该字符的相关文件</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-33.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-34.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-35.png" alt="alt text"></p></li></ul><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><ul><li>数据同步包含四种主流方式：手机等移动设备的同步，PC等固定设备的数据同步、云盘同步、跨网同步。<ul><li><p>手机备份：登录自己的极空间APP，第一次需要进入“手机备份”设置，后续仅需打开极空间APP或常驻后台会自动备份。</p></li><li><p>PC等固定设备的数据同步</p><ul><li>文档同步：选择目标位置和存储位置，将二者同步，有单向&#x2F;双向两种选择；</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-7.png" alt="alt text"></p></li><li><p>阿里云盘的同步速度很慢只有500kB&#x2F;s，应该是没充会员被阿里限速了；其余的传输方式速度还是很快的</p></li><li><p>跨网传输指的是如果以网址的方式访问极空间，必须处在同一局域网内，如果使用手机APP可以用数据网络或者其他WIFI都行</p></li></ul></li></ul><h3 id="数据分享"><a href="#数据分享" class="headerlink" title="数据分享"></a>数据分享</h3><ul><li>极空间的任何文件都可以通过鼠标右键以网页链接的形式分享出去</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-17.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-18.png" alt="alt text"></p><ul><li>通过文件收集，选择存储位置，可通过网页链接发送给别人收集想要的数据（可自定模版）</li></ul><p><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-42.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-47.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-45.png" alt="alt text"><br><img src="/2025/01/23/%E6%9E%81%E7%A9%BA%E9%97%B4/image-46.png" alt="alt text"></p><ul><li>参考<ul><li><a href="https://www.makeasy.work/%e6%9e%81%e7%a9%ba%e9%97%b4%e4%ba%a7%e5%93%81%e9%80%89%e8%b4%ad%e5%92%8c%e6%9e%81%e7%a9%ba%e9%97%b4z4pro%e7%89%b9%e7%82%b9%ef%bc%8c%e7%9c%8b%e8%bf%99%e7%af%87%e5%b0%b1%e5%a4%9f%e4%ba%86/2024/05/2/">https://www.makeasy.work/%e6%9e%81%e7%a9%ba%e9%97%b4%e4%ba%a7%e5%93%81%e9%80%89%e8%b4%ad%e5%92%8c%e6%9e%81%e7%a9%ba%e9%97%b4z4pro%e7%89%b9%e7%82%b9%ef%bc%8c%e7%9c%8b%e8%bf%99%e7%af%87%e5%b0%b1%e5%a4%9f%e4%ba%86/2024/05/2/</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/678389920?source_id=1005">https://www.zhihu.com/tardis/zm/art/678389920?source_id=1005</a></li><li><a href="https://post.smzdm.com/p/apmloow0/">https://post.smzdm.com/p/apmloow0/</a></li><li><a href="https://www.zhihu.com/tardis/zm/art/678389920?source_id=1005">https://www.zhihu.com/tardis/zm/art/678389920?source_id=1005</a></li><li><a href="https://www.makeasy.work/%e6%9e%81%e7%a9%ba%e9%97%b4%e4%ba%a7%e5%93%81%e9%80%89%e8%b4%ad%e5%92%8c%e6%9e%81%e7%a9%ba%e9%97%b4z4pro%e7%89%b9%e7%82%b9%ef%bc%8c%e7%9c%8b%e8%bf%99%e7%af%87%e5%b0%b1%e5%a4%9f%e4%ba%86/2024/05/#i-4">https://www.makeasy.work/%e6%9e%81%e7%a9%ba%e9%97%b4%e4%ba%a7%e5%93%81%e9%80%89%e8%b4%ad%e5%92%8c%e6%9e%81%e7%a9%ba%e9%97%b4z4pro%e7%89%b9%e7%82%b9%ef%bc%8c%e7%9c%8b%e8%bf%99%e7%af%87%e5%b0%b1%e5%a4%9f%e4%ba%86/2024/05/#i-4</a></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Test Docling</title>
    <link href="/2025/01/16/Test-Docling/"/>
    <url>/2025/01/16/Test-Docling/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试开源项目docling的功能</p></blockquote><span id="more"></span><h3 id="docling"><a href="#docling" class="headerlink" title="docling"></a>docling</h3><ul><li>仓库地址：<a href="https://github.com/DS4SD/docling">https://github.com/DS4SD/docling</a></li><li>Usage文档： <a href="https://ds4sd.github.io/docling/usage/#control-pdf-table-extraction-options">https://ds4sd.github.io/docling/usage/#control-pdf-table-extraction-options</a></li><li>特点：能读取流行的文档格式（PDF、DOCX、PPTX、XLSX、图片、HTML、AsciiDoc 和 Markdown），并导出为 HTML、Markdown 和 JSON。</li></ul><h4 id="默认的Fast模式"><a href="#默认的Fast模式" class="headerlink" title="默认的Fast模式"></a>默认的Fast模式</h4><ul><li><p>代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docling.document_converter <span class="hljs-keyword">import</span> DocumentConverter<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path<br><span class="hljs-comment"># 创建output目录(如果不存在)</span><br>output_dir = <span class="hljs-string">&quot;output&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>    os.makedirs(output_dir)<br><br>source = <span class="hljs-string">&quot;contract.docx&quot;</span>  <span class="hljs-comment"># document per local path or URL</span><br><span class="hljs-comment"># 获取源文件名(不含扩展名)</span><br>source_name = os.path.splitext(os.path.basename(source))[<span class="hljs-number">0</span>]<br><br>converter = DocumentConverter()<br>result = converter.convert(source)<br><br><span class="hljs-comment"># 构建输出文件路径</span><br>output_path = os.path.join(output_dir, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;source_name&#125;</span>.md&quot;</span>)<br><br><span class="hljs-comment"># 将转换结果写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(result.document.export_to_markdown())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;转换完成,文件已保存至: <span class="hljs-subst">&#123;output_path&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>测试效果如下：</p></li><li><p>文本</p></li></ul><p><img src="/2025/01/16/Test-Docling/image-42.png" alt="alt text"></p><ul><li>复杂图片，没有识别也没有保留；数字、括号识别很精准</li></ul><p><img src="/2025/01/16/Test-Docling/image-43.png" alt="alt text"></p><ul><li>对表格的识别很好，但对公式、指数等识别不准确；不过作者在readme的Coming soon中提交到了，未来会补充；</li></ul><p><img src="/2025/01/16/Test-Docling/image-44.png" alt="alt text"><br><img src="/2025/01/16/Test-Docling/image-45.png" alt="alt text"></p><h4 id="Accurate模式"><a href="#Accurate模式" class="headerlink" title="Accurate模式"></a>Accurate模式</h4><ul><li><p>Usage文档中描述：Since docling 1.16.0: You can control which TableFormer mode you want to use. Choose between TableFormerMode.FAST (default) and TableFormerMode.ACCURATE (better, but slower) to receive better quality with difficult table structures；即选择TableFormerMode.ACCURATE (better, but slower) 可以识别更复杂的表格结构获得更好的质量，但速度会变慢。</p></li><li><p>需要在默认的OCR引擎上添加中文支持<code>pipeline_options.ocr_options.lang = [&quot;ch_sim&quot;, &quot;en&quot;]  # example of languages for EasyOCR</code></p></li><li><p>示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docling.datamodel.base_models <span class="hljs-keyword">import</span> InputFormat<br><span class="hljs-keyword">from</span> docling.document_converter <span class="hljs-keyword">import</span> DocumentConverter, PdfFormatOption<br><span class="hljs-keyword">from</span> docling.datamodel.pipeline_options <span class="hljs-keyword">import</span> PdfPipelineOptions, TableFormerMode<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path<br>pipeline_options = PdfPipelineOptions(do_table_structure=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 开启表格结构识别</span><br>pipeline_options.table_structure_options.mode = TableFormerMode.ACCURATE  <span class="hljs-comment"># use more accurate TableFormer model</span><br>pipeline_options.ocr_options.lang = [<span class="hljs-string">&quot;ch_sim&quot;</span>, <span class="hljs-string">&quot;en&quot;</span>]  <span class="hljs-comment"># example of languages for EasyOCR</span><br>doc_converter = DocumentConverter(<br>    format_options=&#123;<br>        InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)<br>    &#125;<br>)<br><br><br><span class="hljs-comment"># 创建output目录(如果不存在)</span><br>output_dir = <span class="hljs-string">&quot;outputAccurate&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>    os.makedirs(output_dir)<br><br>source = <span class="hljs-string">&quot;test5.pdf&quot;</span>  <span class="hljs-comment"># document per local path or URL</span><br><span class="hljs-comment"># 获取源文件名(不含扩展名)</span><br>source_name = os.path.splitext(os.path.basename(source))[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 构建输出文件路径</span><br>output_path = os.path.join(output_dir, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;source_name&#125;</span>.md&quot;</span>)<br><br>result = doc_converter.convert(source)<br><br><br><br><span class="hljs-comment"># 将转换结果写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(result.document.export_to_markdown())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;转换完成,文件已保存至: <span class="hljs-subst">&#123;output_path&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure><p>如下为测试结果,以发票为例，左边为Fast模式，右边为Accurate模式;</p></li></ul><p><img src="/2025/01/16/Test-Docling/image-46.png" alt="alt text"></p><p><img src="/2025/01/16/Test-Docling/image-47.png" alt="alt text"></p><ul><li><p>可以看出来，Accurate模式识别的布局确实更细致一些，但也有更多重复的地方；</p></li><li><p>最后还有一个AI集成功能没有测完</p><ul><li><a href="https://ds4sd.github.io/docling/integrations/">https://ds4sd.github.io/docling/integrations/</a></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Test Markdownit对比MinerU</title>
    <link href="/2025/01/13/Markitdown/"/>
    <url>/2025/01/13/Markitdown/</url>
    
    <content type="html"><![CDATA[<blockquote><p>摘要</p></blockquote><span id="more"></span><h3 id="Test-Markdownit对比MinerU"><a href="#Test-Markdownit对比MinerU" class="headerlink" title="Test Markdownit对比MinerU"></a>Test Markdownit对比MinerU</h3><ul><li>开源地址：<a href="https://github.com/microsoft/markitdown">https://github.com/microsoft/markitdown</a></li></ul><h4 id="基础用法（无大模型）"><a href="#基础用法（无大模型）" class="headerlink" title="基础用法（无大模型）"></a>基础用法（无大模型）</h4><ul><li>优点：<ul><li>各种文件格式都能转成markdown</li><li>速度快，不到1s一张10页的论文pdf就被转换完成</li></ul></li><li>缺点：无法OCR、处理图片，无法处理公式<ul><li>参考如下仓库issue，作者没有进行处理<ul><li><a href="https://github.com/microsoft/markitdown/issues/255">https://github.com/microsoft/markitdown/issues/255</a></li><li><a href="https://github.com/microsoft/markitdown/issues/246">https://github.com/microsoft/markitdown/issues/246</a></li><li><a href="https://github.com/microsoft/markitdown/issues/217">https://github.com/microsoft/markitdown/issues/217</a></li><li><a href="https://github.com/microsoft/markitdown/issues/163">https://github.com/microsoft/markitdown/issues/163</a></li></ul></li></ul></li><li>举例<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> markitdown <span class="hljs-keyword">import</span> MarkItDown<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_pdf_to_md</span>(<span class="hljs-params">pdf_filename</span>):<br>    <span class="hljs-comment"># 创建output目录（如果不存在）</span><br>    output_dir = <span class="hljs-string">&quot;output&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_dir):<br>        os.makedirs(output_dir)<br><br>    md = MarkItDown()<br>    result = md.convert(pdf_filename)<br><br>    <span class="hljs-comment"># 构建输出文件路径</span><br>    output_filename = os.path.splitext(os.path.basename(pdf_filename))[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;.md&quot;</span><br>    output_path = os.path.join(output_dir, output_filename)<br><br>    <span class="hljs-comment"># 将结果写入文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(result.text_content)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果已保存到: <span class="hljs-subst">&#123;output_path&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    pdf_filename = <span class="hljs-string">&quot;demo1.pdf&quot;</span><br>    convert_pdf_to_md(pdf_filename)<br></code></pre></td></tr></table></figure><img src="/2025/01/13/Markitdown/image.png" alt="alt text"></li></ul><h4 id="使用大语言模型进行图像描述"><a href="#使用大语言模型进行图像描述" class="headerlink" title="使用大语言模型进行图像描述"></a>使用大语言模型进行图像描述</h4><ul><li>仓库的readme举例描述如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> markitdown <span class="hljs-keyword">import</span> MarkItDown<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br>client = OpenAI()<br>md = MarkItDown(llm_client=client, llm_model=<span class="hljs-string">&quot;gpt-4o&quot;</span>)<br>result = md.convert(<span class="hljs-string">&quot;example.jpg&quot;</span>)<br><span class="hljs-built_in">print</span>(result.text_content)<br><br></code></pre></td></tr></table></figure></li><li>实际运行不了；需要改成如下，并添加自己的秘钥;<ul><li>由于我没买过openAI的API，所以换成了Gemini进行尝试，结果运行出错，调查仓库issue发现此软件未对OpenAI之外的模型进行兼容处理；尽管使用OpenAI的API，也不能OCR；参考如下</li><li><a href="https://github.com/microsoft/markitdown/issues/255">https://github.com/microsoft/markitdown/issues/255</a></li><li><a href="https://github.com/microsoft/markitdown/issues/256">https://github.com/microsoft/markitdown/issues/256</a></li><li><a href="https://github.com/microsoft/markitdown/issues/232">https://github.com/microsoft/markitdown/issues/232</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> markitdown <span class="hljs-keyword">import</span> MarkItDown<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 设置 OpenAI API 密钥</span><br>api_key = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入您的 OpenAI API 密钥: &quot;</span>).strip()<br>os.environ[<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>] = api_key<br><br>client = OpenAI()<br>md = MarkItDown(llm_client=client, llm_model=<span class="hljs-string">&quot;gpt-4&quot;</span>)<br>result = md.convert(<span class="hljs-string">&quot;image1.jpg&quot;</span>)<br><span class="hljs-built_in">print</span>(result.text_content)<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Markitdown与MinerU对比"><a href="#Markitdown与MinerU对比" class="headerlink" title="Markitdown与MinerU对比"></a>Markitdown与MinerU对比</h4><ul><li>不同<ul><li>Markitdown无OCR功能、无法处理图片、无法处理公式</li><li>Markitdown速度快，不到1s一张10页的论文pdf就被转换完成;而MinerU需要7s左右（在GPU加速下）</li></ul></li><li>共同点<ul><li>Markitdown、MinerU都能将各种文件格式转成markdown，包括PDF、图片、word、excel、ppt等</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>testMinerU</title>
    <link href="/2025/01/06/testMinerU/"/>
    <url>/2025/01/06/testMinerU/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试minerU的过程与结果</p></blockquote><span id="more"></span><h3 id="minerU"><a href="#minerU" class="headerlink" title="minerU"></a>minerU</h3><ul><li><p>可本地部署的一站式开源高质量数据提取工具，将PDF转换成Markdown和JSON格式。转换成这两种格式的目的就是方便将数据提取出来更好地存储&#x2F;传递给相关大模型进行逻辑处理提高解答的准确率；（大模型都是通过markdown或json格式的数据进行训练和响应的）</p></li><li><p>首先要配置相关环境</p><ul><li>具体见 <a href="https://github.com/opendatalab/MinerU/blob/master/docs/README_Windows_CUDA_Acceleration_zh_CN.md?tab=readme-ov-file#command-line">https://github.com/opendatalab/MinerU/blob/master/docs/README_Windows_CUDA_Acceleration_zh_CN.md?tab=readme-ov-file#command-line</a></li><li>每次使用之前，先conda activate MinerU 进入环墶</li><li>GPU配置CUDA加速之后，速度明显提升好几倍，但是效果似乎没变；</li></ul></li><li><p>运行命令</p><ul><li>简单来讲主要功能：magic-pdf -p {pdf文件（夹）路径} -o {输出路径} -m {模式：ocr&#x2F;text&#x2F;auto(default)} –lang (语言：ch、en)<ul><li>提示：选择正确的语言可以显著提高识别准确率。对于混合语言文档，建议使用自动检测模式（默认）。</li></ul></li><li>比如 magic-pdf -p test.pdf -o .&#x2F;Output -m ocr –lang ch 后会在当前目录下生成一个Output文件夹，结构如下<ul><li>Output&#x2F;相应pdf文件名&#x2F;模式&#x2F;识别结果</li><li>具体意义详见：<a href="https://mineru.readthedocs.io/en/latest/user_guide/tutorial/output_file_description.html">https://mineru.readthedocs.io/en/latest/user_guide/tutorial/output_file_description.html</a><br><img src="/2025/01/06/testMinerU/image-31.png" alt="alt text"></li></ul></li><li>详见： <a href="https://mineru.readthedocs.io/en/latest/user_guide/quick_start/command_line.html">https://mineru.readthedocs.io/en/latest/user_guide/quick_start/command_line.html</a></li></ul></li><li><p>测试结果：类似于如下，排版比较简单的合同、文章等等大多是文字的图片，可以ocr识别出来提取文字；而像发票、车票等排版复杂的图片目前minerU识别不了，还是以图片的形式存在于markdown中，</p><ul><li><p>合同、文章：<br><img src="/2025/01/06/testMinerU/image-37.png" alt="alt text"><br><img src="/2025/01/06/testMinerU/image-34.png" alt="alt text"><br><img src="/2025/01/06/testMinerU/image-36.png" alt="alt text"></p></li><li><p>发票、车票</p><p><img src="/2025/01/06/testMinerU/image-38.png" alt="alt text"><br><img src="/2025/01/06/testMinerU/image-39.png" alt="alt text"></p></li></ul></li><li><p>分析原因：</p><ul><li><p>也许是没开GPU加速的原因？试试</p><ul><li>开了之后，速度确实加快了很多，之前30-40s一张pdf，现在不到15s，时长取决于内容的多少,但是发票等图片还是以图片的形式存在于markdown中</li></ul></li><li><p>谷歌之后发现github也有人提出类似的issue</p><ul><li><a href="https://github.com/opendatalab/MinerU/issues/1348">如何实现插图中的文字识别 · Issue #1348 · opendatalab&#x2F;MinerU</a></li><li><a href="https://github.com/opendatalab/MinerU/discussions/795">能不能解析图片中的文字 · opendatalab&#x2F;MinerU · Discussion #795</a></li><li><a href="https://github.com/opendatalab/MinerU/issues/1392">图表 ·问题 #1392 ·开放数据实验室&#x2F;MinerU — Charting · Issue #1392 · opendatalab&#x2F;MinerU</a></li></ul></li><li><p>查看项目readme.md文档</p><ul><li>作者已在Known Issues 说明 some uncommon list formats may not be recognized.<ul><li><a href="https://github.com/opendatalab/MinerU?tab=readme-ov-file#known-issues">https://github.com/opendatalab/MinerU?tab=readme-ov-file#known-issues</a></li></ul></li></ul></li><li><p>尝试解决办法</p><ul><li>不用命令行，改用python代码进行调用强制开启OCR<ul><li>结果：无用</li></ul></li><li>通过paddle去识别那些minerU识别不了的内容<ul><li><a href="https://github.com/PaddlePaddle/PaddleOCR">https://github.com/PaddlePaddle/PaddleOCR</a></li></ul></li><li>我已提交issue，等待作者和大佬们升级项目<ul><li><a href="https://github.com/opendatalab/MinerU/issues/1415">https://github.com/opendatalab/MinerU/issues/1415</a></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>testOCR</title>
    <link href="/2025/01/02/testOCR/"/>
    <url>/2025/01/02/testOCR/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试两款开源OCR工具以及百度飞桨在线产品PP-OCRv4的识别效果</p></blockquote><span id="more"></span><ul><li><p>先说结论：百度的飞桨在线产品<a href="https://aistudio.baidu.com/community/app/91660/webUI">PP-OCRv4</a> 对文字、数字、排版的识别都很不错；开源paddleOCR和Umi-OCR对文字、数字的识别效果都还可以，但是对排版的识别及其导致的输出顺序效果都不太好，二者差不多，相同与不同如下；</p></li><li><p>相同点：</p><ul><li>都可批量OCR</li><li>对文本、数字等等效果比较好，但对布局格式识别、输出顺序不太行。</li><li>对图片、pdf等文件都可以识别</li></ul></li><li><p>不同之处</p><ul><li>Umi-OCR通过应用程序鼠标点击进行操作</li><li>PaddleOCR通过命令行&#x2F;python进行操作,输出结果中含有置信度</li><li>Umi-OCR可识别二维码</li></ul></li><li><p>如下是测试过程：</p></li></ul><h3 id="Umi-OCR"><a href="#Umi-OCR" class="headerlink" title="Umi-OCR"></a><a href="https://github.com/hiroi-sora/Umi-OCR">Umi-OCR</a></h3><ul><li>设置规则<ul><li>多栏：自动识别多栏布局输出</li><li>单栏：不识别布局，从上往下按照一行行的顺序识别和输出</li></ul></li></ul><p><img src="/2025/01/02/testOCR/image-15.png" alt="alt text"></p><h4 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h4><ul><li>效果很好，连格式几乎都一样，除了有些缩进和换行被忽略了；<br><img src="/2025/01/02/testOCR/image-7.png" alt="alt text"></li></ul><h4 id="发票1"><a href="#发票1" class="headerlink" title="发票1"></a>发票1</h4><p><img src="/2025/01/02/testOCR/image-13.png" alt="alt text"></p><ul><li>多栏-按自然段换行：最上面盖章处，识别有少许偏差，上面中间部分一行行识别和输出效果还可以，下面列与列之间间隙较大，就变成了一列列识别和输出，键与值之间错位，不方便对应；最右下角可能是光线不好，没识别出来；</li></ul><p><img src="/2025/01/02/testOCR/image-14.png" alt="alt text"></p><ul><li>多栏，总是换行：识别效果和顺序和上方差不多，但每识别一段就换行；</li></ul><p><img src="/2025/01/02/testOCR/image-16.png" alt="alt text"></p><ul><li>单栏：自然换行：从上往下按照一行行的顺序识别和输出，但是遇到一些格式不一样的一起识别就会出现顺序问题</li></ul><p><img src="/2025/01/02/testOCR/image-17.png" alt="alt text"></p><h4 id="发票2"><a href="#发票2" class="headerlink" title="发票2"></a>发票2</h4><p><img src="/2025/01/02/testOCR/image-10.png" alt="alt text"></p><ul><li>多栏-按自然段换行：尽管除了少数和印章重叠的字识别有误之外（蓝色圈出），文字和数字都识别出来了，但是识别和输出格式和输出顺序很糟糕，整体上也是从左向右一列列识别和输出，但他并不是以每列相同的宽度去读取的，像圈1和圈4所在列就比较规则，所以它也能准确读出来，但有些列的宽度并不能包含相应格式的数据保证他们的连贯性；（如图中圈3）</li></ul><p><img src="/2025/01/02/testOCR/image-12.png" alt="alt text"></p><ul><li>单栏：自然换行 ：从上往下按照一行行的顺序识别和输出，语意不连贯，键值不对应，盖章文字未识别出；</li></ul><p><img src="/2025/01/02/testOCR/image-18.png" alt="alt text"></p><ul><li>总结：对纯文本效果比较好，但对布局格式识别不太行；</li></ul><h3 id="开源PaddleOCR"><a href="#开源PaddleOCR" class="headerlink" title="开源PaddleOCR"></a><a href="https://paddlepaddle.github.io/PaddleOCR/latest/ppocr/quick_start.html#3">开源PaddleOCR</a></h3><h4 id="纯文本-1"><a href="#纯文本-1" class="headerlink" title="纯文本"></a>纯文本</h4><p><img src="/2025/01/02/testOCR/image-27.png" alt="alt text"><br><img src="/2025/01/02/testOCR/image-29.png" alt="alt text"></p><h4 id="发票1-1"><a href="#发票1-1" class="headerlink" title="发票1"></a>发票1</h4><p><img src="/2025/01/02/testOCR/image-21.png" alt="alt text"></p><h4 id="发票2-1"><a href="#发票2-1" class="headerlink" title="发票2"></a>发票2</h4><p><img src="/2025/01/02/testOCR/image-28.png" alt="alt text"></p><ul><li>总结：和前者效果差不多：对纯文本效果比较好，但对布局格式识别不太行；</li></ul><h3 id="PP-OCRv4-在线"><a href="#PP-OCRv4-在线" class="headerlink" title="PP-OCRv4 在线"></a><a href="https://aistudio.baidu.com/community/app/91660/webUI">PP-OCRv4 在线</a></h3><ul><li>对文本、数字、布局、排版格式等等识别的都很好；唯一缺点就是印章重叠处的文字识别不太精准；</li></ul><h4 id="纯文本-2"><a href="#纯文本-2" class="headerlink" title="纯文本"></a>纯文本</h4><p><img src="/2025/01/02/testOCR/image-23.png" alt="alt text"></p><h4 id="发票"><a href="#发票" class="headerlink" title="发票"></a>发票</h4><p><img src="/2025/01/02/testOCR/image-22.png" alt="alt text"><br><img src="/2025/01/02/testOCR/image-24.png" alt="alt text"><br><img src="/2025/01/02/testOCR/image-30.png" alt="alt text"></p>]]></content>
    
    
    
    <tags>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署项目</title>
    <link href="/2024/11/15/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/11/15/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述如何使用Vercel部署前端项目</p></blockquote><span id="more"></span><h2 id="上线前端静态项目"><a href="#上线前端静态项目" class="headerlink" title="上线前端静态项目"></a>上线前端静态项目</h2><h4 id="vercel"><a href="#vercel" class="headerlink" title="vercel"></a>vercel</h4><ol><li>登录<a href="https://vercel.com/new">https://vercel.com/new</a> 注册账号（需要绑定手机号输入验证码）并绑定github</li><li>将项目上传到github上，不要上传依赖node_modules，在 Vercel 部署项目时会自动安装项目依赖、执行构建命令，并将构建结果上传到其服务器。</li><li>在vercel中new project，导入相应的仓库，然后vercel会自动识别框架，你只需要点击下一步和deploy即可部署成功</li><li>部署成功后可在vercel中看到项目的域名，状态等信息<ol><li>默认域名格式：项目名-github账号名-projects.vercel.app</li></ol></li><li>在 Vercel 的控制面板中，可以管理项目，包括查看日志、配置环境变量、设置 HTTPS 等，还可以将自定义域名绑定到 Vercel 项目。</li><li>如果想修改项目，直接本地修改代码然后上传到github即可</li><li>最大的问题就是域名vercel.app在国内背墙了，无法访问，解决办法有如下两种<ol><li>换一个国内可以访问的域名然后通过进行cloudflare解析。<ul><li>如果是使用国内的域名需要Cloudflare解析海外的服务器，因为国内的阿里云腾讯云免费DNS不支持直接解析海外服务器,步骤如下：<ol><li>注册 Cloudfare</li><li>把自己购买的域名添加到cloudfare，然后选择免费计划。</li><li>点进该域名的配置面板，增加 DNS 配置。（76.223.126.88 是 vercel 贴心为墙内用户准备的 IP。添加@记录后，保存后显示的是你的域名.）</li><li>把cloudflare名称服务器下的两行代码，直接复制粘贴到你所购买域名平台相应的DNS管理中修改，将域名的DNS解析服务转移到Cloudflare;需要稍等一会（记住DNS的相关操作是具有迟缓性的，也许半个小时甚至更久才能起作用，不要心急）</li><li>转移需要一些时间，等邮箱通知激活成功；</li></ol></li></ul></li><li>github学生包还有很多权益，其中就包括很多免费的域名，全球可访；</li></ol></li></ol><h4 id="利用github学生包免费获得https-get-tech-的-tech域名"><a href="#利用github学生包免费获得https-get-tech-的-tech域名" class="headerlink" title="利用github学生包免费获得https://get.tech 的.tech域名"></a>利用github学生包免费获得<a href="https://get.tech/">https://get.tech</a> 的.tech域名</h4><ol><li>进入官网，选择一个域名mylsz.tech，然后绑定github,价格会变成0元，购买；时效1年</li><li>购买前需要注册账号<ol><li>谷歌账号、</li><li>范式：tech</li></ol></li><li>namecheap可以直接在其中进行域名解析绑定服务器，此网站也可以，不过它是通过邮箱的方式告诉你地址（刚开始我还纳闷为什么一个卖域名的网站居然没有解析服务）<ol><li>.tech是在全球可访问的，无需使用cloudflare，直接通过<a href="https://controlpanel.tech/servlet/ViewDomainServlet?orderid=116516920&referrerkey=MmNvTVlSTzYvWEZMUzRLRTJLdHdJczM3cTVtc3NyT1lnWWpiaEhsWW9nbzRvQXE5L1gxTllYR0QxRk1rVHJsV3V1VjdiOUZ2Wk5nPQ==#domorder">此链接</a> 管理DNS解析域名：76.223.126.88  是 vercel 贴心为墙内用户准备的 IP（不要用vercel控制台提供的76.76.21.21，这个国内访问不了）。添加A记录后，DNS缓存需要稍等一会</li></ol></li></ol><ul><li>参考<ul><li><a href="https://www.nbmao.com/archives/6702">https://www.nbmao.com/archives/6702</a></li><li><a href="https://blog.csdn.net/ll_renlong/article/details/141395626">https://blog.csdn.net/ll_renlong/article/details/141395626</a></li><li><a href="https://juejin.cn/post/7383894687302434825#heading-5">https://juejin.cn/post/7383894687302434825#heading-5</a></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MJ</title>
    <link href="/2024/10/25/MJ/"/>
    <url>/2024/10/25/MJ/</url>
    
    <content type="html"><![CDATA[<h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="Vue常考八股"><a href="#Vue常考八股" class="headerlink" title="Vue常考八股"></a>Vue常考八股</h3><p>好的，下面是一些常见的 Vue 面试问题及答案，涵盖了 Vue 的基础知识、核心概念、高级特性以及生态系统：</p><p><strong>基础知识</strong></p><ol><li><p><strong>Vue.js 是什么？它有什么特点？</strong></p><ul><li>Vue.js 是一套用于构建用户界面的渐进式框架。</li><li>特点：<ul><li><strong>易用性</strong>：易于学习和使用，只需要基本的 HTML、CSS 和 JavaScript 知识。</li><li><strong>灵活性</strong>：可以作为库引入，也可以构建复杂的单页应用。</li><li><strong>高效性</strong>：虚拟 DOM 和响应式系统使得性能优化更容易。</li><li><strong>组件化</strong>：将 UI 划分为可复用的组件，提高代码的可维护性和可重用性。</li><li><strong>生态系统</strong>：拥有丰富的官方和社区插件，如 Vue Router、Vuex、Vue CLI 等。</li></ul></li></ul></li><li><p><strong>Vue 的双向数据绑定是如何实现的？</strong></p><ul><li>Vue 2 使用 Object.defineProperty() 的 getter 和 setter 来劫持数据的变化，结合发布-订阅模式实现双向数据绑定。</li><li>Vue 3 使用 Proxy 对象来代理数据的变化，更加高效和灵活。</li><li>原理：<ul><li><strong>数据劫持（Observer）</strong>：监听数据的变化。</li><li><strong>依赖收集（Dep）</strong>：收集依赖（Watcher）。</li><li><strong>发布-订阅模式（Watcher）</strong>：当数据变化时，通知相应的 Watcher 更新视图。</li></ul></li></ul></li><li><p><strong>v-if 和 v-show 的区别？</strong></p><ul><li><code>v-if</code>：<ul><li>条件渲染，当条件为 false 时，元素不会被渲染到 DOM 中（销毁&#x2F;创建）。</li><li>适用于切换频率较低的场景。</li></ul></li><li><code>v-show</code>：<ul><li>通过 CSS 的 <code>display</code> 属性控制元素的显示和隐藏，元素始终存在于 DOM 中。</li><li>适用于切换频率较高的场景。</li></ul></li></ul></li><li><p><strong>Vue 中 key 的作用是什么？</strong></p><ul><li><code>key</code> 是 Vue 中用于标识列表中的元素的唯一属性。</li><li>作用：<ul><li><strong>高效更新虚拟 DOM</strong>：当列表数据变化时，Vue 可以根据 <code>key</code> 来判断哪些元素需要更新、删除或创建，提高渲染效率。</li><li><strong>避免复用错误</strong>：如果没有 <code>key</code>，Vue 可能会复用错误的元素，导致显示异常。</li></ul></li><li>建议：<ul><li><code>key</code> 应该是唯一的、稳定的值。</li><li>尽量不要使用数组的索引作为 <code>key</code>，除非列表是静态的。</li></ul></li></ul></li><li><p><strong>computed 和 watch 的区别？</strong></p><ul><li><strong>computed</strong>：<ul><li>计算属性，基于响应式依赖进行缓存，只有当依赖变化时才会重新计算。</li><li>适用于需要根据其他数据计算得出新数据的场景。</li><li>具有getter和setter。</li></ul></li><li><strong>watch</strong>：<ul><li>侦听器，监听一个数据的变化，并在数据变化时执行回调函数。</li><li>适用于需要在数据变化时执行异步操作或复杂逻辑的场景。</li></ul></li></ul></li></ol><p><strong>核心概念</strong></p><ol><li><p><strong>Vue 的生命周期钩子有哪些？它们分别在什么时候执行？</strong></p><ul><li><strong>beforeCreate</strong>：实例初始化之后，数据观测和事件配置之前。</li><li><strong>created</strong>：实例创建完成，数据观测和事件配置已完成，但 DOM 尚未渲染。</li><li><strong>beforeMount</strong>：在挂载开始之前被调用，相关的 render 函数首次被调用。</li><li><strong>mounted</strong>：实例挂载到 DOM 后调用，可以访问到 DOM。</li><li><strong>beforeUpdate</strong>：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li><li><strong>updated</strong>：数据更新后调用，发生在虚拟 DOM 重新渲染和打补丁之后。</li><li><strong>beforeDestroy</strong>：实例销毁之前调用，可以执行一些清理操作。</li><li><strong>destroyed</strong>：实例销毁后调用，所有的数据绑定和事件监听器都被移除。</li><li><strong>activated</strong> (keep-alive): 被 keep-alive 包裹的组件激活时调用。</li><li><strong>deactivated</strong> (keep-alive): 被 keep-alive 包裹的组件失活时调用。</li><li><strong>errorCaptured</strong>：(2.5.0+)当捕获一个来自子孙组件的错误时被调用</li></ul></li><li><p><strong>Vue 组件之间的通信方式有哪些？</strong></p><ul><li><p><strong>父子组件</strong>：</p><ul><li><code>props</code>：父组件向子组件传递数据。</li><li><code>$emit</code>：子组件向父组件触发事件。</li><li><code>$refs</code>：父组件直接访问子组件的实例。</li><li><code>$parent</code> &#x2F; <code>$children</code>: 访问父组件&#x2F;子组件的实例（不推荐）。</li></ul></li><li><p><strong>兄弟组件</strong>：</p><ul><li>事件总线（Event Bus）：创建一个空的 Vue 实例作为中央事件总线，通过 <code>$emit</code> 触发事件，<code>$on</code> 监听事件。</li><li>Vuex：状态管理模式。</li></ul></li><li><p><strong>跨级组件</strong>：</p><ul><li><code>provide</code> &#x2F; <code>inject</code>：祖先组件提供数据，后代组件注入数据。</li><li>Vuex。</li></ul></li></ul></li><li><p><strong>Vuex 是什么？它的核心概念有哪些？</strong></p><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</li><li>核心概念：<ul><li><strong>State</strong>：单一状态树，存储应用的所有状态。</li><li><strong>Getters</strong>：从 State 中派生出一些状态，类似于计算属性。</li><li><strong>Mutations</strong>：同步修改 State 的方法，必须是同步函数。</li><li><strong>Actions</strong>：提交 Mutations，可以包含异步操作。</li><li><strong>Modules</strong>：将 Store 分割成模块，每个模块拥有自己的 State、Getters、Mutations、Actions。</li></ul></li></ul></li><li><p><strong>Vue Router是什么， 模式有几种，区别是什么？</strong></p><ul><li>Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让构建单页面应用变得非常简单。</li><li>模式：<ul><li>hash: 使用 URL hash 值来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</li><li>history: 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，需要后台配置支持。</li><li>abstract：支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul></li></ul></li></ol><p><strong>高级特性</strong></p><ol><li><p><strong>Vue 的自定义指令如何使用？</strong></p><ul><li>通过 <code>Vue.directive</code> 或在组件中使用 <code>directives</code> 选项定义自定义指令。</li><li>自定义指令可以操作 DOM，实现一些特殊的功能。</li><li>常用钩子函数：<ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。</li><li><code>inserted</code>：被绑定元素插入父节点时调用。</li><li><code>update</code>：所在组件的 VNode 更新时调用。</li><li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul></li></ul></li><li><p><strong>Vue 的 mixin 如何使用？</strong></p><ul><li>Mixin 是一种分发 Vue 组件中可复用功能的灵活方式。</li><li>Mixin 对象可以包含任何组件选项。</li><li>当组件使用 Mixin 时，Mixin 对象中的所有选项将被“混合”到组件自身的选项中。</li><li>注意：<ul><li>如果有同名选项，组件选项会覆盖 Mixin 选项。</li><li>生命周期钩子会合并成一个数组，先执行 Mixin 中的钩子，再执行组件中的钩子。</li></ul></li></ul></li><li><p><strong>Vue 的 keep-alive 组件有什么作用？</strong></p><ul><li><code>&lt;keep-alive&gt;</code> 可以缓存不活动的组件实例，而不是销毁它们。</li><li>作用：<ul><li><strong>性能优化</strong>：避免重复渲染相同的组件，提高性能。</li><li><strong>状态保持</strong>：保留组件的状态，避免用户操作丢失。</li><li>常用于标签页的切换。</li></ul></li></ul></li></ol><p><strong>Vue 3 相关</strong></p><ol><li><p><strong>Vue 3 有哪些新特性？</strong></p><ul><li><strong>Composition API</strong>：一种新的组织代码的方式，可以更好地处理大型组件的逻辑复用和可读性。</li><li><strong>Proxy 响应式系统</strong>：性能更好，支持更多的数据类型（如 Map、Set）。</li><li><strong>更小的包体积</strong>：通过 tree-shaking 移除未使用的代码。</li><li><strong>更好的 TypeScript 支持</strong>。</li><li><strong>Teleport</strong>：可以将组件的内容渲染到 DOM 树的任何位置。</li><li><strong>Fragments</strong>：组件可以有多个根节点。</li><li><strong>Suspense</strong>: 允许我们的组件在等待异步操作时渲染一些备用内容</li></ul></li><li><p><strong>Composition API 和 Options API 的区别？</strong></p><ul><li><p><strong>Options API</strong>：</p><ul><li>基于选项（data、methods、computed、watch 等）来组织代码。</li><li>对于小型组件来说比较清晰，但对于大型组件来说可能会变得难以维护。</li></ul></li><li><p><strong>Composition API</strong>：</p><ul><li>基于函数来组织代码，将相关的逻辑放在一起。</li><li>可以更好地处理大型组件的逻辑复用和可读性。</li><li>更灵活，可以更好地利用 JavaScript 的特性。</li></ul></li></ul></li></ol><p><strong>其他</strong></p><ol><li><p><strong>如何优化 Vue 应用的性能？</strong></p><ul><li><strong>代码层面</strong>：<ul><li>合理使用 <code>v-if</code> 和 <code>v-show</code>。</li><li>为列表项添加唯一的 <code>key</code>。</li><li>使用 computed 缓存计算结果。</li><li>使用 keep-alive 缓存组件。</li><li>使用异步组件。</li><li>使用函数式组件。</li><li>事件销毁</li><li>图片懒加载</li><li>第三方插件按需引入</li><li>适当采用长列表技术，如只渲染可是区域</li></ul></li><li><strong>Webpack 层面</strong>：<ul><li>代码分割（Code Splitting）。</li><li>Tree Shaking。</li><li>使用 CDN 加速。</li></ul></li></ul></li></ol><p>这只是一些常见的 Vue 面试问题，实际面试中可能会根据你的经验和项目经历进行更深入的提问。建议你在准备面试时，结合自己的实际情况，深入理解 Vue 的原理和最佳实践。</p><h3 id="一、块级元素和行内元素"><a href="#一、块级元素和行内元素" class="headerlink" title="一、块级元素和行内元素"></a>一、块级元素和行内元素</h3><h4 id="1-定义与区别"><a href="#1-定义与区别" class="headerlink" title="1. 定义与区别"></a>1. <strong>定义与区别</strong></h4><ul><li><strong>块级元素</strong>：独占一行，默认宽度撑满父容器，可以设置宽高、内外边距。<strong>常见标签</strong>：<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;~&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;figure&gt;</code>、<code>nav</code>、<code>form</code>。</li><li><strong>行内元素</strong>：不换行，默认宽高由内容决定，<strong>无法直接设置宽高</strong>。<br><strong>常见标签</strong>：<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;button&gt;</code>。其中 <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;button&gt;</code>、<code>textarea</code>、<code>select</code>、<code>Video</code>作为可替换元素比较特殊，可以设置宽高。</li></ul><h4 id="2-行内元素如何定义宽高？"><a href="#2-行内元素如何定义宽高？" class="headerlink" title="2. 行内元素如何定义宽高？"></a>2. <strong>行内元素如何定义宽高？</strong></h4><ul><li><strong>方法</strong>：<ol><li>转换为块级元素：<code>display: block</code> 或 <code>display: inline-block</code>。<ol><li>它们的区别：<ul><li><code>display: block</code>：独占一行，默认宽度撑满父容器，可以设置宽高、内外边距。</li><li><code>display: inline-block</code>：不换行，默认宽高由内容决定，<strong>可以设置宽高、内外边距</strong>。</li></ul></li></ol></li><li>使用 CSS 属性：如 <code>transform: scale()</code>（不改变布局流）。</li><li>某些行内替换元素（如 <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>）天然支持宽高设置。</li></ol></li></ul><hr><h3 id="二、语义化标签"><a href="#二、语义化标签" class="headerlink" title="二、语义化标签"></a>二、语义化标签</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h4><p>通过 HTML 标签的命名（如 <code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code>）直接表达内容的结构和意义，而非仅用 <code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code>。</p><h4 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. <strong>优点</strong></h4><ul><li><strong>SEO 友好</strong>：搜索引擎更容易理解页面结构。</li><li><strong>可访问性</strong>：屏幕阅读器能更准确地解析内容。</li><li><strong>代码可维护性</strong>：结构清晰，便于团队协作。</li></ul><h4 id="3-常见标签"><a href="#3-常见标签" class="headerlink" title="3. 常见标签"></a>3. <strong>常见标签</strong></h4><p><code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;figure&gt;</code>。</p><hr><h3 id="三、iframe"><a href="#三、iframe" class="headerlink" title="三、iframe"></a>三、iframe</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h4><p>用于在当前页面中嵌入另一个独立的 HTML 文档（如地图、广告等）。</p><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. <strong>特点</strong></h4><ul><li><strong>独立上下文</strong>：内部样式和脚本与父页面隔离。</li><li><strong>性能问题</strong>：加载子页面可能阻塞父页面，增加内存消耗。</li><li><strong>现代替代</strong>：微前端或组件化开发（如 Web Components）。</li></ul><hr><h3 id="事件绑定和阻止冒泡：事件在-DOM-中有三个阶段：捕获阶段（自上而下）、目标阶段、冒泡阶段（自下而上）。"><a href="#事件绑定和阻止冒泡：事件在-DOM-中有三个阶段：捕获阶段（自上而下）、目标阶段、冒泡阶段（自下而上）。" class="headerlink" title="事件绑定和阻止冒泡：事件在 DOM 中有三个阶段：捕获阶段（自上而下）、目标阶段、冒泡阶段（自下而上）。"></a>事件绑定和阻止冒泡：事件在 DOM 中有三个阶段：捕获阶段（自上而下）、目标阶段、冒泡阶段（自下而上）。</h3><ol><li>事件绑定：<ol><li>选中元素：document.getElementById(‘element’)或者document.querySelector(‘#element’)</li><li>绑定事件：element.addEventListener(‘click’, handler);</li></ol></li><li>阻止冒泡：stopPropagation() 阻止事件继续传播，preventDefault() 阻止默认行为（比如点击链接跳转）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 绑定事件</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler);<br><span class="hljs-comment">// 取消绑定</span><br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handler);<br><br><span class="hljs-comment">// 阻止冒泡</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">event</span>) &#123;<br>    event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止冒泡</span><br>    event.<span class="hljs-title function_">preventDefault</span>();  <span class="hljs-comment">// 阻止默认行为</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="四、CSS-选择器"><a href="#四、CSS-选择器" class="headerlink" title="四、CSS 选择器"></a>四、CSS 选择器</h3><h4 id="1-常见类型"><a href="#1-常见类型" class="headerlink" title="1. 常见类型"></a>1. <strong>常见类型</strong></h4><ul><li><strong>基础选择器</strong>：<code>#id</code>（id选择器）、<code>.class</code>（类选择器）、<code>tag</code>（标签选择器）、<code>*</code>（通配符选择器）。</li><li><strong>组合选择器</strong>：<code>div p</code>（后代选择器）、<code>div &gt; p</code>（直接子元素选择器）、<code>div + p</code>（相邻兄弟选择器）。</li><li><strong>属性选择器</strong>：<code>[type=&quot;text&quot;]</code>（属性选择器）。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;prefix&quot;</span>]</span> &#123; &#125; <span class="hljs-comment">/* 以prefix开头 */</span><br><span class="hljs-selector-attr">[class$=<span class="hljs-string">&quot;suffix&quot;</span>]</span> &#123; &#125; <span class="hljs-comment">/* 以suffix结尾 */</span><br><span class="hljs-selector-attr">[class*=<span class="hljs-string">&quot;contain&quot;</span>]</span> &#123; &#125; <span class="hljs-comment">/* 包含contain */</span><br></code></pre></td></tr></table></figure></li><li><strong>伪类</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 状态伪类 */</span><br><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br><span class="hljs-selector-pseudo">:active</span> &#123; &#125;<br><span class="hljs-selector-pseudo">:focus</span> &#123; &#125;<br><span class="hljs-selector-pseudo">:visited</span> &#123; &#125;<br><br><span class="hljs-comment">/* 结构伪类 */</span><br><span class="hljs-selector-pseudo">:first-child</span> &#123; &#125;<br><span class="hljs-selector-pseudo">:last-child</span> &#123; &#125;<br><span class="hljs-selector-pseudo">:nth-child</span>(n) &#123; &#125;<br><span class="hljs-selector-pseudo">:nth-of-type</span>(n) &#123; &#125;<br><span class="hljs-selector-pseudo">:not</span>() &#123; &#125;<br></code></pre></td></tr></table></figure></li><li><strong>伪元素</strong>：<code>::before</code>（伪元素）。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 使用双冒号 */</span><br>  <span class="hljs-selector-pseudo">::before</span> &#123; &#125;用于在选定元素的内容之前插入内容。它创建一个虚拟的元素，这个元素不会出现在DOM树中，但可以通过CSS进行样式设置。比如<span class="hljs-selector-tag">li</span>前面的点<br>  <span class="hljs-selector-pseudo">::after</span> &#123; &#125;用于在选定元素的内容之后插入内容。它创建一个虚拟的元素，这个元素不会出现在DOM树中，但可以通过CSS进行样式设置。比如<span class="hljs-selector-tag">li</span>后面的点<br>  <span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;用于选择元素的第一行文本。<br>  <span class="hljs-selector-pseudo">::first-letter</span> &#123; &#125;用于选择元素的第一行文本。<br>  <span class="hljs-selector-pseudo">::selection</span> &#123; &#125;用于选择用户选择的文本。<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-amp-gt-就是"><a href="#2-amp-gt-就是" class="headerlink" title="2. &amp;amp;gt;就是 &gt;"></a>2. <code>&amp;amp;gt;</code>就是 <code>&gt;</code></h4><p>子元素选择器，仅匹配直接子元素。<br><strong>示例</strong>：<code>.parent &gt; .child</code> 仅选择 <code>.parent</code> 下一级的 <code>.child</code>。</p><hr><h3 id="五、水平垂直居中"><a href="#五、水平垂直居中" class="headerlink" title="五、水平垂直居中"></a>五、水平垂直居中</h3><h4 id="1-Flex-布局"><a href="#1-Flex-布局" class="headerlink" title="1. Flex 布局"></a>1. <strong>Flex 布局</strong></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-行内元素居中"><a href="#4-行内元素居中" class="headerlink" title="4. 行内元素居中"></a>4. <strong>行内元素居中</strong></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center; <span class="hljs-comment">/* 水平 */</span><br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 垂直（需固定高度） */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-绝对定位-Transform"><a href="#3-绝对定位-Transform" class="headerlink" title="3. 绝对定位 + Transform"></a>3. <strong>绝对定位 + Transform</strong></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Grid-布局"><a href="#2-Grid-布局" class="headerlink" title="2. Grid 布局"></a>2. <strong>Grid 布局</strong></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  place-items: center;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="CSS-选择器权重"><a href="#CSS-选择器权重" class="headerlink" title="CSS 选择器权重"></a>CSS 选择器权重</h3><p>让我以面试的方式回答 CSS 选择器权重的问题：</p><p>CSS 选择器权重从高到低排序如下：</p><ol><li><p><strong>!important</strong> (权重值：∞)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;  <span class="hljs-comment">/* 最高优先级 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>行内样式</strong> (权重值：1000)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 直接写在标签上的样式 --&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>ID选择器</strong> (权重值：100)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#header</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>类选择器、属性选择器、伪类</strong> (权重值：10)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123; &#125;          <span class="hljs-comment">/* 类选择器 */</span><br><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span> &#123; &#125;      <span class="hljs-comment">/* 属性选择器 */</span><br><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;             <span class="hljs-comment">/* 伪类 */</span><br></code></pre></td></tr></table></figure></li><li><p><strong>标签选择器、伪元素</strong> (权重值：1)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123; &#125;                <span class="hljs-comment">/* 标签选择器 */</span><br><span class="hljs-selector-pseudo">::before</span> &#123; &#125;          <span class="hljs-comment">/* 伪元素 */</span><br></code></pre></td></tr></table></figure></li><li><p><strong>通配符、关系选择器</strong> (权重值：0)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123; &#125;                  <span class="hljs-comment">/* 通配符 */</span><br>&gt; &#123; &#125;                  <span class="hljs-comment">/* 子选择器 */</span><br>+ &#123; &#125;                  <span class="hljs-comment">/* 相邻选择器 */</span><br></code></pre></td></tr></table></figure></li></ol><p>面试要点：</p><ol><li><p><strong>权重值不进位</strong>：</p><ul><li>11个类选择器 (110) 也不会超过 1个ID选择器 (100)</li><li>这不是一个十进制的计数系统</li></ul></li><li><p><strong>继承的权重最低</strong>：</p><ul><li>继承的样式优先级最低，即使是从 ID 选择器继承来的样式</li></ul></li><li><p><strong>相同权重的情况</strong>：</p><ul><li>后面的样式会覆盖前面的样式（就近原则）</li><li>外部样式表和内部样式表权重相同时，后加载的优先</li></ul></li><li><p><strong>通配符的特殊性</strong>：</p><ul><li><code>*</code> 的权重为 0，但比继承的样式优先级高</li></ul></li><li><p><strong>权重叠加</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 两个类选择器叠加 (20) 会大于一个类选择器 (10) */</span><br><span class="hljs-selector-class">.header</span><span class="hljs-selector-class">.active</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>在实际开发中的建议：</p><ol><li>避免过度使用 <code>!important</code></li><li>避免过长的选择器链</li><li>合理使用类选择器，降低选择器的耦合度</li><li>遵循 BEM 等命名规范，减少选择器权重混乱</li><li>使用 CSS Modules 或 CSS-in-JS 等方案来避免全局样式冲突</li></ol><h3 id="六、回流（Reflow）与重绘（Repaint）"><a href="#六、回流（Reflow）与重绘（Repaint）" class="headerlink" title="六、回流（Reflow）与重绘（Repaint）"></a>六、回流（Reflow）与重绘（Repaint）</h3><h4 id="1-回流"><a href="#1-回流" class="headerlink" title="1. 回流"></a>1. <strong>回流</strong></h4><ul><li><strong>触发条件</strong>：修改布局属性（如宽高、位置、DOM 结构）。</li><li><strong>性能消耗高</strong>：需重新计算元素几何信息。</li></ul><h4 id="2-重绘"><a href="#2-重绘" class="headerlink" title="2. 重绘"></a>2. <strong>重绘</strong></h4><ul><li><strong>触发条件</strong>：修改样式但不影响布局（如颜色、背景）。</li><li><strong>性能消耗低</strong>：无需重新计算布局。</li></ul><h4 id="3-优化建议"><a href="#3-优化建议" class="headerlink" title="3. 优化建议"></a>3. <strong>优化建议</strong></h4><ul><li>避免频繁操作 DOM（使用 <code>DocumentFragment</code> 或虚拟 DOM）。</li><li>使用 CSS3 动画（<code>transform</code>、<code>opacity</code> 触发 GPU 加速）。</li><li>批量修改样式（通过 <code>class</code> 或 <code>requestAnimationFrame</code>）。</li></ul><hr><hr><h3 id="Cookie、LocalStorage、SessionStorage"><a href="#Cookie、LocalStorage、SessionStorage" class="headerlink" title="Cookie、LocalStorage、SessionStorage"></a>Cookie、LocalStorage、SessionStorage</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是存储在浏览器中的小型文本文件。</p><p><strong>特点：</strong></p><ol><li>容量小：约4KB</li><li>每次请求都会自动携带</li><li>可设置过期时间</li><li>可设置域名和路径</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置Cookie</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;username=张三; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/&quot;</span>;<br><br><span class="hljs-comment">// 读取Cookie</span><br><span class="hljs-keyword">const</span> cookies = <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;<br><br><span class="hljs-comment">// 删除Cookie（设置过期时间为过去的时间）</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>永久性的本地存储，除非手动删除，否则数据永远不会过期。</p><p><strong>特点：</strong></p><ol><li>容量大：约5MB</li><li>永久存储</li><li>不会随请求发送到服务器</li><li>同源策略限制</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;));<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-keyword">const</span> user = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>));<br><br><span class="hljs-comment">// 删除特定数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>);<br><br><span class="hljs-comment">// 清空所有数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><h3 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h3><p>会话级别的存储，关闭标签页或浏览器后数据就会清除。</p><p><strong>特点：</strong></p><ol><li>容量大：约5MB</li><li>会话期间有效</li><li>不会随请求发送到服务器</li><li>同源策略限制</li><li>标签页隔离</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;currentPage&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-keyword">const</span> currentPage = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;currentPage&#x27;</span>);<br><br><span class="hljs-comment">// 删除特定数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;currentPage&#x27;</span>);<br><br><span class="hljs-comment">// 清空所有数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>Cookie适用于：</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 用户身份验证</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;token=abc123; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/&quot;</span>;<br><br><span class="hljs-comment">// 记住用户偏好</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;theme=dark; path=/&quot;</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>LocalStorage适用于：</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储用户设置</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;settings&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>    <span class="hljs-attr">theme</span>: <span class="hljs-string">&#x27;dark&#x27;</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>,<br>    <span class="hljs-attr">language</span>: <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>&#125;));<br><br><span class="hljs-comment">// 缓存数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;cachedData&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(largeData));<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>SessionStorage适用于：</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 表单数据暂存</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;zhangsan@example.com&#x27;</span><br>&#125;));<br><br><span class="hljs-comment">// 页面浏览历史</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>([<span class="hljs-string">&#x27;page1&#x27;</span>, <span class="hljs-string">&#x27;page2&#x27;</span>]));<br></code></pre></td></tr></table></figure><h3 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h3><ol><li><strong>敏感数据处理：</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不要存储敏感信息</span><br><span class="hljs-comment">// 错误示例</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;creditCard&#x27;</span>, <span class="hljs-string">&#x27;1234-5678-9012-3456&#x27;</span>);<br><br><span class="hljs-comment">// 正确示例（加密后存储）</span><br><span class="hljs-keyword">const</span> encryptedData = <span class="hljs-title function_">encrypt</span>(<span class="hljs-string">&#x27;sensitive-data&#x27;</span>);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;secureData&#x27;</span>, encryptedData);<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>数据验证：</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 读取数据时进行验证</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;userData&#x27;</span>));<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidData</span>(data)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Invalid data&#x27;</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;数据验证失败:&#x27;</span>, error);<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;userData&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>跨站脚本攻击（XSS）防护：</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储数据前进行转义</span><br><span class="hljs-keyword">const</span> sanitizedData = <span class="hljs-title function_">escapeHTML</span>(userData);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;userInput&#x27;</span>, sanitizedData);<br><br><span class="hljs-comment">// 读取时解析</span><br><span class="hljs-keyword">const</span> displayData = <span class="hljs-title function_">unescapeHTML</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;userInput&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th><strong>特性</strong></th><th><strong>Cookie</strong></th><th><strong>LocalStorage</strong></th><th><strong>SessionStorage</strong></th></tr></thead><tbody><tr><td><strong>存储大小</strong></td><td>4KB 左右</td><td>5~10MB</td><td>5~10MB</td></tr><tr><td><strong>生命周期</strong></td><td>可设置过期时间（默认会话级）</td><td>永久存储，需手动删除</td><td>标签页关闭后自动删除</td></tr><tr><td><strong>与请求的关系</strong></td><td>每次请求自动携带（影响性能）</td><td>不参与请求</td><td>不参与请求</td></tr><tr><td><strong>访问权限</strong></td><td>同源窗口共享</td><td>同源窗口共享</td><td>仅当前标签页</td></tr><tr><td><strong>API 易用性</strong></td><td>需手动封装</td><td><code>localStorage.setItem()</code></td><td><code>sessionStorage.setItem()</code></td></tr></tbody></table><hr><h3 id="什么是异步和同步"><a href="#什么是异步和同步" class="headerlink" title="什么是异步和同步"></a>什么是异步和同步</h3><ul><li>同步（Synchronous）</li></ul><p>同步操作是按顺序执行的，每个操作必须等待前一个操作完成才能执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 同步示例</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>);<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">someFunction</span>(); <span class="hljs-comment">// 这里会阻塞代码执行，直到函数返回结果</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结果：&#x27;</span>, result);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结束&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>异步（Asynchronous）</li></ul><p>异步操作允许多个操作同时进行，不需要等待前一个操作完成。</p><p>常见的异步操作：</p><ol><li><strong>网络请求</strong></li><li><strong>文件读写</strong></li><li><strong>定时器</strong></li><li><strong>事件监听</strong></li></ol><h4 id="异步实现方式"><a href="#异步实现方式" class="headerlink" title="异步实现方式"></a>异步实现方式</h4><ol><li><strong>回调函数（Callbacks）</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 回调函数示例</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2秒后执行&#x27;</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结束&#x27;</span>);<br><br><span class="hljs-comment">// 输出顺序：</span><br><span class="hljs-comment">// 开始</span><br><span class="hljs-comment">// 结束</span><br><span class="hljs-comment">// 2秒后执行</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>Promise</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Promise示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据获取成功&#x27;</span>);<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;);<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>);<br><span class="hljs-title function_">fetchData</span>()<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结束&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>async&#x2F;await</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// async/await示例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;开始&#x27;</span>);<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 等待Promise完成</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结束&#x27;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h4><ol><li><strong>API请求</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用fetch进行API请求</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/user&#x27;</span>);<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取用户数据失败:&#x27;</span>, error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>文件操作</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Node.js文件读取</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>).<span class="hljs-property">promises</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;读取文件失败:&#x27;</span>, error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>多个异步操作</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 并行执行多个异步操作</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchMultipleData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> [users, posts] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>            <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/users&#x27;</span>),<br>            <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/posts&#x27;</span>)<br>        ]);<br>      <br>        <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> users.<span class="hljs-title function_">json</span>();<br>        <span class="hljs-keyword">const</span> postData = <span class="hljs-keyword">await</span> posts.<span class="hljs-title function_">json</span>();<br>      <br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">users</span>: userData, <span class="hljs-attr">posts</span>: postData &#125;;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取数据失败:&#x27;</span>, error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异步的优势"><a href="#异步的优势" class="headerlink" title="异步的优势"></a>异步的优势</h4><ol><li><strong>不阻塞主线程</strong>：</li><li><strong>提高应用性能</strong>：</li><li><strong>更好的用户体验</strong>：</li></ol><h3 id="Promise-的用法"><a href="#Promise-的用法" class="headerlink" title="Promise 的用法"></a>Promise 的用法</h3><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. <strong>基本语法</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作（如请求接口）</span><br>  <span class="hljs-keyword">if</span> (success) &#123;<br>    <span class="hljs-title function_">resolve</span>(result); <span class="hljs-comment">// 成功回调</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);   <span class="hljs-comment">// 失败回调</span><br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 使用 then/catch 处理结果</span><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功:&quot;</span>, result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败:&quot;</span>, error));<br></code></pre></td></tr></table></figure><h4 id="2-链式调用"><a href="#2-链式调用" class="headerlink" title="2. 链式调用"></a>2. <strong>链式调用</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-title function_">processData</span>(data))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-title function_">saveData</span>(result))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-title function_">handleError</span>(error));<br></code></pre></td></tr></table></figure><h4 id="3-Async-Await（更简洁的写法）"><a href="#3-Async-Await（更简洁的写法）" class="headerlink" title="3. Async&#x2F;Await（更简洁的写法）"></a>3. <strong>Async&#x2F;Await（更简洁的写法）</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">processData</span>(data);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;结果:&quot;</span>, result);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;错误:&quot;</span>, error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="let、var-和-const-的区别"><a href="#let、var-和-const-的区别" class="headerlink" title="let、var 和 const 的区别"></a><code>let</code>、<code>var</code> 和 <code>const</code> 的区别</h3><table><thead><tr><th><strong>特性</strong></th><th><strong><code>let</code></strong></th><th><strong><code>var</code></strong></th><th><strong><code>const</code></strong></th></tr></thead><tbody><tr><td><strong>重新赋值</strong></td><td>✅（允许）</td><td>✅（允许）</td><td>❌（不可重新赋值）</td></tr><tr><td><strong>块级作用域</strong></td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td><strong>声明必须初始化</strong></td><td>❌（可稍后赋值）</td><td>❌（可稍后赋值）</td><td>✅（必须声明时初始化）</td></tr><tr><td><strong>适用场景</strong></td><td>变量需要修改时（如循环计数器）</td><td>不推荐使用</td><td>常量（如配置项、固定引用）</td></tr></tbody></table><hr><h3 id="定义计时器"><a href="#定义计时器" class="headerlink" title="定义计时器"></a>定义计时器</h3><h4 id="1-setTimeout（单次延迟执行）"><a href="#1-setTimeout（单次延迟执行）" class="headerlink" title="1. setTimeout（单次延迟执行）"></a>1. <strong><code>setTimeout</code>（单次延迟执行）</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 延迟 1 秒后执行</span><br><span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;延迟执行&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 清除计时器（若需要取消）</span><br><span class="hljs-built_in">clearTimeout</span>(timerId);<br></code></pre></td></tr></table></figure><h4 id="2-setInterval（重复执行）"><a href="#2-setInterval（重复执行）" class="headerlink" title="2. setInterval（重复执行）"></a>2. <strong><code>setInterval</code>（重复执行）</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 每隔 1 秒执行一次</span><br><span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;重复执行&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 清除计时器</span><br><span class="hljs-built_in">clearInterval</span>(intervalId);<br></code></pre></td></tr></table></figure><hr><h3 id="Vue-组件通信方式"><a href="#Vue-组件通信方式" class="headerlink" title="Vue 组件通信方式"></a>Vue 组件通信方式</h3><h4 id="1-父子组件"><a href="#1-父子组件" class="headerlink" title="1. 父子组件"></a>1. <strong>父子组件</strong></h4><ul><li><strong>父传子</strong>：<code>props</code></li><li><strong>子传父</strong>：<code>$emit</code> 触发事件</li></ul><h4 id="2-跨层级组件"><a href="#2-跨层级组件" class="headerlink" title="2. 跨层级组件"></a>2. <strong>跨层级组件</strong></h4><ul><li><strong>事件总线</strong>：<code>EventBus</code>（小型项目）</li><li><strong>Vuex&#x2F;Pinia</strong>：状态管理库（中大型项目）</li><li><strong>依赖注入</strong>：<code>provide/inject</code></li></ul><h4 id="3-兄弟组件"><a href="#3-兄弟组件" class="headerlink" title="3. 兄弟组件"></a>3. 兄弟组件</h4><ul><li><strong>通过共同父组件中转</strong></li><li><strong>Vuex 或全局事件总线</strong></li></ul><hr><h3 id="Vue-中-v-for-的-key-作用"><a href="#Vue-中-v-for-的-key-作用" class="headerlink" title="Vue 中 v-for 的 key 作用"></a>Vue 中 <code>v-for</code> 的 <code>key</code> 作用</h3><ul><li><strong>核心作用</strong>：帮助 Vue 识别虚拟 DOM 节点的唯一性，优化 Diff 算法效率。</li><li><strong>错误用法</strong>：使用索引 <code>index</code> 作为 key（可能导致渲染错误或性能问题）。</li><li><strong>正确实践</strong>：使用唯一标识（如 <code>id</code>）。</li></ul><hr><h3 id="为什么-Vue-不建议-v-for-和-v-if-一起用？"><a href="#为什么-Vue-不建议-v-for-和-v-if-一起用？" class="headerlink" title="为什么 Vue 不建议 v-for 和 v-if 一起用？"></a>为什么 Vue 不建议 <code>v-for</code> 和 <code>v-if</code> 一起用？</h3><ul><li><strong>优先级问题</strong>：<code>v-for</code> 优先级高于 <code>v-if</code>，导致每次循环都会执行条件判断，浪费性能。</li><li><strong>解决方案</strong>：<ol><li>改用计算属性过滤数据后再遍历。</li><li>在外层包裹 <code>&lt;template&gt;</code> 单独使用 <code>v-if</code>。</li></ol></li></ul><hr><h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a><code>computed</code> 和 <code>watch</code> 的区别</h3><table><thead><tr><th><strong>特性</strong></th><th><strong><code>computed</code></strong></th><th><strong><code>watch</code></strong></th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>基于依赖的派生数据（如过滤、计算）</td><td>监听数据变化执行异步或复杂操作</td></tr><tr><td><strong>缓存</strong></td><td>有缓存（依赖不变时直接返回结果）</td><td>无缓存（每次触发都执行）</td></tr><tr><td><strong>同步&#x2F;异步</strong></td><td>仅支持同步</td><td>支持异步操作</td></tr><tr><td><strong>示例场景</strong></td><td>计算总价、格式化日期</td><td>搜索框输入防抖、路由跳转</td></tr></tbody></table><hr><h3 id="Vue-如何实现双向绑定？"><a href="#Vue-如何实现双向绑定？" class="headerlink" title="Vue 如何实现双向绑定？"></a>Vue 如何实现双向绑定？</h3><h4 id="双向绑定语法糖：v-model"><a href="#双向绑定语法糖：v-model" class="headerlink" title="双向绑定语法糖：v-model"></a><strong>双向绑定语法糖：<code>v-model</code></strong></h4><p>本质是 <code>:value</code> + <code>@input</code> 的简写，常用于表单控件。</p><h3 id="介绍主流浏览器的特性，解决常见兼容性问题"><a href="#介绍主流浏览器的特性，解决常见兼容性问题" class="headerlink" title="介绍主流浏览器的特性，解决常见兼容性问题"></a>介绍主流浏览器的特性，解决常见兼容性问题</h3><h4 id="1-主流浏览器特性"><a href="#1-主流浏览器特性" class="headerlink" title="1. 主流浏览器特性"></a>1. <strong>主流浏览器特性</strong></h4><table><thead><tr><th>浏览器</th><th>渲染引擎</th><th>JavaScript引擎</th><th>特点</th></tr></thead><tbody><tr><td>Chrome</td><td>Blink</td><td>V8</td><td>性能好，对新特性支持度高</td></tr><tr><td>Firefox</td><td>Gecko</td><td>SpiderMonkey</td><td>开源，扩展性强</td></tr><tr><td>Safari</td><td>WebKit</td><td>JavaScriptCore</td><td>对苹果生态优化好</td></tr></tbody></table><ul><li>其实使用Vue3框架以及Element plus等UI框架+vite等打包工具，解决了大部分的兼容性问题；以下是从原理上讲；</li></ul><h4 id="2-常见兼容性问题及解决方案"><a href="#2-常见兼容性问题及解决方案" class="headerlink" title="2. 常见兼容性问题及解决方案"></a>2. <strong>常见兼容性问题及解决方案</strong></h4><h5 id="CSS兼容性"><a href="#CSS兼容性" class="headerlink" title="CSS兼容性"></a>CSS兼容性</h5><ol><li><p><strong>浏览器前缀</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);  <span class="hljs-comment">/* Chrome, Safari */</span><br>  -moz-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);     <span class="hljs-comment">/* Firefox */</span><br>  -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);      <span class="hljs-comment">/* IE */</span><br>  -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);       <span class="hljs-comment">/* Opera */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Flex布局兼容</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: -webkit-box;      <span class="hljs-comment">/* iOS 6-, Safari 3.1-6 */</span><br>  <span class="hljs-attribute">display</span>: -webkit-flex;     <span class="hljs-comment">/* Chrome */</span><br>  <span class="hljs-attribute">display</span>: -moz-box;         <span class="hljs-comment">/* Firefox */</span><br>  <span class="hljs-attribute">display</span>: -ms-flexbox;      <span class="hljs-comment">/* IE 10 */</span><br>  <span class="hljs-attribute">display</span>: flex;             <span class="hljs-comment">/* 现代浏览器 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>自动添加前缀</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 Autoprefixer (PostCSS 插件)</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;autoprefixer&#x27;</span>)(&#123;<br>      <span class="hljs-attr">browsers</span>: [<span class="hljs-string">&#x27;last 2 versions&#x27;</span>, <span class="hljs-string">&#x27;&gt; 1%&#x27;</span>]<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="JavaScript兼容性"><a href="#JavaScript兼容性" class="headerlink" title="JavaScript兼容性"></a>JavaScript兼容性</h5><ol><li><p><strong>特性检测</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 检测是否支持某个API</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">localStorage</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 使用 localStorage</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 使用替代方案</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Polyfill使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 core-js 添加 ES6+ 特性支持</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;core-js/stable&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;regenerator-runtime/runtime&#x27;</span>;<br><br><span class="hljs-comment">// 或使用 @babel/polyfill</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@babel/polyfill&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>Babel配置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// babel.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">presets</span>: [<br>    [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<br>      <span class="hljs-attr">targets</span>: &#123;<br>        <span class="hljs-attr">browsers</span>: [<span class="hljs-string">&#x27;last 2 versions&#x27;</span>, <span class="hljs-string">&#x27;&gt; 1%&#x27;</span>]<br>      &#125;<br>    &#125;]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ol><li><p><strong>viewport设置</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>媒体查询</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 响应式设计 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>rem适配方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 动态设置根元素字体大小</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setRem</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;<br>  <span class="hljs-keyword">const</span> width = html.<span class="hljs-property">clientWidth</span>;<br>  html.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = width / <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;px&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, setRem);<br><span class="hljs-title function_">setRem</span>();<br></code></pre></td></tr></table></figure></li></ol><h3 id="Webpack-gulp等打包工具的使用"><a href="#Webpack-gulp等打包工具的使用" class="headerlink" title="Webpack&#x2F;gulp等打包工具的使用"></a>Webpack&#x2F;gulp等打包工具的使用</h3><h4 id="5-打包工具选择建议"><a href="#5-打包工具选择建议" class="headerlink" title="5. 打包工具选择建议"></a>5. <strong>打包工具选择建议</strong></h4><ol><li><p><strong>Webpack适用场景</strong>：</p><ul><li>现代前端框架项目（Vue&#x2F;React）</li><li>需要复杂模块管理</li><li>需要强大的代码分割</li><li>单页应用(SPA)开发</li></ul></li><li><p><strong>Gulp适用场景</strong>：</p><ul><li>简单的网页开发</li><li>多页应用开发</li><li>需要文件流操作</li><li>自动化任务管理</li></ul></li></ol><h4 id="6-性能优化实践"><a href="#6-性能优化实践" class="headerlink" title="6. 性能优化实践"></a>6. <strong>性能优化实践</strong></h4><ol><li><strong>代码分割</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 动态导入</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="hljs-string">&#x27;./views/Home.vue&#x27;</span>);<br><br><span class="hljs-comment">// 提取公共代码</span><br><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">splitChunks</span>: &#123;<br>    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>    <span class="hljs-attr">minSize</span>: <span class="hljs-number">20000</span>,<br>    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="对web页面大数据处理、安全性等的理解"><a href="#对web页面大数据处理、安全性等的理解" class="headerlink" title="对web页面大数据处理、安全性等的理解"></a>对web页面大数据处理、安全性等的理解</h3><h3 id="Web页面大数据处理与安全性"><a href="#Web页面大数据处理与安全性" class="headerlink" title="Web页面大数据处理与安全性"></a>Web页面大数据处理与安全性</h3><h4 id="1-大数据处理策略"><a href="#1-大数据处理策略" class="headerlink" title="1. 大数据处理策略"></a>1. <strong>大数据处理策略</strong></h4><h5 id="1-1-虚拟列表"><a href="#1-1-虚拟列表" class="headerlink" title="1.1 虚拟列表"></a>1.1 虚拟列表</h5><ul><li><ol><li><strong>基本概念</strong></li></ol></li></ul><p>虚拟列表是一种用于优化长列表性能的技术，核心思想是：只渲染可视区域内的列表项，而不是渲染整个列表。</p><ul><li><ol start="2"><li><strong>关键要素</strong></li></ol></li></ul><ol><li><strong>可视区域高度</strong>：视口（viewport）的高度</li><li><strong>列表项高度</strong>：每个列表项的高度（固定或动态）</li><li><strong>可视区域起始索引</strong>：根据滚动位置计算</li><li><strong>可见列表项数量</strong>：根据可视区域高度和列表项高度计算</li></ol><h5 id="1-2-分片处理"><a href="#1-2-分片处理" class="headerlink" title="1.2 分片处理"></a>1.2 分片处理</h5><p>将大量数据切分成小块，利用浏览器的空闲时间分批处理，避免阻塞主线程。</p><h5 id="1-3-Web-Worker"><a href="#1-3-Web-Worker" class="headerlink" title="1.3 Web Worker"></a>1.3 Web Worker</h5><p>Web Worker 提供了在后台线程中运行脚本的能力，不会阻塞主线程。</p><h4 id="2-安全性处理"><a href="#2-安全性处理" class="headerlink" title="2. 安全性处理"></a>2. <strong>安全性处理</strong></h4><h5 id="2-1-XSS防御"><a href="#2-1-XSS防御" class="headerlink" title="2.1 XSS防御"></a>2.1 XSS防御</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入过滤</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeHtml</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&quot;/g</span>, <span class="hljs-string">&#x27;&amp;quot;&#x27;</span>)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&#x27;/g</span>, <span class="hljs-string">&#x27;&amp;#39;&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// Vue中使用v-html时的安全处理</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$sanitize</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">html</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">DOMPurify</span>.<span class="hljs-title function_">sanitize</span>(html)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-CSRF防御"><a href="#2-2-CSRF防御" class="headerlink" title="2.2 CSRF防御"></a>2.2 CSRF防御</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// axios请求拦截器添加token</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">getCsrfToken</span>()<br>  <span class="hljs-keyword">if</span> (token) &#123;<br>    config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;X-CSRF-TOKEN&#x27;</span>] = token<br>  &#125;<br>  <span class="hljs-keyword">return</span> config<br>&#125;)<br><br><span class="hljs-comment">// 服务端验证示例（Express）</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">csrf</span>())<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;XSRF-TOKEN&#x27;</span>, req.<span class="hljs-title function_">csrfToken</span>())<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="2-4-数据加密"><a href="#2-4-数据加密" class="headerlink" title="2.4 数据加密"></a>2.4 数据加密</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 敏感数据加密</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">encryptData</span>(<span class="hljs-params">data, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> cipher = <span class="hljs-title class_">CryptoJS</span>.<span class="hljs-property">AES</span>.<span class="hljs-title function_">encrypt</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), key)<br>  <span class="hljs-keyword">return</span> cipher.<span class="hljs-title function_">toString</span>()<br>&#125;<br><br><span class="hljs-comment">// 数据解密</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">decryptData</span>(<span class="hljs-params">encryptedData, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> bytes = <span class="hljs-title class_">CryptoJS</span>.<span class="hljs-property">AES</span>.<span class="hljs-title function_">decrypt</span>(encryptedData, key)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(bytes.<span class="hljs-title function_">toString</span>(<span class="hljs-title class_">CryptoJS</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Utf8</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. <strong>性能优化</strong></h4><ol><li><strong>数据缓存（IndexedDB）</strong></li></ol><ul><li>浏览器提供的本地数据库，用于存储大量结构化数据</li><li>支持异步操作，不会阻塞主线程</li><li>适用于存储大型数据集、离线数据等场景</li><li>通过事务机制确保数据完整性</li></ul><ol start="2"><li><strong>请求队列合并</strong></li></ol><ul><li>将短时间内的多个请求合并成一个批量请求</li><li>使用防抖机制控制请求发送时机</li><li>减少服务器压力，优化网络资源利用</li><li>适用于需要频繁请求的场景</li></ul><ol start="3"><li><strong>性能监控</strong></li></ol><ul><li>收集页面性能指标（加载时间、响应时间等）</li><li>使用Performance API进行精确计时</li><li>通过sendBeacon进行数据上报，避免页面卸载时丢失数据</li><li>帮助发现性能瓶颈，优化用户体验</li></ul><h3 id="Web性能优化"><a href="#Web性能优化" class="headerlink" title="Web性能优化"></a>Web性能优化</h3><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><ol><li><strong>基本概念</strong><br>懒加载是一种性能优化技术，核心思想是：延迟加载页面中不可见区域的资源，直到用户需要查看时才进行加载。</li></ol><h6 id="Vue路由懒加载按需加载"><a href="#Vue路由懒加载按需加载" class="headerlink" title="Vue路由懒加载按需加载"></a><strong>Vue路由懒加载按需加载</strong></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue路由懒加载</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="hljs-string">&#x27;./views/Home.vue&#x27;</span>)<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><ol><li><p><strong>主要应用场景</strong></p></li><li><p><strong>图片懒加载</strong></p><ul><li>长列表中的图片</li><li>页面底部的图片</li><li>轮播图中的非当前图片</li></ul></li><li><p><strong>组件懒加载</strong></p><ul><li>路由组件</li><li>复杂组件</li><li>弹窗组件</li></ul></li><li><p><strong>数据懒加载</strong></p><ul><li>分页数据</li><li>无限滚动</li></ul></li><li><p><strong>实现原理</strong></p><ol><li><p><strong>监测可视区域</strong></p><ul><li>使用 Intersection Observer API</li><li>监听滚动事件（传统方式）</li><li>计算元素位置</li></ul></li><li><p><strong>触发加载</strong></p><ul><li>当元素进入可视区域时加载资源</li><li>提前一定距离开始加载（预加载）</li><li>替换占位符为实际内容</li></ul></li></ol></li></ol><h4 id="1资源加载优化"><a href="#1资源加载优化" class="headerlink" title="1资源加载优化"></a>1<strong>资源加载优化</strong></h4><h5 id="1-1-资源压缩与合并"><a href="#1-1-资源压缩与合并" class="headerlink" title="1.1 资源压缩与合并"></a>1.1 <strong>资源压缩与合并</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack配置示例</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 启用压缩</span><br>    <span class="hljs-attr">splitChunks</span>: &#123;   <span class="hljs-comment">// 代码分割</span><br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-CDN加速"><a href="#1-2-CDN加速" class="headerlink" title="1.2 CDN加速"></a>1.2 <strong>CDN加速</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用CDN加载公共资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.xxx.com/element-ui/index.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.xxx.com/vue/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-3-预加载与预解析"><a href="#1-3-预加载与预解析" class="headerlink" title="1.3 预加载与预解析"></a>1.3 <strong>预加载与预解析</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- DNS预解析 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//example.com&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 预加载 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;style&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 预渲染 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prerender&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;next-page.html&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-代码优化"><a href="#2-代码优化" class="headerlink" title="2. 代码优化"></a>2. <strong>代码优化</strong></h4><h3 id="防抖-Debounce"><a href="#防抖-Debounce" class="headerlink" title="防抖(Debounce)"></a>防抖(Debounce)</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h4><ul><li>在事件被触发n秒后再执行回调</li><li>如果在这n秒内事件又被触发，则重新计时</li><li>适合多次事件一次响应的情况</li></ul><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 基础版防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 保存this和参数</span><br>    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <br>    <span class="hljs-comment">// 如果已经设定过定时器，则清空上一次的定时器</span><br>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    <br>    <span class="hljs-comment">// 设定新的定时器</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 立即执行版防抖</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay, immediate = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <br>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer)<br>    <br>    <span class="hljs-keyword">if</span>(immediate) &#123;<br>      <span class="hljs-comment">// 如果是第一次触发，则立即执行</span><br>      <span class="hljs-keyword">const</span> callNow = !timer<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        timer = <span class="hljs-literal">null</span><br>      &#125;, delay)<br>      <span class="hljs-keyword">if</span>(callNow) fn.<span class="hljs-title function_">apply</span>(context, args)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(context, args)<br>      &#125;, delay)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 搜索框输入查询</span><br><span class="hljs-keyword">const</span> searchInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;search&#x27;</span>)<br>searchInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 发起搜索请求</span><br>  <span class="hljs-title function_">search</span>()<br>&#125;, <span class="hljs-number">500</span>))<br><br><span class="hljs-comment">// 2. 窗口大小调整</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 更新布局</span><br>  <span class="hljs-title function_">updateLayout</span>()<br>&#125;, <span class="hljs-number">200</span>))<br></code></pre></td></tr></table></figure><h3 id="节流-Throttle"><a href="#节流-Throttle" class="headerlink" title="节流(Throttle)"></a>节流(Throttle)</h3><h4 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1. 原理"></a>1. 原理</h4><ul><li>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行</li><li>如果在同一个单位时间内某事件被触发多次，只有一次能生效</li><li>适合大量事件按时间做平均分配触发</li></ul><h4 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2. 实现"></a>2. 实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 时间戳版节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <br>    <span class="hljs-keyword">if</span>(now - previous &gt; delay) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args)<br>      previous = now<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定时器版节流</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span><br>    <br>    <span class="hljs-keyword">if</span>(!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fn.<span class="hljs-title function_">apply</span>(context, args)<br>        timer = <span class="hljs-literal">null</span><br>      &#125;, delay)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-使用场景-1"><a href="#3-使用场景-1" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 滚动事件处理</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 更新滚动动画</span><br>  <span class="hljs-title function_">updateAnimation</span>()<br>&#125;, <span class="hljs-number">100</span>))<br><br><span class="hljs-comment">// 2. 按钮点击</span><br>submitButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 提交表单</span><br>  <span class="hljs-title function_">submitForm</span>()<br>&#125;, <span class="hljs-number">1000</span>))<br></code></pre></td></tr></table></figure><h3 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h3><table><thead><tr><th>特性</th><th>防抖(Debounce)</th><th>节流(Throttle)</th></tr></thead><tbody><tr><td>触发时机</td><td>最后一次事件触发后的delay时间后执行</td><td>第一次事件触发后的delay时间内只执行一次</td></tr><tr><td>适用场景</td><td>输入框实时搜索、窗口大小调整</td><td>滚动事件处理、按钮点击控制</td></tr><tr><td>执行频率</td><td>多次触发，最后一次生效</td><td>按照时间间隔执行</td></tr><tr><td>性能消耗</td><td>较低（只执行最后一次）</td><td>适中（按时间间隔执行）</td></tr></tbody></table><h3 id="实际应用示例-1"><a href="#实际应用示例-1" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 防抖：实时搜索</span><br><span class="hljs-keyword">const</span> searchInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;search&#x27;</span>)<br><span class="hljs-keyword">const</span> debouncedSearch = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;搜索:&#x27;</span>, value)<br>  <span class="hljs-comment">// 发起API请求</span><br>&#125;, <span class="hljs-number">500</span>)<br><br>searchInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">debouncedSearch</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>&#125;)<br><br><span class="hljs-comment">// 节流：页面滚动</span><br><span class="hljs-keyword">const</span> throttledScroll = <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;滚动位置:&#x27;</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>)<br>  <span class="hljs-comment">// 更新页面元素</span><br>&#125;, <span class="hljs-number">100</span>)<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, throttledScroll)<br></code></pre></td></tr></table></figure><h4 id="3-渲染优化"><a href="#3-渲染优化" class="headerlink" title="3. 渲染优化"></a>3. <strong>渲染优化</strong></h4><h5 id="3-1-避免重排重绘"><a href="#3-1-避免重排重绘" class="headerlink" title="3.1 避免重排重绘"></a>3.1 <strong>避免重排重绘</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 批量DOM操作</span><br><span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>()<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>)<br>  fragment.<span class="hljs-title function_">appendChild</span>(li)<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>).<span class="hljs-title function_">appendChild</span>(fragment)<br></code></pre></td></tr></table></figure><h5 id="3-2-CSS优化"><a href="#3-2-CSS优化" class="headerlink" title="3.2 CSS优化"></a>3.2 <strong>CSS优化</strong></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 使用transform代替位置改变 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">100px</span>);<br>  <span class="hljs-comment">/* 替代 */</span><br>  <span class="hljs-comment">/* left: 100px; */</span><br>  <span class="hljs-comment">/* top: 100px; */</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="一、GET与POST请求的核心区别"><a href="#一、GET与POST请求的核心区别" class="headerlink" title="一、GET与POST请求的核心区别"></a><strong>一、GET与POST请求的核心区别</strong></h3><table><thead><tr><th><strong>对比维度</strong></th><th><strong>GET请求</strong></th><th><strong>POST请求</strong></th></tr></thead><tbody><tr><td><strong>主要用途</strong></td><td>获取数据（查）</td><td>提交数据（增&#x2F;改）</td></tr><tr><td><strong>参数位置</strong></td><td>URL查询字符串（<code>?key=value</code>）</td><td>请求体（Body）</td></tr><tr><td><strong>数据长度限制</strong></td><td>受URL长度限制（通常2KB-8KB）</td><td>无硬性限制（服务器可配置）</td></tr><tr><td><strong>缓存机制</strong></td><td>可被浏览器缓存</td><td>默认不缓存</td></tr><tr><td><strong>安全性</strong></td><td>参数明文暴露在URL中</td><td>数据在请求体中相对隐蔽</td></tr><tr><td><strong>幂等性</strong></td><td>幂等（多次请求结果相同）</td><td>非幂等（可能产生副作用）</td></tr><tr><td><strong>浏览器历史记录</strong></td><td>保留参数</td><td>不保留请求体数据</td></tr><tr><td><strong>典型应用场景</strong></td><td>搜索、分页、资源获取</td><td>表单提交、文件上传、敏感操作</td></tr></tbody></table><hr><h3 id="二、常见HTTP状态码分类解析"><a href="#二、常见HTTP状态码分类解析" class="headerlink" title="二、常见HTTP状态码分类解析"></a><strong>二、常见HTTP状态码分类解析</strong></h3><h4 id="2xx-成功类"><a href="#2xx-成功类" class="headerlink" title="2xx 成功类"></a><strong>2xx 成功类</strong></h4><table><thead><tr><th><strong>状态码</strong></th><th><strong>含义</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>200 OK</strong></td><td>请求成功</td><td>标准成功响应</td></tr><tr><td><strong>201 Created</strong></td><td>资源创建成功</td><td>RESTful API创建新资源后返回</td></tr><tr><td><strong>204 No Content</strong></td><td>无返回内容</td><td>DELETE请求成功后的响应</td></tr></tbody></table><h4 id="3xx-重定向类"><a href="#3xx-重定向类" class="headerlink" title="3xx 重定向类"></a><strong>3xx 重定向类</strong></h4><table><thead><tr><th><strong>状态码</strong></th><th><strong>含义</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>301 Moved Permanently</strong></td><td>永久重定向</td><td>网站改版后旧URL跳转</td></tr><tr><td><strong>302 Found</strong></td><td>临时重定向</td><td>登录后跳回原页面</td></tr><tr><td><strong>304 Not Modified</strong></td><td>资源未修改</td><td>协商缓存生效时返回</td></tr></tbody></table><h4 id="4xx-客户端错误类"><a href="#4xx-客户端错误类" class="headerlink" title="4xx 客户端错误类"></a><strong>4xx 客户端错误类</strong></h4><table><thead><tr><th><strong>状态码</strong></th><th><strong>含义</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>400 Bad Request</strong></td><td>请求语法错误</td><td>参数格式错误&#x2F;必填字段缺失</td></tr><tr><td><strong>401 Unauthorized</strong></td><td>未认证</td><td>未携带有效Token访问需登录的接口</td></tr><tr><td><strong>403 Forbidden</strong></td><td>禁止访问</td><td>权限不足（如普通用户访问管理员接口）</td></tr><tr><td><strong>404 Not Found</strong></td><td>资源不存在</td><td>访问不存在的URL</td></tr><tr><td><strong>429 Too Many Requests</strong></td><td>请求过频</td><td>接口限流触发</td></tr></tbody></table><h4 id="5xx-服务端错误类"><a href="#5xx-服务端错误类" class="headerlink" title="5xx 服务端错误类"></a><strong>5xx 服务端错误类</strong></h4><table><thead><tr><th><strong>状态码</strong></th><th><strong>含义</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>500 Internal Server Error</strong></td><td>服务器内部错误</td><td>代码未捕获的异常</td></tr><tr><td><strong>502 Bad Gateway</strong></td><td>网关错误</td><td>反向代理服务器无法获取响应</td></tr><tr><td><strong>503 Service Unavailable</strong></td><td>服务不可用</td><td>服务器过载维护&#x2F;停机</td></tr><tr><td><strong>504 Gateway Timeout</strong></td><td>网关超时</td><td>上游服务器响应超时</td></tr></tbody></table><hr><h3 id="js中的数据类型有哪些"><a href="#js中的数据类型有哪些" class="headerlink" title="js中的数据类型有哪些"></a>js中的数据类型有哪些</h3><p>字符串，数值，布尔，undefined，null</p><h3 id="常用的原生js函数比如字符串和数组的操作有哪些方法"><a href="#常用的原生js函数比如字符串和数组的操作有哪些方法" class="headerlink" title="常用的原生js函数比如字符串和数组的操作有哪些方法"></a>常用的原生js函数比如字符串和数组的操作有哪些方法</h3><h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;Hello World&quot;</span><br><br><span class="hljs-comment">// 获取长度</span><br>str.<span class="hljs-property">length</span>  <span class="hljs-comment">// 11</span><br><br><span class="hljs-comment">// 获取字符</span><br>str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment">// &quot;H&quot;</span><br>str[<span class="hljs-number">0</span>]         <span class="hljs-comment">// &quot;H&quot;</span><br><br><span class="hljs-comment">// 获取子串</span><br>str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">// &quot;Hello&quot;</span><br>str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)      <span class="hljs-comment">// &quot;Hello&quot;</span><br>str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)     <span class="hljs-comment">// &quot;Hello&quot;（不推荐使用）</span><br><br><span class="hljs-comment">// 查找</span><br>str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;World&quot;</span>)     <span class="hljs-comment">// 6</span><br>str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;o&quot;</span>)    <span class="hljs-comment">// 7</span><br>str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;Hello&quot;</span>)   <span class="hljs-comment">// true</span><br>str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Hello&quot;</span>) <span class="hljs-comment">// true</span><br>str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;World&quot;</span>)   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="2-转换方法"><a href="#2-转换方法" class="headerlink" title="2. 转换方法"></a>2. 转换方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 大小写转换</span><br>str.<span class="hljs-title function_">toUpperCase</span>()   <span class="hljs-comment">// &quot;HELLO WORLD&quot;</span><br>str.<span class="hljs-title function_">toLowerCase</span>()   <span class="hljs-comment">// &quot;hello world&quot;</span><br><br><span class="hljs-comment">// 去除空格</span><br>str.<span class="hljs-title function_">trim</span>()          <span class="hljs-comment">// 去除两端空格</span><br>str.<span class="hljs-title function_">trimStart</span>()     <span class="hljs-comment">// 去除开头空格</span><br>str.<span class="hljs-title function_">trimEnd</span>()       <span class="hljs-comment">// 去除结尾空格</span><br><br><span class="hljs-comment">// 分割</span><br>str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)      <span class="hljs-comment">// [&quot;Hello&quot;, &quot;World&quot;]</span><br><br><span class="hljs-comment">// 替换</span><br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>)  <span class="hljs-comment">// &quot;Hello JavaScript&quot;</span><br>str.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>)           <span class="hljs-comment">// &quot;HeLLo WorLd&quot;</span><br></code></pre></td></tr></table></figure><h3 id="数组操作方法"><a href="#数组操作方法" class="headerlink" title="数组操作方法"></a>数组操作方法</h3><h4 id="1-增删改查"><a href="#1-增删改查" class="headerlink" title="1. 增删改查"></a>1. 增删改查</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-comment">// 添加元素</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>)         <span class="hljs-comment">// 末尾添加，返回新长度</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>)      <span class="hljs-comment">// 开头添加，返回新长度</span><br><br><span class="hljs-comment">// 删除元素</span><br>arr.<span class="hljs-title function_">pop</span>()           <span class="hljs-comment">// 删除最后一个，返回被删除元素</span><br>arr.<span class="hljs-title function_">shift</span>()         <span class="hljs-comment">// 删除第一个，返回被删除元素</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)    <span class="hljs-comment">// 从索引1开始删除2个元素</span><br><br><span class="hljs-comment">// 修改元素</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>         <span class="hljs-comment">// 直接修改</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 替换元素</span><br><br><span class="hljs-comment">// 查找元素</span><br>arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">3</span>)      <span class="hljs-comment">// 返回元素索引</span><br>arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>)     <span class="hljs-comment">// 判断是否包含</span><br>arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">3</span>) <span class="hljs-comment">// 返回第一个满足条件的元素</span><br>arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">3</span>) <span class="hljs-comment">// 返回第一个满足条件的元素索引</span><br></code></pre></td></tr></table></figure><h4 id="2-遍历方法"><a href="#2-遍历方法" class="headerlink" title="2. 遍历方法"></a>2. 遍历方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// forEach：遍历</span><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index)<br>&#125;)<br><br><span class="hljs-comment">// map：映射，返回新数组</span><br><span class="hljs-keyword">const</span> doubled = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// filter：过滤，返回新数组</span><br><span class="hljs-keyword">const</span> filtered = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// reduce：累加</span><br><span class="hljs-keyword">const</span> sum = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// some：判断是否存在满足条件的元素</span><br><span class="hljs-keyword">const</span> hasEven = arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// every：判断是否所有元素都满足条件</span><br><span class="hljs-keyword">const</span> allPositive = arr.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="3-数组转换"><a href="#3-数组转换" class="headerlink" title="3. 数组转换"></a>3. 数组转换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 合并数组</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">const</span> merged = arr1.<span class="hljs-title function_">concat</span>(arr2)  <span class="hljs-comment">// [1, 2, 3, 4]</span><br><span class="hljs-comment">// 或使用展开运算符</span><br><span class="hljs-keyword">const</span> merged2 = [...arr1, ...arr2]<br><br><span class="hljs-comment">// 转换为字符串</span><br>arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;,&quot;</span>)  <span class="hljs-comment">// &quot;1,2,3,4,5&quot;</span><br><br><span class="hljs-comment">// 复制数组</span><br><span class="hljs-keyword">const</span> copy = arr.<span class="hljs-title function_">slice</span>()<br><span class="hljs-comment">// 或使用展开运算符</span><br><span class="hljs-keyword">const</span> copy2 = [...arr]<br></code></pre></td></tr></table></figure><h4 id="4-排序方法"><a href="#4-排序方法" class="headerlink" title="4. 排序方法"></a>4. 排序方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 排序</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)  <span class="hljs-comment">// 升序</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)  <span class="hljs-comment">// 降序</span><br><br><span class="hljs-comment">// 反转</span><br>arr.<span class="hljs-title function_">reverse</span>()<br></code></pre></td></tr></table></figure><h3 id="实际应用示例-2"><a href="#实际应用示例-2" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatName</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> name<br>    .<span class="hljs-title function_">trim</span>()<br>    .<span class="hljs-title function_">toLowerCase</span>()<br>    .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + word.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>))<br>    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br><span class="hljs-title function_">formatName</span>(<span class="hljs-string">&quot; john smith &quot;</span>)  <span class="hljs-comment">// &quot;John Smith&quot;</span><br><br><span class="hljs-comment">// 数组处理</span><br><span class="hljs-keyword">const</span> users = [<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;,<br>  &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">22</span> &#125;<br>]<br><br><span class="hljs-comment">// 查找用户</span><br><span class="hljs-keyword">const</span> user = users.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">id</span> === <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 获取所有用户名</span><br><span class="hljs-keyword">const</span> names = users.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">name</span>)<br><br><span class="hljs-comment">// 获取年龄大于20的用户</span><br><span class="hljs-keyword">const</span> adults = users.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">age</span> &gt; <span class="hljs-number">20</span>)<br><br><span class="hljs-comment">// 计算平均年龄</span><br><span class="hljs-keyword">const</span> avgAge = users.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, user</span>) =&gt;</span> sum + user.<span class="hljs-property">age</span>, <span class="hljs-number">0</span>) / users.<span class="hljs-property">length</span><br></code></pre></td></tr></table></figure><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a><strong>1. 数据类型</strong></h3><ul><li><strong>基本类型</strong>：<code>Undefined</code>、<code>Null</code>、Boolean、Number、String、Symbol（ES6）。  </li><li><strong>引用类型</strong>：Object（包括 Array、Function、Date 等）。  </li><li><strong>区别</strong>：基本类型按值存储，引用类型按引用（内存地址）存储。</li></ul><hr><h3 id="2-判断数据类型"><a href="#2-判断数据类型" class="headerlink" title="2. 判断数据类型"></a><strong>2. 判断数据类型</strong></h3><ul><li>**<code>typeof</code>**：快速区分基本类型（<code>typeof null</code> 返回 <code>&quot;object&quot;</code>，需注意）。  </li><li>**<code>instanceof</code>**：检测对象是否为某构造函数的实例（无法判断基本类型）。  </li><li>**<code>Object.prototype.toString.call()</code>**：最准确（如 <code>[object Array]</code>）。</li></ul><hr><h3 id="3-重排（Reflow）和重绘（Repaint）"><a href="#3-重排（Reflow）和重绘（Repaint）" class="headerlink" title="3. 重排（Reflow）和重绘（Repaint）"></a><strong>3. 重排（Reflow）和重绘（Repaint）</strong></h3><ul><li><strong>重排</strong>：元素几何属性变化（如宽高、位置），触发重新计算布局。  </li><li><strong>重绘</strong>：元素外观变化（如颜色），不涉及布局，直接重新绘制。  </li><li><strong>优化</strong>：避免频繁操作样式，使用 <code>transform</code>&#x2F;<code>opacity</code>（触发 GPU 加速，跳过重排）。</li></ul><hr><h3 id="4-闭包（Closure）"><a href="#4-闭包（Closure）" class="headerlink" title="4. 闭包（Closure）"></a><strong>4. 闭包（Closure）</strong></h3><ul><li><strong>定义</strong>：函数嵌套时，内层函数访问外层作用域的变量，即使外层函数已执行完毕。  </li><li><strong>作用</strong>：封装私有变量、延长变量生命周期。  </li><li><strong>内存泄漏风险</strong>：未手动释放的闭包变量会常驻内存（如未清除的 DOM 事件引用）。</li></ul><hr><h3 id="5-内存泄漏其他原因"><a href="#5-内存泄漏其他原因" class="headerlink" title="5. 内存泄漏其他原因"></a><strong>5. 内存泄漏其他原因</strong></h3><ul><li><strong>未清除的定时器</strong>（<code>setInterval</code>）。  </li><li><strong>游离的 DOM 引用</strong>（删除 DOM 后仍保留变量引用）。  </li><li><strong>全局变量滥用</strong>（未用 <code>let/const</code> 声明）。  </li><li><strong>未解绑的事件监听</strong>（尤其重复绑定时）。</li></ul><hr><h3 id="6-深拷贝与浅拷贝"><a href="#6-深拷贝与浅拷贝" class="headerlink" title="6. 深拷贝与浅拷贝"></a><strong>6. 深拷贝与浅拷贝</strong></h3><ul><li><strong>浅拷贝</strong>：仅复制一层属性，引用类型仍共享地址（如 <code>Object.assign()</code>、展开运算符）。  </li><li><strong>深拷贝</strong>：递归复制所有层级，新旧对象完全独立（需处理循环引用）。</li></ul><hr><h3 id="7-实现深拷贝"><a href="#7-实现深拷贝" class="headerlink" title="7. 实现深拷贝"></a><strong>7. 实现深拷贝</strong></h3><ul><li>**<code>JSON.parse(JSON.stringify())</code>**：简单但无法处理函数、<code>undefined</code>、循环引用。  </li><li><strong>递归手动实现</strong>：遍历对象属性，区分基本&#x2F;引用类型，处理数组和循环引用。  </li><li><strong>库函数</strong>：使用 Lodash 的 <code>_.cloneDeep()</code>。</li></ul><h3 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h3><p>Object.assign()</p><hr><h3 id="8-缓存策略"><a href="#8-缓存策略" class="headerlink" title="8. 缓存策略"></a><strong>8. 缓存策略</strong></h3><p><strong>本地存储 (Local Storage &amp; Session Storage)</strong><br>localStorage： 将数据存储在用户的本地浏览器中，没有过期时间（除非用户手动清除）。</p><p>sessionStorage： 将数据存储在用户的当前会话中，关闭浏览器标签页或窗口后，数据会被清除。</p><p>IndexedDB: 一个更大更强大的客户端存储方案,用于在浏览器中存储大量结构化数据</p><p><strong>CDN 缓存</strong><br>CDN（内容分发网络）将网站的静态资源（如图片、CSS、JavaScript）缓存到全球各地的边缘节点上。当用户访问网站时，CDN 会从离用户最近的节点提供资源，加快访问速度，降低源服务器的负载。</p><p>优点：</p><p>加速静态资源访问。</p><p>降低源服务器负载。</p><p>提高网站的可用性。</p><p>缺点：</p><p>需要付费。</p><p>缓存更新可能存在延迟。</p><hr><h3 id="9-ES6-常用特性"><a href="#9-ES6-常用特性" class="headerlink" title="9. ES6 常用特性"></a><strong>9. ES6 常用特性</strong></h3><ul><li><strong>变量声明</strong>：<code>let</code>&#x2F;<code>const</code>（块级作用域）。  </li><li><strong>箭头函数</strong>：简化写法，无自身 <code>this</code>。  </li><li><strong>解构赋值</strong>：<code>const &#123; a, b &#125; = obj</code>。  </li><li><strong>模块化</strong>：<code>import</code>&#x2F;<code>export</code>。  </li><li><strong>Promise</strong>：异步编程，链式调用。  </li><li><strong>Class</strong>：语法糖，替代构造函数。</li></ul><hr><h3 id="10-Vue2-与-Vue3-区别"><a href="#10-Vue2-与-Vue3-区别" class="headerlink" title="10. Vue2 与 Vue3 区别"></a><strong>10. Vue2 与 Vue3 区别</strong></h3><h4 id="1-响应式原理"><a href="#1-响应式原理" class="headerlink" title="1. 响应式原理"></a><strong>1. 响应式原理</strong></h4><table><thead><tr><th><strong>Vue2</strong></th><th><strong>Vue3</strong></th></tr></thead><tbody><tr><td>使用 <code>Object.defineProperty</code> 劫持对象属性（需递归遍历对象）</td><td>使用 <code>Proxy</code> 代理整个对象，直接监听动态属性变化</td></tr><tr><td><strong>缺陷</strong>：无法检测对象属性的新增&#x2F;删除、数组索引修改</td><td><strong>优势</strong>：天然支持动态属性、性能更优</td></tr></tbody></table><hr><h4 id="2-组合式-API"><a href="#2-组合式-API" class="headerlink" title="2. 组合式 API"></a><strong>2. 组合式 API</strong></h4><ul><li><strong>Vue2</strong>：<code>Options API</code>（分散在 <code>data</code>、<code>methods</code>、<code>computed</code> 中）。  </li><li><strong>Vue3</strong>：<code>Composition API</code>（通过 <code>setup()</code> 集中管理逻辑，支持逻辑复用）。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue3 示例</span><br><span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> double = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> &#123; count, double &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><hr><h4 id="3-性能优化-1"><a href="#3-性能优化-1" class="headerlink" title="3. 性能优化"></a><strong>3. 性能优化</strong></h4><table><thead><tr><th><strong>优化点</strong></th><th><strong>Vue2</strong></th><th><strong>Vue3</strong></th></tr></thead><tbody><tr><td><strong>虚拟 DOM</strong></td><td>全量对比</td><td>静态标记 + 靶向更新（Diff 更高效）</td></tr><tr><td><strong>Tree-shaking</strong></td><td>不支持</td><td>按需引入 API，打包体积更小</td></tr><tr><td><strong>静态提升</strong></td><td>无</td><td>将静态节点提取为常量，减少渲染开销</td></tr></tbody></table><hr><h4 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a><strong>4. 生命周期</strong></h4><table><thead><tr><th><strong>Vue2</strong></th><th><strong>Vue3</strong>（Composition API）</th></tr></thead><tbody><tr><td><code>beforeDestroy</code></td><td><code>onBeforeUnmount</code></td></tr><tr><td><code>destroyed</code></td><td><code>onUnmounted</code></td></tr><tr><td>-</td><td><code>onServerPrefetch</code>（SSR）</td></tr></tbody></table><hr><h4 id="5-新特性"><a href="#5-新特性" class="headerlink" title="5. 新特性"></a><strong>5. 新特性</strong></h4><ul><li><strong>Fragment</strong>：支持多根节点模板（无需包裹 <code>&lt;div&gt;</code>）。  </li><li><strong>Teleport</strong>：将组件渲染到任意 DOM 节点（如弹窗全局定位）。  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br>  ```  <br>- **Suspense**：异步组件加载状态管理。  <br>- **自定义渲染器**：支持非 DOM 环境（如小程序、Canvas）。  <br><br>---<br><br>#### **6. TypeScript 支持**  <br>- **Vue2**：需通过 `Vue.extend` 或 Class API 支持，类型推断较弱。  <br>- **Vue3**：完全用 TypeScript 重写，提供完整的类型定义。  <br><br><br><br>### **2. Vuex 核心概念与函数**  <br>- **作用**：集中管理 Vue 应用的共享状态，解决组件间复杂数据传递问题。  <br>- **核心函数/概念**：  <br>  - **`state`**：存储状态数据（响应式）。  <br>  - **`getters`**：计算属性，对 `state` 加工（类似 `computed`）。  <br>  - **`mutations`**：唯一修改 `state` 的方式（**同步**操作），通过 `commit` 触发。  <br>  - **`actions`**：处理异步逻辑（如请求数据），通过 `dispatch` 触发，内部调用 `commit`。  <br>  - **`modules`**：拆分复杂 store 为多个模块（每个模块独立拥有自己的 state、mutations 等）。  <br><br>---<br><br>### **3. 无限加载性能优化** ：懒加载 <br>- **数据拼接**：分页加载，每次滚动到底部时追加新数据（`list = [...list, ...newData]`）。  <br>- **性能关键点**：  <br>  1. **虚拟滚动**：仅渲染可视区域内的 DOM，减少节点数量（如 `vue-virtual-scroller`）。  <br>  2. **防抖/节流**：避免频繁触发滚动事件。  <br>  3. **复用 DOM**：使用 `v-for` 时设置唯一 `key`，帮助 Vue 高效复用节点。  <br>  4. **内存释放**：移除不可见数据或分页缓存，避免内存泄漏。  <br><br>---<br><br>### **4. 图片懒加载实现**  <br>- **方案一：Intersection Observer API**（推荐，性能好）  <br>  ```javascript<br>  const observer = new IntersectionObserver((entries) =&gt; &#123;<br>    entries.forEach(entry =&gt; &#123;<br>      if (entry.isIntersecting) &#123;<br>        const img = entry.target;<br>        img.src = img.dataset.src; // 替换 data-src 为实际 src<br>        observer.unobserve(img);   // 加载后停止观察<br>      &#125;<br>    &#125;);<br>  &#125;);<br>  document.querySelectorAll(&#x27;img[data-src]&#x27;).forEach(img =&gt; observer.observe(img));<br>  ```  <br>- **方案二：滚动监听 + getBoundingClientRect**  <br>  ```javascript<br>  window.addEventListener(&#x27;scroll&#x27;, throttle(() =&gt; &#123;<br>    const imgs = document.querySelectorAll(&#x27;img[data-src]&#x27;);<br>    imgs.forEach(img =&gt; &#123;<br>      if (img.getBoundingClientRect().top &lt; window.innerHeight) &#123;<br>        img.src = img.dataset.src;<br>      &#125;<br>    &#125;);<br>  &#125;, 200));<br>  ```  <br>- **HTML 原生支持**：`<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span>&gt;</span>`（部分浏览器支持）。<br><br>---<br><br><br>让我来介绍一下 JavaScript 中的同步与异步,特别是 ES6 中的 async/await 特性:<br><br>### 同步与异步的区别<br><br>同步:<br>- 代码按顺序执行,前一个任务完成后才执行下一个<br>- 会阻塞主线程<br>- 适用于简单运算<br><br>异步:<br>- 不会阻塞主线程<br>- 适用于网络请求、文件读写等耗时操作<br>- 主要解决方案包括:回调函数、Promise、async/await<br><br>#### async/await 使用<br><br>基本语法:<br>```javascript<br>async function getData() &#123;<br>  try &#123;<br>    // await 后面接 Promise<br>    const response = await fetch(&#x27;/api/data&#x27;);<br>    const data = await response.json();<br>    return data;<br>  &#125; catch(err) &#123;<br>    console.error(err);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>主要特点:</p><ul><li>async 函数返回 Promise 对象</li><li>await 只能在 async 函数内使用</li><li>让异步代码写法更接近同步代码</li><li>配合 try&#x2F;catch 进行错误处理</li></ul><h4 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h4><ol><li><p>接口请求:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUsers</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/users&#x27;</span>);<br>  <span class="hljs-keyword">const</span> orders = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/orders&#x27;</span>); <br>  <span class="hljs-keyword">return</span> &#123; users, orders &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>并发请求:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMultiData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// Promise.all 并发执行</span><br>  <span class="hljs-keyword">const</span> [users, orders] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/users&#x27;</span>),<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/orders&#x27;</span>)<br>  ]);<br>  <span class="hljs-keyword">return</span> &#123; users, orders &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-原生-JS-与-Vue-的同步异步"><a href="#6-原生-JS-与-Vue-的同步异步" class="headerlink" title="6. 原生 JS 与 Vue 的同步异步"></a><strong>6. 原生 JS 与 Vue 的同步异步</strong></h3><ul><li><strong>原生 JS</strong>：  <ul><li>同步：普通代码执行。  </li><li>异步：<code>setTimeout</code>、<code>XMLHttpRequest</code>、事件回调（如点击事件）。</li></ul></li><li><strong>Vue 的异步</strong>：  <ul><li>**<code>Vue.nextTick()</code>**：在 DOM 更新后触发回调（微任务）。  </li><li><strong>响应式更新队列</strong>：Vue 将数据变更批量处理，异步更新 DOM。</li></ul></li></ul><hr><h3 id="7-Promise-方法"><a href="#7-Promise-方法" class="headerlink" title="7. Promise 方法"></a><strong>7. Promise 方法</strong></h3><ul><li><strong>实例方法</strong>：  <ul><li>**<code>then()</code>**：处理成功状态。  </li><li>**<code>catch()</code>**：处理失败状态。  </li><li>**<code>finally()</code>**：无论成功&#x2F;失败都会执行。</li></ul></li><li><strong>静态方法</strong>：  <ul><li>**<code>Promise.all()</code>**：所有成功则成功，任一失败则失败。  </li><li>**<code>Promise.race()</code>**：取第一个完成的结果（无论成功&#x2F;失败）。  </li><li>**<code>Promise.allSettled()</code>**：等待所有完成，返回结果数组。  </li><li>**<code>Promise.any()</code>**：取第一个成功的 Promise（忽略失败）。</li></ul></li></ul><hr><h3 id="8-async-await-原理"><a href="#8-async-await-原理" class="headerlink" title="8. async&#x2F;await 原理"></a><strong>8. async&#x2F;await 原理</strong></h3><ul><li><strong>本质</strong>：Generator 函数的语法糖，结合 Promise 实现同步写法。  </li><li><strong>原理</strong>：  <ul><li><code>async</code> 函数返回一个 Promise。  </li><li><code>await</code> 会暂停代码执行，等待 Promise 完成（底层通过 Generator 的 <code>yield</code> 实现）。  </li><li>错误处理：用 <code>try/catch</code> 捕获 <code>await</code> 后的异常。</li></ul></li></ul><hr><h3 id="9-Git-基础命令"><a href="#9-Git-基础命令" class="headerlink" title="9. Git 基础命令"></a><strong>9. Git 基础命令</strong></h3><ul><li><strong>仓库操作</strong>：  <ul><li><code>git clone [url]</code>：克隆远程仓库。  </li><li><code>git init</code>：初始化本地仓库。</li></ul></li><li><strong>提交代码</strong>：  <ul><li><code>git add .</code>：添加所有修改到暂存区。  </li><li><code>git commit -m &quot;msg&quot;</code>：提交暂存区内容。  </li><li><code>git push</code>：推送到远程分支。</li></ul></li><li><strong>分支管理</strong>：  <ul><li><code>git branch</code>：查看分支。  </li><li><code>git checkout -b [branch]</code>：创建并切换分支。  </li><li><code>git merge [branch]</code>：合并分支。</li></ul></li><li><strong>其他</strong>：  <ul><li><code>git pull</code>：拉取远程更新。  </li><li><code>git status</code>：查看当前状态。  </li><li><code>git log</code>：查看提交历史。</li></ul></li></ul><hr><h3 id="10-TCP、IP、HTTP-的关系"><a href="#10-TCP、IP、HTTP-的关系" class="headerlink" title="10. TCP、IP、HTTP 的关系"></a><strong>10. TCP、IP、HTTP 的关系</strong></h3><ul><li><strong>IP（网络层）</strong>：负责路由寻址：将数据包从源地址发送到目标地址（通过 IP 地址寻址）。  </li><li><strong>TCP（传输层）</strong>：在 IP 基础上提供可靠传输（三次握手建立连接、数据校验保证数据完整性和顺序、通过端口号区分应用）。  </li><li><strong>HTTP（应用层）</strong>：基于 TCP&#x2F;IP 的应用层协议，定义客户端与服务器通信格式（如请求头、响应状态码）。 </li><li>HTTP 是无状态的应用层协议</li><li>各层协议相互独立</li></ul><hr><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP 三次握手(Three-way Handshake)是建立连接的过程,我来详细解释:</p><h3 id="TCP-三次握手流程"><a href="#TCP-三次握手流程" class="headerlink" title="TCP 三次握手流程"></a>TCP 三次握手流程</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">客户端                      服务端<br>   |<span class="hljs-string">                         </span>|<br>   |<span class="hljs-string">        SYN=1           </span>|<br>   |<span class="hljs-string">     seq=x              </span>|<br>   |<span class="hljs-string"> ------------------&gt;    </span>|<span class="hljs-string"> 第一次握手</span><br><span class="hljs-string">   </span>|<span class="hljs-string">                        </span>|<br>   |<span class="hljs-string">     SYN=1, ACK=1      </span>|<br>   |<span class="hljs-string">     seq=y, ack=x+1    </span>|<br>   |<span class="hljs-string"> &lt;------------------    </span>|<span class="hljs-string"> 第二次握手</span><br><span class="hljs-string">   </span>|<span class="hljs-string">                        </span>|<br>   |<span class="hljs-string">        ACK=1          </span>|<br>   |<span class="hljs-string">     seq=x+1, ack=y+1  </span>|<br>   |<span class="hljs-string"> ------------------&gt;    </span>|<span class="hljs-string"> 第三次握手</span><br><span class="hljs-string">   </span>|<span class="hljs-string">                        </span>|<br></code></pre></td></tr></table></figure><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ol><li>第一次握手 (SYN)</li></ol><ul><li>客户端发送 SYN 包</li><li>SYN&#x3D;1, seq&#x3D;x(随机数)</li><li>客户端进入 SYN_SENT 状态</li></ul><ol start="2"><li>第二次握手 (SYN + ACK)</li></ol><ul><li>服务端收到 SYN 包</li><li>发送 SYN+ACK 包</li><li>SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y(随机数), ack&#x3D;x+1</li><li>服务端进入 SYN_RECV 状态</li></ul><ol start="3"><li>第三次握手 (ACK)</li></ol><ul><li>客户端收到 SYN+ACK 包</li><li>发送 ACK 包</li><li>ACK&#x3D;1, seq&#x3D;x+1, ack&#x3D;y+1</li><li>双方进入 ESTABLISHED 状态</li></ul><h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手?"></a>为什么需要三次握手?</h3><ol><li>确认双方收发能力都正常</li><li>同步双方序列号</li><li>防止历史连接的建立</li><li>避免资源浪费</li></ol><p>这就是所谓的”三次握手”,建立可靠的 TCP 连接必经的过程。</p><hr><h3 id="1-Vue-生命周期钩子函数的作用"><a href="#1-Vue-生命周期钩子函数的作用" class="headerlink" title="1. Vue 生命周期钩子函数的作用"></a><strong>1. Vue 生命周期钩子函数的作用</strong></h3><table><thead><tr><th><strong>钩子函数</strong></th><th><strong>执行时机</strong></th><th><strong>典型操作</strong></th></tr></thead><tbody><tr><td><strong>beforeCreate</strong></td><td>实例初始化后，数据观测前</td><td>无法访问 <code>data</code> 和 <code>methods</code>，极少使用</td></tr><tr><td><strong>created</strong></td><td>实例创建完成，DOM 未生成</td><td>发起异步请求、初始化数据（如 API 调用）</td></tr><tr><td><strong>beforeMount</strong></td><td>挂载开始前，首次调用 <code>render</code> 函数</td><td>极少使用</td></tr><tr><td><strong>mounted</strong></td><td>DOM 挂载完成</td><td>操作 DOM、集成第三方库（地图、图表）</td></tr><tr><td><strong>beforeUpdate</strong></td><td>数据变化后，DOM 更新前</td><td>获取更新前的 DOM 状态</td></tr><tr><td><strong>updated</strong></td><td>DOM 更新后</td><td>操作更新后的 DOM（避免修改数据）</td></tr><tr><td><strong>beforeUnmount</strong></td><td>实例销毁前（Vue3）</td><td><strong>清除定时器、解绑事件监听、销毁第三方实例</strong></td></tr><tr><td><strong>unmounted</strong></td><td>实例销毁后（Vue3）</td><td>清理残留引用</td></tr></tbody></table><hr><h3 id="2-销毁定时器的原因与方式"><a href="#2-销毁定时器的原因与方式" class="headerlink" title="2. 销毁定时器的原因与方式"></a><strong>2. 销毁定时器的原因与方式</strong></h3><ul><li><strong>为什么销毁</strong>：防止组件销毁后定时器仍在执行，导致内存泄漏或操作已销毁的 DOM。  </li><li><strong>如何销毁</strong>：在 <code>beforeUnmount</code>（Vue3）或 <code>beforeDestroy</code>（Vue2）中清除。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span> &#125;;<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;, <span class="hljs-number">1000</span>);<br>  &#125;,<br>  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>); <span class="hljs-comment">// 销毁定时器</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="3-Vue-响应式原理"><a href="#3-Vue-响应式原理" class="headerlink" title="3. Vue 响应式原理"></a><strong>3. Vue 响应式原理</strong></h3><ul><li><strong>Vue2</strong>：通过 <code>Object.defineProperty</code> 递归遍历对象，劫持属性 getter&#x2F;setter，在 <strong>get</strong> 中收集依赖（Watcher），在 <strong>set</strong> 中通知更新。  </li><li><strong>Vue3</strong>：使用 <code>Proxy</code> 代理对象，直接监听整个对象，支持动态新增属性。</li></ul><hr><h3 id="4-Vue2-数组的响应式处理"><a href="#4-Vue2-数组的响应式处理" class="headerlink" title="4. Vue2 数组的响应式处理"></a><strong>4. Vue2 数组的响应式处理</strong></h3><ul><li><strong>方法重写</strong>：覆盖数组的 <code>push</code>、<code>pop</code>、<code>splice</code> 等 7 个方法，触发视图更新。  </li><li><strong>局限性</strong>：直接通过索引修改项（如 <code>arr[0] = 1</code>）或修改长度（<code>arr.length = 0</code>）不会触发更新。  </li><li><strong>解决方案</strong>：使用 <code>Vue.set(arr, index, value)</code> 或 <code>arr.splice()</code>。</li></ul><hr><h3 id="5-MVVM-架构理解"><a href="#5-MVVM-架构理解" class="headerlink" title="5. MVVM 架构理解"></a><strong>5. MVVM 架构理解</strong></h3><ul><li><strong>Model</strong>：数据层（如 Vue 的 <code>data</code>）。  </li><li><strong>View</strong>：UI 层（如模板）。  </li><li><strong>ViewModel</strong>：连接 Model 和 View，实现数据绑定（如 Vue 实例）。  </li><li><strong>核心</strong>：数据驱动视图，自动同步数据与 UI（通过响应式系统）。</li></ul><hr><h3 id="6-v-model-原理"><a href="#6-v-model-原理" class="headerlink" title="6. v-model 原理"></a><strong>6. <code>v-model</code> 原理</strong></h3><ul><li><strong>本质</strong>：语法糖，结合 <code>:value</code> 和 <code>@input</code>。  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;msg = $event.target.value&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 等价于 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br>  ```  <br>- **自定义组件**：通过 `modelValue` 属性和 `update:modelValue` 事件实现。  <br><br>---<br><br>### **7. `$nextTick`**  <br>- **作用**：在 DOM 更新后执行回调（Vue 异步更新队列）。  <br>- **场景**：操作更新后的 DOM。  <br>  ```javascript<br>  this.msg = &#x27;新消息&#x27;;<br>  this.$nextTick(() =&gt; &#123;<br>    console.log(document.getElementById(&#x27;text&#x27;).innerHTML); // 获取最新 DOM<br>  &#125;);<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="8-Vue2-的-data-为什么是函数"><a href="#8-Vue2-的-data-为什么是函数" class="headerlink" title="8. Vue2 的 data 为什么是函数"></a><strong>8. Vue2 的 <code>data</code> 为什么是函数</strong></h3><ul><li><strong>原因</strong>：组件可能被复用，函数返回独立对象，避免多个实例共享同一数据对象。  </li><li><strong>错误写法</strong>（对象形式）：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125; <span class="hljs-comment">// 所有实例共享同一个 count！</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="9-闭包与内存泄漏"><a href="#9-闭包与内存泄漏" class="headerlink" title="9. 闭包与内存泄漏"></a><strong>9. 闭包与内存泄漏</strong></h3><ul><li><strong>闭包</strong>：函数嵌套时，内层函数引用外层变量，导致外层变量无法释放。  </li><li><strong>内存泄漏场景</strong>：未清除的定时器、DOM 事件引用、全局变量。</li></ul><hr><h3 id="10-深拷贝与实现"><a href="#10-深拷贝与实现" class="headerlink" title="10. 深拷贝与实现"></a><strong>10. 深拷贝与实现</strong></h3><ul><li><strong>浅拷贝</strong>：<code>Object.assign()</code>、展开运算符（仅复制一层）。  </li><li><strong>深拷贝实现</strong>：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;<br>  <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(obj)) <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(obj); <span class="hljs-comment">// 处理循环引用</span><br>  <span class="hljs-keyword">const</span> clone = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br>  map.<span class="hljs-title function_">set</span>(obj, clone);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    clone[key] = <span class="hljs-title function_">deepClone</span>(obj[key], map);<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="11-JS-数据类型"><a href="#11-JS-数据类型" class="headerlink" title="11. JS 数据类型"></a><strong>11. JS 数据类型</strong></h3><ul><li><strong>基本类型</strong>：<code>Undefined</code>、<code>Null</code>、Boolean、Number、String、Symbol（ES6）、BigInt（ES2020）。  </li><li><strong>引用类型</strong>：Object（包括 Array、Function、Date 等）。</li></ul><hr><h3 id="12-判断数组"><a href="#12-判断数组" class="headerlink" title="12. 判断数组"></a><strong>12. 判断数组</strong></h3><ul><li><strong>方法 1</strong>：<code>Array.isArray(arr)</code>（推荐）。  </li><li><strong>方法 2</strong>：<code>Object.prototype.toString.call(arr) === &#39;[object Array]&#39;</code>。  </li><li><strong>方法 3</strong>：<code>arr instanceof Array</code>（不适用于多窗口环境）。</li></ul><hr><p>以上答案覆盖高频考点，代码示例可直接用于面试手写环节，原理需结合理解阐述。</p><h3 id="11-正方形交互场景题"><a href="#11-正方形交互场景题" class="headerlink" title="11. 正方形交互场景题"></a><strong>11. 正方形交互场景题</strong></h3><p><strong>实现代码</strong>：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;square&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px; height: 100px; background: blue;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> square = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;square&#x27;</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> isInside = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 鼠标移入/移出</span></span><br><span class="language-javascript">  square.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;鼠标进入正方形&#x27;</span>);</span><br><span class="language-javascript">    isInside = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  square.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;鼠标离开正方形&#x27;</span>);</span><br><span class="language-javascript">    isInside = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 点击正方形内外</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> === square || square.<span class="hljs-title function_">contains</span>(e.<span class="hljs-property">target</span>)) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了正方形内部&#x27;</span>);</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了正方形外部&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="12-获取标签元素的方式"><a href="#12-获取标签元素的方式" class="headerlink" title="12. 获取标签元素的方式"></a><strong>12. 获取标签元素的方式</strong></h3><ul><li><strong>ID 获取</strong>：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;id&#x27;</span>); <span class="hljs-comment">// 返回单个元素</span><br>  <span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">- **类名获取**：  </span><br><span class="hljs-string">  `</span><span class="hljs-string">``</span>javascript<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class&#x27;</span>); <span class="hljs-comment">// 返回 HTMLCollection（动态）</span><br>  <span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">- **标签名获取**：  </span><br><span class="hljs-string">  `</span><span class="hljs-string">``</span>javascript<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>); <span class="hljs-comment">// 返回 HTMLCollection</span><br>  <span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">- **CSS 选择器**：  </span><br><span class="hljs-string">  `</span><span class="hljs-string">``</span>javascript<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#id&#x27;</span>);        <span class="hljs-comment">// 返回第一个匹配元素</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.class&#x27;</span>);  <span class="hljs-comment">// 返回 NodeList（静态）</span><br>  <span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">- **Vue 中**：通过 `</span>ref<span class="hljs-string">` 属性获取组件或 DOM 元素。  </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">### 1. 代码问题定位</span><br><span class="hljs-string"></span><br><span class="hljs-string">主要方法:</span><br><span class="hljs-string">- console.log/debugger 打点调试</span><br><span class="hljs-string">- 浏览器开发者工具断点调试</span><br><span class="hljs-string">- 查看浏览器控制台报错信息和堆栈</span><br><span class="hljs-string">- 使用 Vue Devtools 调试 Vue 组件和状态</span><br><span class="hljs-string">- 代码版本回溯,查看 git 提交记录定位问题代码</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 2. 浏览器调试技巧</span><br><span class="hljs-string"></span><br><span class="hljs-string">常用工具面板:</span><br><span class="hljs-string">- Elements: 检查和调试页面元素和样式</span><br><span class="hljs-string">- Console: 查看日志和错误信息</span><br><span class="hljs-string">- Sources: 断点调试 JavaScript 代码</span><br><span class="hljs-string">- Network: 分析网络请求和响应</span><br><span class="hljs-string">- Performance: 分析页面性能瓶颈</span><br><span class="hljs-string">- Application: 查看存储和缓存</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 3. 抓包经验</span><br><span class="hljs-string"></span><br><span class="hljs-string">工具使用:</span><br><span class="hljs-string">- Charles: 常用于移动端调试,可以查看和修改 HTTP/HTTPS 请求</span><br><span class="hljs-string">- Fiddler: Windows 平台常用抓包工具</span><br><span class="hljs-string">- Chrome DevTools 的 Network 面板:分析请求响应和性能</span><br><span class="hljs-string"></span><br><span class="hljs-string">主要用于:</span><br><span class="hljs-string">- 分析接口请求/响应数据</span><br><span class="hljs-string">- 调试移动端页面</span><br><span class="hljs-string">- 排查网络相关问题</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 为什么使用前端框架，帮我们解决什么问题</span><br><span class="hljs-string">- 他提供了很多api，同时组件化开发使得代码复用性提高,便于团队开发、维护和测试；团队协作更容易，可以极大提升前端开发的人员的效率</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 单页面和多页面有哪些区别，单页面有哪些好处；</span><br><span class="hljs-string">让我来解释单页面应用(SPA)和多页面应用(MPA)的区别：</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 单页面应用(SPA)</span><br><span class="hljs-string"></span><br><span class="hljs-string">优点：</span><br><span class="hljs-string">- 用户体验好，切换页面无刷新</span><br><span class="hljs-string">- 前后端分离，开发效率高</span><br><span class="hljs-string">- 可以实现更丰富的交互效果</span><br><span class="hljs-string">- 更好的缓存机制</span><br><span class="hljs-string"></span><br><span class="hljs-string">缺点：</span><br><span class="hljs-string">- 首屏加载时间较长</span><br><span class="hljs-string">- SEO 不友好(可通过 SSR 解决)</span><br><span class="hljs-string">- 需要额外的路由管理</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 多页面应用(MPA)</span><br><span class="hljs-string"></span><br><span class="hljs-string">优点：</span><br><span class="hljs-string">- 首屏加载快</span><br><span class="hljs-string">- SEO 友好</span><br><span class="hljs-string">- 适合简单的展示型网站</span><br><span class="hljs-string">- 开发门槛低</span><br><span class="hljs-string"></span><br><span class="hljs-string">缺点：</span><br><span class="hljs-string">- 页面切换需要刷新</span><br><span class="hljs-string">- 前后端耦合度高</span><br><span class="hljs-string">- 服务器压力大</span><br><span class="hljs-string">- 用户体验相对较差</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 主要区别</span><br><span class="hljs-string"></span><br><span class="hljs-string">1. **资源加载**</span><br><span class="hljs-string">- SPA: 第一次加载所有必需资源</span><br><span class="hljs-string">- MPA: 每个页面都要重新加载资源</span><br><span class="hljs-string"></span><br><span class="hljs-string">2. **页面切换**</span><br><span class="hljs-string">- SPA: 路由跳转，不刷新页面</span><br><span class="hljs-string">- MPA: 传统链接跳转，需要刷新</span><br><span class="hljs-string"></span><br><span class="hljs-string">3. **数据传递**</span><br><span class="hljs-string">- SPA: 可以维护全局状态</span><br><span class="hljs-string">- MPA: 需要 cookie/storage 等方式</span><br><span class="hljs-string"></span><br><span class="hljs-string">4. **开发方式**</span><br><span class="hljs-string">- SPA: 前后端分离</span><br><span class="hljs-string">- MPA: 前后端耦合</span><br><span class="hljs-string"></span><br><span class="hljs-string">### vue生命周期，绑定dom事件和网络请求分别在哪个生命周期里</span><br><span class="hljs-string"></span><br><span class="hljs-string">让我来介绍 Vue 的生命周期钩子函数：</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 主要生命周期钩子</span><br><span class="hljs-string"></span><br><span class="hljs-string">1. **beforeCreate**</span><br><span class="hljs-string">- 实例创建前</span><br><span class="hljs-string">- 此时无法访问数据和方法</span><br><span class="hljs-string"></span><br><span class="hljs-string">2. **created**</span><br><span class="hljs-string">- 实例创建完成</span><br><span class="hljs-string">- 可以访问数据和方法</span><br><span class="hljs-string">- 适合进行**网络请求**，因为此时可以操作数据</span><br><span class="hljs-string"></span><br><span class="hljs-string">3. **beforeMount**</span><br><span class="hljs-string">- 挂载前</span><br><span class="hljs-string">- 模板编译完成，但还未挂载到 DOM</span><br><span class="hljs-string"></span><br><span class="hljs-string">4. **mounted**</span><br><span class="hljs-string">- 挂载完成</span><br><span class="hljs-string">- DOM 已经渲染完成</span><br><span class="hljs-string">- 适合进行**DOM 操作和事件绑定**</span><br><span class="hljs-string"></span><br><span class="hljs-string">5. **beforeUpdate**</span><br><span class="hljs-string">- 数据更新前</span><br><span class="hljs-string">- 可以在更新前访问现有的 DOM</span><br><span class="hljs-string"></span><br><span class="hljs-string">6. **updated**</span><br><span class="hljs-string">- 数据更新后</span><br><span class="hljs-string">- DOM 已经更新完成</span><br><span class="hljs-string"></span><br><span class="hljs-string">7. **beforeUnmount**</span><br><span class="hljs-string">- 组件卸载前</span><br><span class="hljs-string">- 适合移除事件监听器等清理工作</span><br><span class="hljs-string"></span><br><span class="hljs-string">8. **unmounted**</span><br><span class="hljs-string">- 组件卸载完成</span><br><span class="hljs-string"></span><br><span class="hljs-string">#@## 最佳实践</span><br><span class="hljs-string"></span><br><span class="hljs-string">1. **网络请求放在 created 中**：</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>javascript<br><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 发起API请求</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchData</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>DOM 操作和事件绑定放在 mounted 中</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// DOM操作</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>);<br>&#125;<br><br><span class="hljs-comment">// 记得在组件销毁前解绑</span><br><span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>).<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>created: 数据初始化、异步请求</li><li>mounted: DOM操作、第三方库初始化</li><li>beforeUnmount: 清理定时器、解绑事件</li><li>updated: 处理数据更新后的DOM操作</li></ul><p><a href="https://vuejs.org/guide/essentials/lifecycle.html">参考 Vue.js 官方文档</a></p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ul><li>分支管理<ul><li>分支管理一般有feature、dev、master等分支，feature分支是用于开发新功能，dev分支是用于测试，master分支是用于发布；</li></ul></li><li>出现冲突怎么办<ul><li>首先肯定是做好避免冲突的措施，从源头上是最有效的，比如规定每次提交只能提交一个小功能，避免大范围冲突，并且提交的时候一定要按照规范写好提交信息，比如fix~；</li><li>如果发生冲突了，这时候就比较小了，那就直接当事人一起codeView嘛；</li></ul></li></ul><h4 id="11-Git-冲突"><a href="#11-Git-冲突" class="headerlink" title="11. Git 冲突"></a><strong>11. Git 冲突</strong></h4><ul><li><strong>原因</strong>：同一文件在多个分支被修改，合并时无法自动解决差异。  </li><li><strong>解决步骤</strong>：  <ol><li><code>git pull</code> 后出现冲突标记（<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>）。  </li><li>手动编辑文件，保留需要的代码，删除冲突标记。  </li><li><code>git add &lt;file&gt;</code> 标记为已解决。  </li><li><code>git commit</code> 完成合并。</li></ol></li></ul><h3 id="浏览器输入URL到页面展示的全流程"><a href="#浏览器输入URL到页面展示的全流程" class="headerlink" title="浏览器输入URL到页面展示的全流程"></a><strong>浏览器输入URL到页面展示的全流程</strong></h3><hr><h4 id="1-URL-解析与预处理"><a href="#1-URL-解析与预处理" class="headerlink" title="1. URL 解析与预处理"></a><strong>1. URL 解析与预处理</strong></h4><ul><li><strong>协议处理</strong>：自动补全协议（如 <code>http://</code> 或 <code>https://</code>）。  </li><li><strong>编码转换</strong>：处理特殊字符（如空格转为 <code>%20</code>）。  </li><li><strong>HSTS 检查</strong>（仅 HTTPS）：强制使用 HTTPS 连接（若域名在 HSTS 列表中）。</li></ul><hr><h4 id="2-DNS-域名解析"><a href="#2-DNS-域名解析" class="headerlink" title="2. DNS 域名解析"></a><strong>2. DNS 域名解析</strong></h4><ul><li><strong>查询顺序</strong>：  <ol><li>浏览器缓存 → 2. 系统（hosts 文件）缓存 → 3. 路由器缓存 → 4. ISP 的 DNS 服务器 → 5. 递归查询根域名服务器。</li></ol></li><li><strong>优化</strong>：DNS 预解析（<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</code>）。</li></ul><hr><h4 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a><strong>3. 建立 TCP 连接</strong></h4><ul><li><strong>三次握手</strong>：  <ol><li>客户端发送 <code>SYN</code> 包 → 2. 服务端返回 <code>SYN-ACK</code> → 3. 客户端发送 <code>ACK</code>。</li></ol></li><li><strong>HTTPS 加密</strong>：在 TCP 连接后，进行 TLS 握手（交换密钥、验证证书）。</li></ul><hr><h4 id="4-发送-HTTP-请求"><a href="#4-发送-HTTP-请求" class="headerlink" title="4. 发送 HTTP 请求"></a><strong>4. 发送 HTTP 请求</strong></h4><ul><li><strong>请求行</strong>：方法（GET&#x2F;POST）、URL、协议版本。  </li><li><strong>请求头</strong>：<code>Cookie</code>、<code>User-Agent</code>、<code>Accept-*</code> 等。  </li><li><strong>请求体</strong>：POST&#x2F;PUT 时的数据（如表单 JSON）。</li></ul><hr><h4 id="5-服务器处理请求"><a href="#5-服务器处理请求" class="headerlink" title="5. 服务器处理请求"></a><strong>5. 服务器处理请求</strong></h4><ul><li><strong>负载均衡</strong>：请求可能被转发到集群中的某台服务器。  </li><li><strong>后端处理</strong>：执行 API、查询数据库、生成响应（HTML&#x2F;JSON）。  </li><li><strong>返回响应</strong>：状态码（200 OK、404 Not Found）、响应头、响应体。</li></ul><hr><h4 id="6-浏览器解析与渲染"><a href="#6-浏览器解析与渲染" class="headerlink" title="6. 浏览器解析与渲染"></a><strong>6. 浏览器解析与渲染</strong></h4><ol><li><p><strong>构建 DOM 树</strong>：  </p><ul><li>解析 HTML → 生成 Token → 构建 DOM 节点树。  </li><li><strong>遇到 <code>&lt;script&gt;</code> 会阻塞 DOM 解析</strong>（除非标记 <code>async</code>&#x2F;<code>defer</code>）。</li></ul></li><li><p><strong>构建 CSSOM 树</strong>：  </p><ul><li>解析 CSS 样式（内联、外联、<code>&lt;style&gt;</code>）→ 生成 CSSOM 树。</li></ul></li><li><p><strong>合并渲染树（Render Tree）</strong>：  </p><ul><li>结合 DOM 和 CSSOM，排除不可见节点（如 <code>display: none</code>）。</li></ul></li><li><p><strong>布局（Layout&#x2F;Reflow）</strong>：  </p><ul><li>计算每个节点的位置和尺寸（视口大小、盒模型）。</li></ul></li><li><p><strong>绘制（Paint）与合成（Composite）</strong>：  </p><ul><li>将渲染树转为屏幕像素（分层绘制 → 合成图层 → GPU 加速）。</li></ul></li></ol><hr><h4 id="7-加载子资源与执行脚本"><a href="#7-加载子资源与执行脚本" class="headerlink" title="7. 加载子资源与执行脚本"></a><strong>7. 加载子资源与执行脚本</strong></h4><ul><li><strong>图片、字体等</strong>：异步加载，可能延迟渲染完成时间。  </li><li><strong>JavaScript 执行</strong>：  <ul><li>触发 <code>DOMContentLoaded</code> 事件（DOM 解析完成）。  </li><li>所有资源加载完成后触发 <code>load</code> 事件。</li></ul></li></ul><hr><h4 id="8-连接关闭与缓存"><a href="#8-连接关闭与缓存" class="headerlink" title="8. 连接关闭与缓存"></a><strong>8. 连接关闭与缓存</strong></h4><ul><li><strong>TCP 连接</strong>：完成请求后可能关闭（<code>Connection: close</code>）或保持复用（HTTP&#x2F;1.1 默认 Keep-Alive）。  </li><li><strong>缓存策略</strong>：  <ul><li><strong>强缓存</strong>：<code>Cache-Control</code>&#x2F;<code>Expires</code>（直接使用本地缓存）。  </li><li><strong>协商缓存</strong>：<code>Last-Modified</code>&#x2F;<code>ETag</code>（向服务器验证缓存有效性）。</li></ul></li></ul><hr><h4 id="关键优化点"><a href="#关键优化点" class="headerlink" title="关键优化点"></a><strong>关键优化点</strong></h4><ul><li><strong>减少 DNS 查询</strong>：使用 DNS 预解析、减少域名数量。  </li><li><strong>TCP 复用</strong>：HTTP&#x2F;2 多路复用、Keep-Alive。  </li><li><strong>压缩资源</strong>：Gzip、Brotli 压缩 HTML&#x2F;CSS&#x2F;JS。  </li><li><strong>关键渲染路径优化</strong>：内联关键 CSS、异步非关键 JS、延迟加载图片。  </li><li><strong>CDN 加速</strong>：静态资源分发到边缘节点。</li></ul><hr><h4 id="流程图概览"><a href="#流程图概览" class="headerlink" title="流程图概览"></a><strong>流程图概览</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">URL</span> → <span class="hljs-variable constant_">DNS</span> → <span class="hljs-variable constant_">TCP</span> → <span class="hljs-variable constant_">HTTP</span> → <span class="hljs-title class_">Server</span> → <span class="hljs-title class_">Response</span> → <span class="hljs-title class_">Parse</span> → <span class="hljs-title class_">Render</span> → <span class="hljs-title class_">Load</span><br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">### keep-alive的原理</span><br><span class="hljs-string"></span><br><span class="hljs-string">keep-alive 是 Vue 的内置组件，用于缓存组件实例，主要用途：</span><br><span class="hljs-string">- 保持组件状态，避免重复渲染</span><br><span class="hljs-string">- 提升性能和用户体验</span><br><span class="hljs-string">- 常用于需要频繁切换的组件场景</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">1. **缓存机制**</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>javascript<br><span class="hljs-comment">// keep-alive 内部实现原理</span><br>&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>  <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 抽象组件</span><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">include</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>],<br>    <span class="hljs-attr">exclude</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>],<br>    <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>]<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>() <span class="hljs-comment">// 用于存储缓存的组件实例</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>生命周期</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 组件被缓存时的生命周期</span><br><span class="hljs-title function_">activated</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 组件被激活时调用</span><br>&#125;,<br><span class="hljs-title function_">deactivated</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 组件被停用时调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ol><li><p><strong>基础用法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;keep-alive&gt;<br>    &lt;component :is=&quot;currentComponent&quot;/&gt;<br>  &lt;/keep-alive&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>条件缓存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;keep-alive :include=&quot;[&#x27;ComponentA&#x27;, &#x27;ComponentB&#x27;]&quot;&gt;<br>    &lt;router-view/&gt;<br>  &lt;/keep-alive&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><strong>缓存策略</strong></li></ol><ul><li>默认缓存所有子组件</li><li>可通过 include&#x2F;exclude 控制缓存组件</li><li>可通过 max 控制最大缓存数量</li></ul><ol start="2"><li><strong>性能优化</strong></li></ol><ul><li>避免重复创建和销毁组件</li><li>减少不必要的 DOM 操作</li><li>保留组件状态</li></ul><ol start="3"><li><strong>注意事项</strong></li></ol><ul><li>只能有一个直接子组件</li><li>不能和 v-show 一起使用</li><li>需要给缓存的组件设置 name 属性</li></ul><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>让我来解释事件冒泡(Event Bubbling)的概念和应用：</p><h3 id="事件冒泡原理"><a href="#事件冒泡原理" class="headerlink" title="事件冒泡原理"></a>事件冒泡原理</h3><p>事件冒泡是指事件从最深的节点开始，逐步向上传播到父节点的过程。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;grandparent&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 第三步：最后触发 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>     <span class="hljs-comment">&lt;!-- 第二步：然后触发 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 第一步：首先触发 --&gt;</span><br>      Click me!<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>事件处理</li></ul><ol><li><p><strong>基本使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加事件监听</span><br>child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child clicked&#x27;</span>);<br>&#125;);<br><br>parent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Parent clicked&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>阻止冒泡</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件继续冒泡</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;只触发 Child&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><ul><li>实际应用</li></ul><ol><li><p><strong>事件委托(代理)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用冒泡实现事件委托</span><br><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>);<br>ul.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了列表项:&#x27;</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>自定义事件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建自定义事件</span><br><span class="hljs-keyword">const</span> customEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&#x27;myEvent&#x27;</span>, &#123;<br>  <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 允许冒泡</span><br>  <span class="hljs-attr">detail</span>: &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span> &#125;<br>&#125;);<br><br><span class="hljs-comment">// 触发自定义事件</span><br>element.<span class="hljs-title function_">dispatchEvent</span>(customEvent);<br></code></pre></td></tr></table></figure></li></ol><ul><li>注意事项</li></ul><ol><li><strong>不是所有事件都冒泡</strong></li></ol><ul><li>focus</li><li>blur</li><li>mouseenter</li><li>mouseleave</li></ul><ol start="2"><li><p><strong>事件捕获</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;捕获阶段&#x27;</span>);<br>&#125;, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// true 表示在捕获阶段处理</span><br></code></pre></td></tr></table></figure></li><li><p><strong>事件流三个阶段</strong></p></li></ol><ul><li><p>捕获阶段（从上到下）</p></li><li><p>目标阶段（到达目标元素）</p></li><li><p>冒泡阶段（从下到上）</p></li><li><p>应用场景</p></li></ul><ol><li>实现事件委托，提高性能</li><li>实现事件广播</li><li>组件通信</li><li>插件开发</li></ol><h3 id="父子组件渲染过程"><a href="#父子组件渲染过程" class="headerlink" title="父子组件渲染过程"></a>父子组件渲染过程</h3><p>让我来解释 Vue 中父子组件的生命周期执行顺序：</p><ul><li>创建过程</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">父 <span class="hljs-keyword">beforeCreate</span><br><span class="hljs-keyword"></span>父 created<br>父 <span class="hljs-keyword">beforeMount</span><br><span class="hljs-keyword"></span>    子 <span class="hljs-keyword">beforeCreate</span><br><span class="hljs-keyword"></span>    子 created<br>    子 <span class="hljs-keyword">beforeMount</span><br><span class="hljs-keyword"></span>    子 mounted<br>父 mounted<br></code></pre></td></tr></table></figure><ul><li><p>更新过程</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">父 <span class="hljs-keyword">beforeUpdate</span><br><span class="hljs-keyword"></span>    子 <span class="hljs-keyword">beforeUpdate</span><br><span class="hljs-keyword"></span>    子 updated<br>父 updated<br></code></pre></td></tr></table></figure></li><li><p>销毁过程</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">父 <span class="hljs-keyword">beforeUnmount</span><br><span class="hljs-keyword"></span>    子 <span class="hljs-keyword">beforeUnmount</span><br><span class="hljs-keyword"></span>    子 unmounted<br>父 unmounted<br></code></pre></td></tr></table></figure></li><li><p>重要特点</p></li></ul><ol><li><strong>创建阶段</strong>：</li></ol><ul><li>created 钩子是从父到子依次执行</li><li>mounted 钩子是从子到父依次执行</li><li>父组件会等待所有子组件挂载完成后，才会执行自身的 mounted 钩子</li></ul><ol start="2"><li><p><strong>Props 传递注意事项</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 推荐在 created 中准备数据</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">propData</span> = <span class="hljs-string">&#x27;data&#x27;</span><br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 不推荐在 mounted 中设置 props</span><br>    <span class="hljs-comment">// 可能导致子组件重复渲染</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">propData</span> = <span class="hljs-string">&#x27;data&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>最佳实践</strong>：</p></li></ol><ul><li>DOM 操作放在 mounted 中</li><li>数据初始化和异步请求放在 created 中</li><li>避免在父组件 mounted 中修改传递给子组件的 props</li></ul><h3 id="跨域问题如何解决"><a href="#跨域问题如何解决" class="headerlink" title="跨域问题如何解决"></a>跨域问题如何解决</h3><p>让我来介绍几种常见的跨域解决方案：</p><ol><li>CORS (跨域资源共享)</li></ol><p>服务端设置响应头:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 服务器端设置</span><br>/app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);  <span class="hljs-comment">// 允许所有域名访问</span><br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;GET, POST&#x27;</span>);  <span class="hljs-comment">// 允许的请求方法</span><br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Content-Type&#x27;</span>);  <span class="hljs-comment">// 允许的请求头</span><br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>Nginx 反向代理</strong><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /api &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://target-domain.com;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-代理服务器"><a href="#2-代理服务器" class="headerlink" title="2. 代理服务器"></a>2. 代理服务器</h4><ol><li><strong>开发环境 (Vue)</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// vue.config.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://target-domain.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-JSONP-仅支持-GET-：利用-标签没有跨域限制的特性，但只支持-GET-请求"><a href="#3-JSONP-仅支持-GET-：利用-标签没有跨域限制的特性，但只支持-GET-请求" class="headerlink" title="3. JSONP (仅支持 GET)：利用 &lt;script&gt; 标签没有跨域限制的特性，但只支持 GET 请求"></a>3. JSONP (仅支持 GET)：利用 <code>&lt;script&gt; 标签没有跨域限制的特性，但只支持 GET 请求</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 前端实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">url, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>  script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://api.example.com/data&#x27;</span>, <span class="hljs-string">&#x27;handleCallback&#x27;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-postMessage"><a href="#4-postMessage" class="headerlink" title="4. postMessage"></a>4. postMessage</h4><p>适用于不同窗口间通信：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 发送消息</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;http://receiver.com&#x27;</span>);<br><br><span class="hljs-comment">// 接收消息</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">origin</span> !== <span class="hljs-string">&#x27;http://sender.com&#x27;</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>CORS 是最推荐的跨域解决方案</li><li>代理方案适合开发环境和生产环境</li><li>JSONP 只支持 GET 请求，已逐渐被淘汰</li><li>需要注意跨域安全性，合理配置允许的域名</li></ol><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC 全名是 Model View Controller 的简写，是模型 (model)－视图 (view)－控制器 (controller) 的缩<br>写<br>在这其中：</p><p>Model （模型）：负责处理数据的逻辑和从数据库存取数据，也就是数据存取<br>View （视图）：负责展示数据，UI界⾯，⽤户交互，也就是⽤户界⾯<br>Controller （控制器）： 处理业务逻辑</p><p>视图层 发送⽤户操作给控制器， 控制器 处理业务逻辑，完成后告诉模型更改状态，模型 将新的的数据<br>发送给视图层，⽤户得到操作的反馈。</p><h3 id="原型链基本概念"><a href="#原型链基本概念" class="headerlink" title="原型链基本概念"></a>原型链基本概念</h3><p>原型链是 JavaScript 实现继承的主要方式，它通过 <code>__proto__</code> 属性将对象连接起来。</p><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-comment">// 原型方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建实例</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>);<br><br><span class="hljs-comment">// 原型链查找过程</span><br>person.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// 张三</span><br><span class="hljs-comment">// person -&gt; Person.prototype -&gt; Object.prototype -&gt; null</span><br></code></pre></td></tr></table></figure><h3 id="原型链特点"><a href="#原型链特点" class="headerlink" title="原型链特点"></a>原型链特点</h3><ol><li><strong>属性查找机制</strong></li></ol><ul><li>先查找对象自身属性</li><li>如果没找到，查找原型</li><li>继续向上查找原型的原型</li><li>直到 null</li></ul><ol start="2"><li><strong>属性设置&#x2F;修改</strong></li></ol><ul><li>总是在对象自身上操作</li><li>不会修改原型上的属性</li></ul><ol start="3"><li><strong>检测方法</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 检查属性是否在原型链上</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> person);  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 检查是否是自身属性</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p><code>nextTick</code>是 Vue 提供的一个全局 API，用于在下次 DOM 更新循环结束之后执行延迟回调。</p><p>主要用途：</p><ol><li><p><strong>确保DOM更新完成</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 修改数据</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;新消息&#x27;</span><br><span class="hljs-comment">// DOM 还未更新</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// 仍然是旧的内容</span><br><br><span class="hljs-comment">// 使用 nextTick 确保 DOM 已更新</span><br><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// DOM 现在已经更新</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// 新消息</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>处理依赖DOM更新的操作</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">updateHeight</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someData</span> = <span class="hljs-string">&#x27;更新数据&#x27;</span><br>    <span class="hljs-comment">// 直接获取高度可能不准确</span><br>    <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 这里能获取到更新后的 DOM 高度</span><br>      <span class="hljs-keyword">const</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myDiv</span>.<span class="hljs-property">offsetHeight</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>工作原理：</p><ol><li>Vue 的响应式系统会将数据的变化缓存在一个队列中</li><li>同一个 “tick” 中的多个数据变更会被批量更新</li><li><code>nextTick</code> 会在队列清空（即 DOM 更新完成）后执行回调</li></ol><p>使用场景：</p><ol><li>需要在 DOM 更新后获取新的 DOM 元素尺寸</li><li>需要在 DOM 更新后进行 DOM 操作</li><li>需要确保某些依赖最新 DOM 状态的操作在 DOM 更新后执行</li></ol><p>注意事项：</p><ol><li><code>nextTick</code> 返回一个 Promise，可以使用 async&#x2F;await 语法</li><li>在 created 生命周期中访问 DOM 时，需要使用 nextTick</li><li>Vue3 中可以直接导入使用：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 使用方式</span><br><span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>()<br><span class="hljs-comment">// 或</span><br><span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 操作</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h3 id="综合场景题"><a href="#综合场景题" class="headerlink" title="综合场景题"></a><strong>综合场景题</strong></h3><p><strong>问题</strong>：如何通过 Node.js 后端生成 3D 场景数据，并通过前端 Three.js 动态渲染？<br><strong>答</strong>：  </p><ol><li><strong>后端</strong>：使用 Node.js + Express 提供 REST API，生成模型坐标、材质等信息（如 JSON 格式）。  </li><li><strong>前端</strong>：通过 <code>fetch</code> 请求数据，动态创建 Three.js 物体：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/scene-data&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>     data.<span class="hljs-property">objects</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> &#123;<br>       <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(obj.<span class="hljs-property">size</span>);<br>       <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: obj.<span class="hljs-property">color</span> &#125;);<br>       <span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);<br>       scene.<span class="hljs-title function_">add</span>(mesh);<br>     &#125;);<br>   &#125;);<br>   <span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string"></span><br><span class="hljs-string">---</span><br><span class="hljs-string"></span><br><span class="hljs-string">#### 3. **原型与继承**</span><br><span class="hljs-string">- **问题**：原型链是什么？如何实现继承？</span><br><span class="hljs-string">  - **答案**：</span><br><span class="hljs-string">    - 原型链是对象通过 `</span>__proto__<span class="hljs-string">` 属性向上查找属性和方法的链式结构。</span><br><span class="hljs-string">    - 继承方式：</span><br><span class="hljs-string">      - **原型继承**：`</span><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<span class="hljs-string">`。</span><br><span class="hljs-string">      - **组合继承**：结合构造函数和原型链（推荐）。</span><br><span class="hljs-string">      - **ES6 类继承**：`</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span><span class="hljs-string">`。</span><br><span class="hljs-string"></span><br><span class="hljs-string">#### 4. **事件循环与异步**</span><br><span class="hljs-string">- **问题**：解释事件循环（Event Loop）及宏任务与微任务的区别。</span><br><span class="hljs-string">  - **答案**：</span><br><span class="hljs-string">    - **事件循环**：JS 单线程通过任务队列处理异步任务。</span><br><span class="hljs-string">    - **执行顺序**：同步代码 → 微任务（`</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">then</span><span class="hljs-string">`、`</span><span class="hljs-title class_">MutationObserver</span><span class="hljs-string">`）→ 宏任务（`</span><span class="hljs-built_in">setTimeout</span><span class="hljs-string">`、`</span><span class="hljs-variable constant_">DOM</span> 事件<span class="hljs-string">`）。</span><br><span class="hljs-string">    - **示例**：`</span><span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span><span class="hljs-string">` 的执行顺序结合微任务队列分析。</span><br><span class="hljs-string"></span><br><span class="hljs-string">#### 5. **手写代码题**</span><br><span class="hljs-string">- **防抖（Debounce）**：限制高频触发（如输入框搜索）。</span><br><span class="hljs-string">  `</span><span class="hljs-string">``</span>javascript<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> timeoutId;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timeoutId);<br>      timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">func</span>(...args), delay);<br>    &#125;;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li><strong>深拷贝</strong>：递归复制对象属性，避免引用共享。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    result[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="二、网络协议基础"><a href="#二、网络协议基础" class="headerlink" title="二、网络协议基础"></a>二、网络协议基础</h3><h4 id="1-HTTP-协议"><a href="#1-HTTP-协议" class="headerlink" title="1. HTTP 协议"></a>1. <strong>HTTP 协议</strong></h4><ul><li><strong>问题</strong>：HTTP 缓存机制有哪些？如何实现？<ul><li><strong>答案</strong>：<ul><li><strong>强缓存</strong>：<code>Cache-Control</code>（<code>max-age</code>）、<code>Expires</code>。</li><li><strong>协商缓存</strong>：<code>Last-Modified</code>&#x2F;<code>If-Modified-Since</code>、<code>ETag</code>&#x2F;<code>If-None-Match</code>（优先级更高）。</li></ul></li></ul></li></ul><h4 id="2-TCP-与-UDP"><a href="#2-TCP-与-UDP" class="headerlink" title="2. TCP 与 UDP"></a>2. <strong>TCP 与 UDP</strong></h4><ul><li><strong>问题</strong>：TCP 三次握手和四次挥手的过程？<ul><li><strong>答案</strong>：<ul><li><strong>三次握手</strong>：客户端发送 SYN → 服务端返回 SYN+ACK → 客户端发送 ACK。</li><li><strong>四次挥手</strong>：客户端发送 FIN → 服务端返回 ACK → 服务端发送 FIN → 客户端返回 ACK。</li></ul></li></ul></li></ul><h4 id="3-HTTPS-安全性"><a href="#3-HTTPS-安全性" class="headerlink" title="3. HTTPS 安全性"></a>3. <strong>HTTPS 安全性</strong></h4><ul><li><strong>问题</strong>：HTTPS 如何保证数据传输安全？<ul><li><strong>答案</strong>：<ul><li>使用 <strong>SSL&#x2F;TLS 加密</strong>，通过非对称加密交换密钥，对称加密传输数据。</li><li><strong>证书验证</strong>：CA 机构颁发证书，防止中间人攻击。</li></ul></li></ul></li></ul><h4 id="4-跨域与解决方案"><a href="#4-跨域与解决方案" class="headerlink" title="4. 跨域与解决方案"></a>4. <strong>跨域与解决方案</strong></h4><ul><li><strong>问题</strong>：如何解决跨域问题？<ul><li><strong>答案</strong>：<ul><li><strong>CORS</strong>：服务端设置 <code>Access-Control-Allow-Origin</code>。</li><li><strong>代理服务器</strong>：前端通过代理转发请求。</li><li><strong>JSONP</strong>：利用 <code>&lt;script&gt;</code> 标签跨域（仅限 GET 请求）。</li></ul></li></ul></li></ul><h2 id="手撕场景图"><a href="#手撕场景图" class="headerlink" title="手撕场景图"></a>手撕场景图</h2><ol><li>块级元素居中显示，固定在右下角,具体见居中+固定.html</li><li>定义一个对象数组，实现筛选、查找、对属性求和、提取对象一个属性映射成数组，考察一些数组函数的使用,具体见try.js</li></ol><h3 id="生成8位随机字符串："><a href="#生成8位随机字符串：" class="headerlink" title="生成8位随机字符串："></a>生成8位随机字符串：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateRandomString</span>(<span class="hljs-params">length = <span class="hljs-number">8</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> chars = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123;length&#125;, <span class="hljs-function">() =&gt;</span> chars[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * chars.<span class="hljs-property">length</span>)]).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断变量类型："><a href="#判断变量类型：" class="headerlink" title="判断变量类型："></a>判断变量类型：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法1：typeof</span><br><span class="hljs-keyword">typeof</span> variable <br><br><span class="hljs-comment">// 方法2：instanceof</span><br>variable <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br><br><span class="hljs-comment">// 方法3：Object.prototype.toString.call()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(variable) <span class="hljs-comment">// &quot;[object Type]&quot;</span><br><br><span class="hljs-comment">// 方法4：Array.isArray() 判断数组</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(variable)<br></code></pre></td></tr></table></figure><h3 id="数字取整："><a href="#数字取整：" class="headerlink" title="数字取整："></a>数字取整：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 向上取整</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">3.1</span>)    <span class="hljs-comment">// 4</span><br><br><span class="hljs-comment">// 向下取整</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">3.9</span>)   <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 四舍五入</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">3.5</span>)   <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="并行任务处理"><a href="#并行任务处理" class="headerlink" title="并行任务处理"></a>并行任务处理</h3><p>Promise.all() 接收一个 Promise 数组，返回一个新的 Promise。当所有 Promise 都完成时才会触发 then。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用 Promise.all</span><br><span class="hljs-keyword">const</span> tasks = [<span class="hljs-title function_">task1</span>(), <span class="hljs-title function_">task2</span>(), <span class="hljs-title function_">task3</span>()];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(tasks)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;所有任务已完成！&#x27;</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;任务执行出错：&#x27;</span>, error);<br>    &#125;);<br></code></pre></td></tr></table></figure><h3 id="清洗HTML代码获取文本："><a href="#清洗HTML代码获取文本：" class="headerlink" title="清洗HTML代码获取文本："></a>清洗HTML代码获取文本：</h3><p>正则表达式 &#x2F;&lt;[^&gt;]+&gt;&#x2F;g 的原理：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt; 匹配左尖括号<br><span class="hljs-selector-attr">[^&gt;]</span>+ 匹配任何不是右尖括号的字符（一个或多个）<br>&gt; 匹配右尖括号<br><span class="hljs-selector-tag">g</span> 全局匹配<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTextFromHtml</span>(<span class="hljs-params">html</span>) &#123;<br>    <span class="hljs-comment">// 方法1：使用正则</span><br>    <span class="hljs-keyword">return</span> html.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    <br>    <span class="hljs-comment">// 方法2：使用DOM</span><br>    <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    div.<span class="hljs-property">innerHTML</span> = html;<br>    <span class="hljs-keyword">return</span> div.<span class="hljs-property">textContent</span> || div.<span class="hljs-property">innerText</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组操作方法：js中数组追加元素，压入元素头部，插入元素用什么"><a href="#数组操作方法：js中数组追加元素，压入元素头部，插入元素用什么" class="headerlink" title="数组操作方法：js中数组追加元素，压入元素头部，插入元素用什么"></a>数组操作方法：js中数组追加元素，压入元素头部，插入元素用什么</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 追加元素到末尾</span><br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);      <span class="hljs-comment">// [1,2,3,4]</span><br><br><span class="hljs-comment">// 添加元素到头部</span><br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">// [0,1,2,3,4]</span><br><br><span class="hljs-comment">// 在指定位置插入元素</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;new&#x27;</span>);  <span class="hljs-comment">// 在索引2处插入&#x27;new&#x27;。第二个参数代表删除的元素个数，0代表不删除。</span><br></code></pre></td></tr></table></figure><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><ul><li><p>面试不是背简历，而是把实习、项目中的你擅长的技术点和相关能力划重点，引导面试官去提问，方便他知道该问什么，你在哪些点上擅长；</p></li><li><p>面试官面试一般先会前几分钟让你自我介绍的时候看一眼你的简历，所以你自我介绍时间最好在2-3min，太长，面试官时间也宝贵，人家都想好问你啥了，还在一直听你在巴拉巴拉没有重点；时间太短人家简历都没看完；当然这个只是一般情况，主要取决于面试官本人；如果你想深入介绍下一些东西可以在2-3min把自己介绍地差不多之后再询问一下面试官的意见。</p></li><li><p>介绍内容（按照简历上的顺序）</p><ul><li>你是谁，哪个学校的，什么学历，有哪些奖项（在校的东西没有什么含金量的话，直接pass，校内的东西在校外大概率没一点用）</li><li>介绍自己的技术栈，哪些技术比较熟悉、经验丰富，从这引导面试官去提问你准备好的内容：</li><li>实习经历：在某某处实习，一句话总结，做什么工作，用到什么技术栈，如果有自己擅长的可以引导面试官去问你准备好的和这段工作经历相关的技术点&#x2F;八股文，提几个擅长的就可以来不要全列出来（篇幅太长）；</li><li>项目经历：一句话介绍一下项目：同样的如果还有希望让面试官提问的自己擅长的点，可以引导；</li></ul></li><li><p>示例：面试官您好，很荣幸有机会能参加这次贵公司的面试；我是王斌杰，目前在武汉的江汉大学，大三在读；有前端开发和AI应用开发的实习和项目经验；比较熟悉的技术栈有html&#x2F;css&#x2F;Vue3及其生态系统以及Element plus和Vant等UI框架的使用，了解python、JAVA等一些后端语言，熟悉cursor、copilot等AI工具的使用；有两端实习经历：第一段是在一个武大初创团队做AI应用web前端开发,项目背景是结合AI设计药物与区块链代币化;我主要是负责项目介绍页面和药物分子生成对话界面的前端开发；根据UI设计图开发界面，和后端对接；第二段实习经历是在北京普测时空，主要负责在搭载国产芯片的边缘AI计算设备AIbox1684x上开发AI应用，参与了智能文件搜索系统和会议总结系统两个项目，主要工作内容是调研和整合各种开源项目使用python进行开发；</p></li></ul><h2 id="实习经历提问"><a href="#实习经历提问" class="headerlink" title="实习经历提问"></a>实习经历提问</h2><h3 id="实习过程中最难的地方；"><a href="#实习过程中最难的地方；" class="headerlink" title="实习过程中最难的地方；"></a>实习过程中最难的地方；</h3><ul><li>如何充分利用有限的资源中，实现项目要求，我们这个盒子它的资源是有限，刚开始我是先调研预处理项目嘛，还没在真正的盒子设备里部署，后面资源有限发现跑不起来，因为MinerU它是只支持CPU和GPU加速的，我们这个是NPU，所以需要进行转移操作：将MinerU中用到的各种识别模型，转yi成支持TPU的bmodel格式，然后在docker中去使用它调用NPU资源</li><li>我做的应用层的预处理，顶层用的casaos作为交互界面，它是一个开原的开源个人云系统，我们做出来最后其实类似于一个Nas；</li></ul><h3 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h3><ul><li><p>预处理对于RAG有什么作用？</p><ol><li><strong>文本标准化</strong></li></ol><ul><li>将不同格式(PDF、Word、图片等)的文档转换为统一的文本格式，便于后续处理</li><li>清理和规范化文本，去除噪声数据，提高文本质量</li></ul><ol start="2"><li><strong>提升检索效果</strong></li></ol><ul><li>标准化的文本更容易建立索引</li><li>提高语义匹配的准确度</li><li>减少由格式不一致导致的检索偏差</li></ul><ol start="3"><li><strong>优化向量化效果</strong></li></ol><ul><li>清晰规范的文本能得到更好的向量表示</li><li>提高文本嵌入(embedding)的质量</li><li>使相似文本的向量距离更接近</li></ul><ol start="4"><li><strong>提升系统性能</strong></li></ol><ul><li>减少处理非结构化数据的开销</li><li>加快检索速度</li><li>节省存储空间</li></ul></li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><ul><li>主要是陪诊系统的技术细节<ul><li>项目是一个面向县城小诊所使用的陪诊系统，包括面向诊所人员的PC端后台管理系统和面向用户的移动端H5订单系统，实现了注册、登录、用户移动端能够填写订单信息、选择诊所、陪护师、日期、需求等，发起订单请求，后端管理系统可以展示和管理陪护师信息、订单信息、制定不同的权限菜单，根据不同角色分配不同的权限菜单,实现权限管理；</li><li>项目亮点<ul><li><p>根据用户的权限信息动态生成和添加路由，通过递归组件呈现相应的多层级菜单，提升了系统灵活性，确保菜单栏与路由的同步更新、动态实时渲染,</p></li><li><p>通过请求头header中的token进行身份验证，通过路由守卫实现登录拦截</p></li><li><p>使用 Vuex，通过localStorage 存储用户、路由、token信息到本地，实现数据持久化</p><p>项目的亮点：参照简历上提炼的去剖细节</p><ol><li>通过递归组件实现后台系统多层级菜单，支持无限层级配置,提升了系统灵活性   </li><li>根据用户的权限菜单信息动态生成路由，确保菜单栏与路由的同步更新、实现菜单栏动态实时渲染</li></ol><ul><li>src\view\login\index.vue：登录成功之后向后端发起两个请求，一个请求拿到用户的信息和token存到浏览器里，另一个请求用户的权限信息通过sotre的mutations存到vuex的store定义的routerList变量里，这里面就包含所有权限路由信息，同时把这些路由信息通过addRoute添加到根目录中，作为根目录的子路由；</li><li>然后在公共组件Aside中定义变量menuData通过router.options.routes[0].children来获取所有的菜单路由信息并把它传递到递归组件SubMenu.vue中，SubMenu.vue中通过递归的方式把菜单渲染出来；</li><li>SubMenu组件里用的是elment plus组件库里的template标签在最外层通过v-for遍历Aside传过来的路由信息，（给他赋予一个key属性，这个key由v-for的index还有路由的id信息拼接而成，比如第一个子菜单控制台的key就是1，第二个就是2，如果子菜单还有子菜单，那key就是2-1,2-2,以此类推）；里面包含着el-menu-item 标签，通过v-if判断传过来的正在遍历的在这个路由下面有没有子路由，如果没有的话，就只渲染这个子菜单的元素和相关信息，如果有的话，也给你el-sub-menu标签中使用v-else同样赋予它一个Key(和上面的相同)，然后在这个标签中继续调用这整个SubMenu组件.有多少个子路由就有多少个菜单;</li></ul><ol><li>菜单点击之后发亮效果怎么实现的？<ol><li>在store存了一个MenuActive的变量；点击相应的菜单就会通过mutitation调用我定义的改变激活子菜单的实现，将点击菜单的index属性赋值给MenuActive，在css中设计一个类名展示被激活的样式，在el-menu-item中有一个通过判断当前标签的索引是否和store里存储的这个激活菜单项相当，赋予他这个类名，从而实现菜单点击之后发亮效果；</li></ol></li><li>使用token进行身份验证通过路由守卫实现登录拦截使用 Vuex 配合 vuex-persistedstate 插件实现数据持久化<ol><li>在创建store的时候用了persistedstate这个插件，作用是当 Vuex store 中的状态发生变化时（通过 mutation），vuex-persistedstate 会将新的状态存储到浏览器中。页面加载时：vuex-persistedstate 从浏览器存储中恢复状态到 Vuex store。状态变化时：vuex-persistedstate 将新的状态存储到浏览器中。</li></ol></li><li>通过 localStorage 存储用户、路由、token信息到本地</li></ol><ul><li>没啥好说</li></ul><p>业务上：这个项目的业务背景是什么，在业务上有什么比较牛逼的地方，推动了业务如何运行等等？</p><ul><li>我是一个从小在小县城长大的人，小时候生病都是直接去小诊所打针&#x2F;开药，在我印象里，诊所总是爆满，很多人都没位置坐，而且有的护士她能很差，给别人打针都会打漏，我就想能不能设计一个系统，让用户能提前预约陪诊也能选择自己觉得更好的陪护士；然后就和同学一起开始做了，后面想到能不能让诊所里上班的人也能上网看呢有多少要处理呢，不同职位的人看到的信息也不一样，然后就慢慢开发成这个样子了；</li><li>我觉得最牛的就是能和同学一起开发一个项目， 从无到有，这种吧自己的想法实现变成现实的感觉很好</li></ul><p>项目来源于哪？</p><ul><li>刚开始是自己和同学一起想的然后也参考一些网上的其他项目；慢慢拓展成现在这样；</li></ul><p>技术实现上：这个项目的整体技术实现思路是怎样的，项目中用了什么比较牛逼的技术，解决了什么比较困难的问题等等<br>做这个项目所花费的时间是多少？</p><ul><li><p>vue全家桶，最困难的就是这个不同的权限信息展示不同的菜单栏实现权限管理，</p></li><li><p>难点</p><ul><li>递归组件，动态菜单栏：前面有讲过</li><li>前后端联调：<ul><li>我有想法之后 ，同时我前端先搞出来，用mock模拟一下，给同学提需求，和他交流让他把加相应的接口，把详细细节用APIfox补充在接口文档里 ，然后我在按照接口文档去改；</li><li>途中也遇到很多问题，比如他写的接口参数和响应数据的数据类型、数据内容不对，我就会和他交流，让他改，然后我再去</li></ul></li><li>经常遇到bug，刚开始一个bug能修一天，后来掌握了一些技巧debug的技巧就快多了；我得到了一些关于debug的感悟和复盘总结，具体见D:\Lsz\code\font_back_end\fontend\vue_learn\pzadmin\note\note_vue.md中【总结一下debug的经验、流程】<ul><li>debug的目的<ul><li><ol><li>解决问题</li></ol></li><li><ol start="2"><li>发现自己的认知缺陷和不足之处；</li></ol></li></ul></li><li>如何debug<ul><li>F12打开网页的控制台输出&#x2F;打断点,network,接口文档，问AI，git回滚</li></ul></li></ul></li></ul><p>是否是多人项目，如果是，在项目中担任什么角色？ 你负责了项目的哪块内容？</p><ul><li>同学复责后端，我负责前端所有内容</li></ul><p>项目实现了哪些功能，又或者说你参与的部分实现了哪些功能</p><ul><li>我参与了所有前端部分，包括实现了注册、登录、移动端用户创建预约陪诊订单、后台系统展示和管理诊所人力资源、订单状态及数量、用户权限</li></ul><p>做项目的过程中使用了哪些技术栈？为什么使用它？</p><h2 id="你使用XX技术栈的时候有没有什么坑，你们怎么解决的？-使用了Vue3的组合式-API-，提供更灵活和模块化的代码结构-Vite作为构建工具和开发服务器，提供更快的开发服务器启动和热更新-Vue-Router于前端路由管理-Vuex用于状态管理，存储全局并量方法等数据"><a href="#你使用XX技术栈的时候有没有什么坑，你们怎么解决的？-使用了Vue3的组合式-API-，提供更灵活和模块化的代码结构-Vite作为构建工具和开发服务器，提供更快的开发服务器启动和热更新-Vue-Router于前端路由管理-Vuex用于状态管理，存储全局并量方法等数据" class="headerlink" title="你使用XX技术栈的时候有没有什么坑，你们怎么解决的？- 使用了Vue3的组合式 API ，提供更灵活和模块化的代码结构- Vite作为构建工具和开发服务器，提供更快的开发服务器启动和热更新- Vue Router于前端路由管理- Vuex用于状态管理，存储全局并量方法等数据"></a>你使用XX技术栈的时候有没有什么坑，你们怎么解决的？<br>- 使用了Vue3的组合式 API ，提供更灵活和模块化的代码结构<br>- Vite作为构建工具和开发服务器，提供更快的开发服务器启动和热更新<br>- Vue Router于前端路由管理<br>- Vuex用于状态管理，存储全局并量方法等数据</h2><p>项目中遇到过什么印象比较深的Bug？</p><ul><li>bug：提交表单后无法显示提示”注册成功,请登录”;下面我叙述一下debug的过程<ul><li>首先排除Elment组件的导入问题，因为发送验证码的时候是有提示的</li><li>在提交时在控制台里输出一下提交信息，打开F12在控制台，是有的，说明参数传进去了</li><li>点开network一看发现响应失败，也就是说明后端接口不接受这个数据</li><li>所以我仔细对照了一下接口文档，发现传入的一个参数名字validCode 写成了validcode，字母li的顺序写反了；然后解决</li></ul></li></ul><p>你是根据哪些指标进行针对性优化的？</p><ul><li>使用 Vite 作为构建工具,提供更快的开发服务器启动和热更新</li><li>使用Vue Router的hashweb模式，不用每更改一次路由就像服务器发送一次请求，减少了服务器的压力</li><li>vuex-persistedstate 实现状态持久化，不用频繁地向后端请求同一个数据</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="动态路由实现方式"><a href="#动态路由实现方式" class="headerlink" title="动态路由实现方式"></a>动态路由实现方式</h3><h3 id="登录Token验证相关细节"><a href="#登录Token验证相关细节" class="headerlink" title="登录Token验证相关细节"></a>登录Token验证相关细节</h3><h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><ul><li>打包优化</li><li>首屏优化</li><li>懒加载</li></ul><h3 id="遇到的最困难的技术问题"><a href="#遇到的最困难的技术问题" class="headerlink" title="遇到的最困难的技术问题"></a>遇到的最困难的技术问题</h3><h2 id="非技术问题"><a href="#非技术问题" class="headerlink" title="非技术问题"></a>非技术问题</h2><ul><li>为什么选择前端开发<ul><li>其实我接触前端算是比较晚的了，我们08届师兄陈玉龙他是CSDNCTO，大二暑假的时候来我们学校办了一个Web开发和计算基础训练营，我报名参加了，从那个时候开始接触的Web开发，我也比较喜欢前端这种和用户直接交互、可以用代码搭建所见即所得的界面开发模式，而且前端的生态还比较繁荣，所以就选择深入下去学习了前端开发；</li></ul></li><li>你平时怎么学习的<ul><li>我平时会看一些大佬的技术博客，比如阮一峰还有同龄的很优秀的人分享的以及掘金上的技术文章，对于一些比较难以理解的知识或者一个系统性的演示，我一般会去Blibli或者YouTube上看一些视频入门；再进阶一点就会去看一些技术书籍（比如图解Http）,去github上研究一些相关技术的优质项目的源码，甚至参与建设；还有就是一定要多动手实践，我学Vue的时候就是一边做项目，一边看文档和做笔记，记忆更深刻，效率更高；</li></ul></li><li>你对你未来的职业规划有着怎么样的打算。<ul><li>我目前的打算是现在前端这个领域深耕下去，找到自己一个感兴趣的领域深入研究下去（比如浏览器、3D、AI应用交互等等），然后能学习一些后端，争取能成为一个全栈工程师，如果可以的尝试成为架构师；</li></ul></li><li>你对加班怎么看待。<ul><li>如果项目开发时间比较紧张，在身体和情绪可接受的范围内加班我是可以接受的；</li></ul></li><li>你情绪低落你会选择什么样的方式缓解。<ul><li>我一般会去运动，打篮球、羽毛球、乒乓球，或者去跑跑步，运动可以让我暂时忘记烦恼，放松心情，同时也能锻炼身体，保持一个良好的身体状态；</li></ul></li><li>你的低谷期是多久。<ul><li>我不太容易陷入低谷期，还是比较乐观的，如果真陷入了，大概率2-3天出去走走转转、踢踢足球、跑跑步，想开了就能恢复；</li></ul></li><li>遇到的最困难的事<ul><li>我觉得目前遇到最困难的事就是在秋招的时候进入中大厂；市场逐渐饱和、竞争越来越激烈了，优秀的人太多了，我目前这种水平其实没太大机会，所以要更加用心、刻苦地学习和工作、积累经验和简历</li></ul></li><li>我的优点<ul><li>第一我比喜欢与人沟通、交流，上一段实习的时候就认识了蛮多朋友的，他们不和我一个方向，但我和他们交往的过程中也学到了蛮多以前我都接触不到的行业的知识，拓展了我的认知，我认为拓展认知就是学习的本质，这也是我出来实习的意义之一，</li><li>第二我比较乐观，不会轻易出现畏难情绪，生死之外无大事，只要肯学习和钻研，多向优秀的人请教，反正我觉得没什么能难倒我的；</li></ul></li><li>我的缺点<ul><li>第一我比较喜欢钻牛角尖，有时候一个问题我会想很久，从客观上来讲是在浪费时间的；不过我在上一段实习过程中，mentor告诉了我一个0.5h法则；在工作中遇到难题，先自己搜集资料尝试各种办法解决，如果半个小时之后还是没有头绪，就直接问同事和mentor；我觉得这个方法蛮好的，可以避免我钻牛角尖，也可以提高工作效率；所以一直记得；</li></ul></li></ul><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><ol><li>部门负责的产品是什么？</li><li>技术团队人员现状、人数？</li><li>面试表现怎么样，有哪些可以改进的地方？</li></ol><h2 id="面向公司"><a href="#面向公司" class="headerlink" title="面向公司"></a>面向公司</h2><hr><h3 id="wjby"><a href="#wjby" class="headerlink" title="wjby"></a>wjby</h3><h4 id="部署页面是如何保证用户接受到的页面是最新的"><a href="#部署页面是如何保证用户接受到的页面是最新的" class="headerlink" title="部署页面是如何保证用户接受到的页面是最新的"></a>部署页面是如何保证用户接受到的页面是最新的</h4><p>我将详细解释前端页面缓存和如何确保用户加载最新版本的页面。</p><p>在前端部署中，浏览器缓存确实会影响用户访问页面时加载的资源。为了解决这个问题，我们有几种常用的方案：</p><ol><li>文件指纹（Hash）策略<br>最常用且推荐的方法是在静态资源文件名中添加哈希值。这种方式可以确保当文件内容发生变化时，文件名也会随之改变，浏览器会被迫加载新的资源。</li></ol><p>示例：</p><ul><li><code>app.js</code> → <code>app.abc123.js</code></li><li><code>style.css</code> → <code>style.def456.css</code></li></ul><p>webpack、vite等构建工具都默认支持这种方式。代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[contenthash].js&#x27;</span>,  <span class="hljs-comment">// 添加内容哈希</span><br>    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name].[contenthash].chunk.js&#x27;</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>强制更新策略<br>可以通过以下几种方式实现：</li></ol><p>a. Cache-Control 响应头控制</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache, no-store, must-revalidate<br></code></pre></td></tr></table></figure><p>b. Service Worker 方案<br>使用 Service Worker 可以精确控制缓存策略，实现秒级更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;v1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) &#123;<br>      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([<br>        <span class="hljs-string">&#x27;/&#x27;</span>,<br>        <span class="hljs-string">&#x27;/index.html&#x27;</span>,<br>        <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,<br>        <span class="hljs-string">&#x27;/script/main.js&#x27;</span><br>      ]);<br>    &#125;)<br>  );<br>&#125;);<br><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>      <span class="hljs-comment">// 优先返回最新资源</span><br>      <span class="hljs-keyword">return</span> response || <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>);<br>    &#125;)<br>  );<br>&#125;);<br><br></code></pre></td></tr></table></figure><ol start="3"><li>HTML 版本标记<br>在 HTML 中添加版本戳：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;version&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;2024-03-25-v1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>前端构建时间戳<br>在构建时动态生成时间戳：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><span class="hljs-keyword">const</span> moment = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;moment&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;<br>      <span class="hljs-string">&#x27;process.env.BUILD_TIME&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>))<br>    &#125;)<br>  ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>推荐实践：</p><ol><li>使用文件指纹（推荐）</li><li>配置合理的缓存策略</li><li>结合 CDN 部署</li><li>对于关键资源，可以使用 <code>Cache-Control: no-cache</code></li></ol><p>注意事项：</p><ul><li>不同的缓存策略适用于不同的场景</li><li>要平衡性能和实时更新</li><li>考虑用户体验和加载速度</li></ul><p>总结：通过文件指纹和缓存控制，可以有效确保用户每次访问都能加载最新的页面资源。选择合适的方案取决于具体的业务需求和技术架构。</p><h3 id="Node-js-与-npm-高频问题及参考答案"><a href="#Node-js-与-npm-高频问题及参考答案" class="headerlink" title="Node.js 与 npm 高频问题及参考答案"></a><strong>Node.js 与 npm 高频问题及参考答案</strong></h3><h4 id="1-Node-js-事件循环（Event-Loop）是什么？各阶段的作用？"><a href="#1-Node-js-事件循环（Event-Loop）是什么？各阶段的作用？" class="headerlink" title="1. Node.js 事件循环（Event Loop）是什么？各阶段的作用？"></a><strong>1. Node.js 事件循环（Event Loop）是什么？各阶段的作用？</strong></h4><p><strong>答</strong>：  </p><ul><li><strong>定义</strong>：事件循环是 Node.js 处理异步任务的机制，分为 6 个阶段：  <ol><li><strong>Timers</strong>：执行 <code>setTimeout</code>&#x2F;<code>setInterval</code> 回调。  </li><li><strong>Pending callbacks</strong>：执行系统操作回调（如 TCP 错误）。  </li><li><strong>Idle&#x2F;Prepare</strong>：内部使用。  </li><li><strong>Poll</strong>：检索新的 I&#x2F;O 事件，执行 I&#x2F;O 回调。  </li><li><strong>Check</strong>：执行 <code>setImmediate</code> 回调。  </li><li><strong>Close callbacks</strong>：执行关闭事件回调（如 <code>socket.on(&#39;close&#39;)</code>）。</li></ol></li><li><strong>关键点</strong>：  <ul><li><code>process.nextTick()</code> 和 <code>Promise.then()</code> 属于微任务，在阶段切换前执行。  </li><li><code>setImmediate</code> 在 Check 阶段执行，<code>setTimeout</code> 在 Timers 阶段执行。</li></ul></li></ul><hr><h4 id="2-CommonJS-和-ES-Module-的区别？如何兼容两者？"><a href="#2-CommonJS-和-ES-Module-的区别？如何兼容两者？" class="headerlink" title="2. CommonJS 和 ES Module 的区别？如何兼容两者？"></a><strong>2. CommonJS 和 ES Module 的区别？如何兼容两者？</strong></h4><p><strong>答</strong>：  </p><ul><li><strong>区别</strong>：  <table><thead><tr><th><strong>CommonJS</strong></th><th><strong>ES Module</strong></th></tr></thead><tbody><tr><td><code>require()</code> 动态同步加载</td><td><code>import</code> 静态编译时加载</td></tr><tr><td>模块输出是值的拷贝</td><td>输出是值的引用（动态绑定）</td></tr><tr><td>适用于 Node.js 环境</td><td>浏览器原生支持，Node.js 需配置</td></tr></tbody></table></li><li><strong>兼容</strong>：在 <code>package.json</code> 中设置 <code>&quot;type&quot;: &quot;module&quot;</code>，或使用 <code>.mjs</code>&#x2F;<code>.cjs</code> 扩展名区分。</li></ul><hr><h4 id="3-npm-的依赖版本符号-、-、-有何区别？"><a href="#3-npm-的依赖版本符号-、-、-有何区别？" class="headerlink" title="3. npm 的依赖版本符号 ^、~、* 有何区别？"></a><strong>3. npm 的依赖版本符号 <code>^</code>、<code>~</code>、<code>*</code> 有何区别？</strong></h4><p><strong>答</strong>：  </p><ul><li>**<code>^1.2.3</code>**：允许更新次版本和补丁版本（<code>1.x.x</code>，不更新主版本）。  </li><li>**<code>~1.2.3</code>**：仅允许更新补丁版本（<code>1.2.x</code>）。  </li><li><strong><code>*</code></strong> 或 <code>latest</code>：匹配最新版本（慎用）。  </li><li><strong>锁定依赖</strong>：<code>package-lock.json</code> 或 <code>npm-shrinkwrap.json</code> 确保安装精确版本。</li></ul><hr><h4 id="4-如何解决-npm-依赖冲突（如不同包依赖同一库的不同版本）？"><a href="#4-如何解决-npm-依赖冲突（如不同包依赖同一库的不同版本）？" class="headerlink" title="4. 如何解决 npm 依赖冲突（如不同包依赖同一库的不同版本）？"></a><strong>4. 如何解决 npm 依赖冲突（如不同包依赖同一库的不同版本）？</strong></h4><p><strong>答</strong>：  </p><ul><li><strong>依赖提升</strong>：npm&#x2F;yarn 将共用的依赖提升到顶层 <code>node_modules</code>。  </li><li><strong>手动指定版本</strong>：在 <code>package.json</code> 中显式指定依赖版本。  </li><li><strong>使用 resolutions 字段（yarn）</strong>：强制统一依赖版本。</li></ul><hr><h3 id="Three-js-高频问题及参考答案"><a href="#Three-js-高频问题及参考答案" class="headerlink" title="Three.js 高频问题及参考答案"></a><strong>Three.js 高频问题及参考答案</strong></h3><hr><h4 id="1-Three-js-的核心组件有哪些？简述其作用。"><a href="#1-Three-js-的核心组件有哪些？简述其作用。" class="headerlink" title="1. Three.js 的核心组件有哪些？简述其作用。"></a><strong>1. Three.js 的核心组件有哪些？简述其作用。</strong></h4><p><strong>答</strong>：  </p><ul><li><strong>Scene</strong>：3D 场景容器，管理所有物体、光源、相机。  </li><li><strong>Camera</strong>：定义视图投影方式（如 <code>PerspectiveCamera</code> 透视投影）。  </li><li><strong>Renderer</strong>：将场景渲染到画布（WebGL 或 Canvas 2D）。  </li><li><strong>Geometry</strong>：物体几何形状（如 <code>BoxGeometry</code> 立方体）。  </li><li><strong>Material</strong>：物体材质（如颜色、纹理、反光属性）。  </li><li><strong>Light</strong>：光源（如 <code>DirectionalLight</code> 平行光、<code>AmbientLight</code> 环境光）。</li></ul><hr><h4 id="2-如何优化-Three-js-的渲染性能？"><a href="#2-如何优化-Three-js-的渲染性能？" class="headerlink" title="2. 如何优化 Three.js 的渲染性能？"></a><strong>2. 如何优化 Three.js 的渲染性能？</strong></h4><p><strong>答</strong>：  </p><ul><li><strong>减少 Draw Calls</strong>：合并几何体（<code>BufferGeometryUtils.mergeBufferGeometries</code>）。  </li><li><strong>使用 InstancedMesh</strong>：批量渲染相同物体（如大量树木、粒子）。  </li><li><strong>LOD（细节分级）</strong>：根据距离切换不同精度的模型。  </li><li><strong>纹理压缩</strong>：使用压缩格式（如 <code>KTX2</code>）减少显存占用。  </li><li><strong>避免频繁 GC</strong>：复用对象（如 ObjectPool 模式管理粒子）。</li></ul><hr><h4 id="3-如何实现点击-3D-物体触发交互？"><a href="#3-如何实现点击-3D-物体触发交互？" class="headerlink" title="3. 如何实现点击 3D 物体触发交互？"></a><strong>3. 如何实现点击 3D 物体触发交互？</strong></h4><p><strong>答</strong>：<br><strong>射线检测（Raycasting）</strong>：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> raycaster = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Raycaster</span>();<br><span class="hljs-keyword">const</span> mouse = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>();<br><br><span class="hljs-comment">// 将鼠标坐标归一化到 [-1, 1]</span><br>mouse.<span class="hljs-property">x</span> = (event.<span class="hljs-property">clientX</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>mouse.<span class="hljs-property">y</span> = -(event.<span class="hljs-property">clientY</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 从相机向鼠标方向发射射线</span><br>raycaster.<span class="hljs-title function_">setFromCamera</span>(mouse, camera);<br><span class="hljs-keyword">const</span> intersects = raycaster.<span class="hljs-title function_">intersectObjects</span>(scene.<span class="hljs-property">children</span>);<br><br><span class="hljs-keyword">if</span> (intersects.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了物体:&#x27;</span>, intersects[<span class="hljs-number">0</span>].<span class="hljs-property">object</span>);<br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string"></span><br><span class="hljs-string">---</span><br><span class="hljs-string"></span><br><span class="hljs-string">#### **4. 如何加载并显示 GLTF 模型？**  </span><br><span class="hljs-string">**答**：  </span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>javascript<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GLTFLoader</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/loaders/GLTFLoader&#x27;</span>;<br><br><span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>();<br>loader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;model.gltf&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">gltf</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> model = gltf.<span class="hljs-property">scene</span>;<br>  scene.<span class="hljs-title function_">add</span>(model);<br>&#125;, <span class="hljs-literal">undefined</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;模型加载失败:&#x27;</span>, error);<br>&#125;);<br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string">**优化**：使用 `</span><span class="hljs-title class_">DRACOLoader</span><span class="hljs-string">` 解压缩模型，或预加载进度条。  </span><br><span class="hljs-string"></span><br><span class="hljs-string">---</span><br><span class="hljs-string">### wl</span><br><span class="hljs-string">好的，我来帮你解答这些面试题：</span><br><span class="hljs-string"></span><br><span class="hljs-string">**1. CSS position 属性**</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   **static**：默认值，元素按照正常文档流进行布局。</span><br><span class="hljs-string">*   **relative**：相对定位，相对于元素自身原本的位置进行偏移，不脱离文档流，原本位置保留。</span><br><span class="hljs-string">*   **absolute**：绝对定位，相对于最近的已定位的祖先元素进行定位（若无已定位祖先元素，则相对于初始包含块），脱离文档流。</span><br><span class="hljs-string">*   **fixed**：固定定位，相对于视口（浏览器窗口）进行定位，脱离文档流。</span><br><span class="hljs-string">*    **sticky**: 粘性定位，它是 relative 和 fixed 的结合体. 在跨越特定阈值前为相对定位，之后为固定定位。</span><br><span class="hljs-string"></span><br><span class="hljs-string">**2. 栈与堆类型的底层实现，以及垃圾回收**</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   **栈（Stack）**：</span><br><span class="hljs-string">    *   通常由操作系统自动管理，用于存储局部变量、函数参数、返回地址等。</span><br><span class="hljs-string">    *   遵循后进先出（LIFO）原则，内存分配和释放速度快。</span><br><span class="hljs-string">    *   大小有限制。</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   **堆（Heap）**：</span><br><span class="hljs-string">    *   由程序员手动管理（或通过垃圾回收器自动管理），用于存储动态分配的内存（例如通过 `</span><span class="hljs-keyword">new</span><span class="hljs-string">` 或 `</span>malloc<span class="hljs-string">` 创建的对象）。</span><br><span class="hljs-string">    *   没有特定的顺序，内存分配和释放速度相对较慢。</span><br><span class="hljs-string">    *   大小相对较大，受限于系统可用内存。</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   **垃圾回收（Garbage Collection）**：</span><br><span class="hljs-string">    *   自动检测和回收不再使用的内存（堆内存）的机制，防止内存泄漏。</span><br><span class="hljs-string">    *   常见算法：</span><br><span class="hljs-string">        *   **引用计数**：跟踪每个对象的引用数量，当引用计数为 0 时回收。（有循环引用问题）</span><br><span class="hljs-string">        *   **标记-清除**：从根对象开始，标记所有可达对象，然后清除未标记的对象。</span><br><span class="hljs-string">        *   **复制**：将内存分为两块，每次只使用一块，垃圾回收时将存活对象复制到另一块，然后清除当前块。</span><br><span class="hljs-string">        *   **标记-整理**：类似于标记-清除，但在清除后会将存活对象移动到内存的一端，整理内存碎片。</span><br><span class="hljs-string">        *   **分代回收**：根据对象存活时间将内存分为几代（新生代、老年代），对不同代采用不同的回收策略。</span><br><span class="hljs-string"></span><br><span class="hljs-string">**3. 深拷贝与浅拷贝，以及 object.assign 的底层原理**</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   **浅拷贝（Shallow Copy）**：创建一个新对象，复制原对象的属性值。如果属性值是基本类型，则复制值；如果属性值是引用类型（对象、数组），则复制引用（地址），新旧对象共享同一块内存。</span><br><span class="hljs-string">*   **深拷贝（Deep Copy）**：创建一个新对象，并递归地复制原对象及其所有嵌套的子对象，新旧对象完全独立，不共享内存。</span><br><span class="hljs-string"></span><br><span class="hljs-string">*   **`</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<span class="hljs-string">`**：</span><br><span class="hljs-string">    *   用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。</span><br><span class="hljs-string">    *   它是浅拷贝。</span><br><span class="hljs-string">    *   底层原理：遍历源对象的属性，如果是基本类型则复制值，如果是引用类型则复制引用。</span><br><span class="hljs-string"></span><br><span class="hljs-string">**4. WeakMap 与 weakSet**</span><br><span class="hljs-string"> 好的，让我简洁地回答这个面试问题：</span><br><span class="hljs-string"></span><br><span class="hljs-string">WeakMap 和 WeakSet 是 ES6 引入的两个新的数据结构，它们最大的特点是弱引用。</span><br><span class="hljs-string"></span><br><span class="hljs-string">#### WeakMap</span><br><span class="hljs-string">1. **特点**：</span><br><span class="hljs-string">- 键必须是对象</span><br><span class="hljs-string">- 弱引用（不会阻止垃圾回收）</span><br><span class="hljs-string">- 不可遍历，没有 size 属性</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>javascript<br><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>wm.<span class="hljs-title function_">set</span>(obj, <span class="hljs-string">&quot;data&quot;</span>);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 对象可被回收</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>主要用途</strong>：</li></ol><ul><li>存储 DOM 节点相关数据</li><li>实现私有属性</li><li>数据缓存</li></ul><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ol><li><strong>特点</strong>：</li></ol><ul><li>只能存储对象</li><li>同样是弱引用</li><li>不可遍历</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();<br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>ws.<span class="hljs-title function_">add</span>(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 对象可被回收</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>应用场景</strong>：</li></ol><ul><li>存储 DOM 元素集合</li><li>临时对象存储</li><li>防止对象重复添加</li></ul><h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><ol><li>WeakMap&#x2F;WeakSet 是弱引用，不会阻止垃圾回收</li><li>只能使用对象作为键或值</li><li>不能遍历，没有 size 属性</li></ol><p>这两个数据结构主要用于处理需要自动垃圾回收的场景，可以有效防止内存泄漏。</p><h4 id="5-Promise-常见的方法（then-catch-finally-all-race）"><a href="#5-Promise-常见的方法（then-catch-finally-all-race）" class="headerlink" title="5. Promise 常见的方法（then, catch, finally, all, race）"></a>5. Promise 常见的方法（then, catch, finally, all, race）</h4><ul><li><code>then(onFulfilled, onRejected)</code>：处理 Promise 的成功（fulfilled）和失败（rejected）状态。</li><li><code>catch(onRejected)</code>：处理 Promise 的失败状态，相当于 <code>.then(null, onRejected)</code>。</li><li><code>finally(onFinally)</code>：无论 Promise 是成功还是失败，都会执行的回调。</li><li><code>Promise.all(iterable)</code>：接收一个 Promise 数组，当所有 Promise 都成功时，返回一个包含所有结果的 Promise；如果有一个 Promise 失败，则返回该失败的 Promise。</li><li><code>Promise.race(iterable)</code>：接收一个 Promise 数组，当其中一个 Promise 成功或失败时，就返回该 Promise。</li><li><code>Promise.allSettled()</code>: 接收一个 Promise 数组, 只有等到所有这些参数 Promise 实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。</li></ul><p>获取数组对象中3个成功的，7个失败的，如何获取到成功的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promises = [ <span class="hljs-comment">/* ... 10个Promise ... */</span> ];<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(promises)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> successfulResults = results<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result.<span class="hljs-property">value</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Successful results:&#x27;</span>, successfulResults); <span class="hljs-comment">// 输出成功的3个结果</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h4 id="6-eventloop"><a href="#6-eventloop" class="headerlink" title="6. eventloop**"></a>6. eventloop**</h4><ul><li><p>JavaScript 是单线程的，但浏览器是多线程的。</p></li><li><p>Event Loop 是 JavaScript 实现异步的机制。</p></li><li><p>执行过程：</p><ol><li>执行同步任务（主线程）。</li><li>遇到异步任务（如 <code>setTimeout</code>、<code>Promise</code>、事件回调），将其放入任务队列（宏任务队列、微任务队列）。</li><li>当主线程空闲时，检查微任务队列，执行所有微任务。</li><li>执行完微任务后，从宏任务队列中取出一个宏任务执行。</li><li>重复步骤 2-4。</li></ol></li><li><p><strong>宏任务（Macro Task）</strong>：<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node.js）、I&#x2F;O、UI 渲染。</p></li><li><p><strong>微任务（Micro Task）</strong>：<code>Promise.then</code>、<code>MutationObserver</code>、<code>process.nextTick</code>（Node.js）。</p></li></ul><h4 id="7-Vue-的组件通信"><a href="#7-Vue-的组件通信" class="headerlink" title="7. Vue 的组件通信**"></a>7. Vue 的组件通信**</h4><ul><li><p><strong>父子组件</strong>：</p><ul><li><code>props</code>：父组件向子组件传递数据。</li><li><code>$emit</code>：子组件向父组件触发事件。</li><li><code>$refs</code>：父组件直接访问子组件的实例。</li><li><code>$parent</code> &#x2F; <code>$children</code>: 访问父&#x2F;子组件实例(不推荐).</li></ul></li><li><p><strong>兄弟组件</strong>：</p><ul><li>事件总线（Event Bus）：创建一个空的 Vue 实例作为中央事件总线，通过 <code>$emit</code> 触发事件，<code>$on</code> 监听事件。</li><li>Vuex：状态管理模式。</li></ul></li><li><p><strong>跨级组件</strong>：</p><ul><li><code>provide</code> &#x2F; <code>inject</code>：祖先组件提供数据，后代组件注入数据。</li><li>Vuex。</li></ul></li></ul><h4 id="8-Vue-中获取不到数组下标？（Vue2-数据绑定的局限性，Dep-对象以及-getter-setter-Watcher）"><a href="#8-Vue-中获取不到数组下标？（Vue2-数据绑定的局限性，Dep-对象以及-getter-setter-Watcher）" class="headerlink" title="8. Vue 中获取不到数组下标？（Vue2 数据绑定的局限性，Dep 对象以及 getter&#x2F;setter, Watcher）**"></a>8. Vue 中获取不到数组下标？（Vue2 数据绑定的局限性，Dep 对象以及 getter&#x2F;setter, Watcher）**</h4><ul><li>Vue2 使用 Object.defineProperty() 对数据进行劫持, 无法检测到数组下标和长度的变化。</li><li>Vue2 的解决方案：<ul><li>使用 Vue 提供的变异方法（<code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code>）来操作数组。</li><li>使用 <code>Vue.set</code> 或 <code>this.$set</code> 来添加或修改数组元素。</li></ul></li><li>vue3使用了proxy解决了此问题。</li><li><strong>Dep</strong>：依赖收集器，用于收集 Watcher。</li><li><strong>getter&#x2F;setter</strong>：Object.defineProperty() 中的访问器属性，用于劫持数据的读取和修改。</li><li><strong>Watcher</strong>：观察者，当数据变化时，Dep 会通知 Watcher，Watcher 执行相应的更新操作。</li></ul><h4 id="9-nextTick"><a href="#9-nextTick" class="headerlink" title="9. $nextTick**"></a>9. $nextTick**</h4><ul><li>将回调函数延迟到下次 DOM 更新循环之后执行。</li><li>用于在修改数据后立即获取更新后的 DOM。</li><li>原理：将回调函数放入微任务队列，确保在 DOM 更新后执行。</li></ul><h4 id="10-git-方面-pull-与-fetch-的区别"><a href="#10-git-方面-pull-与-fetch-的区别" class="headerlink" title="10. git 方面 pull 与 fetch 的区别**"></a>10. git 方面 pull 与 fetch 的区别**</h4><ul><li><code>git fetch</code>：从远程仓库下载最新的代码和分支信息，但不会自动合并到本地分支。</li><li><code>git pull</code>：相当于 <code>git fetch</code> + <code>git merge</code>，从远程仓库下载代码并自动合并到当前分支。</li></ul><h4 id="11-vuex-为什么可以全局实现？"><a href="#11-vuex-为什么可以全局实现？" class="headerlink" title="11. vuex 为什么可以全局实现？**"></a>11. vuex 为什么可以全局实现？**</h4><ul><li>Vuex 使用单一状态树（一个大的对象），包含应用的所有状态。</li><li>通过 Vue 的插件机制（<code>Vue.use(Vuex)</code>），将 store 实例注入到所有组件中。</li><li>组件可以通过 <code>this.$store</code> 访问 store 中的状态和方法。</li></ul><h4 id="4-为什么提前访问-let-和-const-定义的变量会报错"><a href="#4-为什么提前访问-let-和-const-定义的变量会报错" class="headerlink" title="4. 为什么提前访问 let 和 const 定义的变量会报错**"></a>4. 为什么提前访问 let 和 const 定义的变量会报错**</h4><ul><li>因为 <code>let</code> 和 <code>const</code> 声明的变量存在<strong>暂时性死区（Temporal Dead Zone，TDZ）</strong>。</li><li>在变量声明之前访问该变量会抛出 <code>ReferenceError</code>。</li><li>这是为了避免 <code>var</code> 声明的变量提升带来的潜在问题，提高代码的可读性和可维护性。</li></ul><p><strong>5. var 的作用域</strong></p><ul><li><code>var</code> 声明的变量具有<strong>函数作用域</strong>。</li><li>这意味着 <code>var</code> 声明的变量在声明它的函数内部是可见的，如果在函数外部声明，则具有全局作用域。</li><li>如果在块级作用域（如 <code>if</code> 语句、<code>for</code> 循环）中使用 <code>var</code> 声明变量，该变量仍然会提升到函数顶部，作用域仍然是函数作用域，而不是块级作用域。</li></ul><p><strong>8. Less 和 Sass 有什么优点</strong></p><p>Less 和 Sass 都是 CSS 预处理器，它们扩展了 CSS 的功能，使 CSS 更易于维护和编写。</p><p><strong>Less 和 Sass 的共同优点：</strong></p><ul><li><strong>变量：</strong> 可以定义和使用变量，避免重复编写相同的值。</li><li><strong>嵌套：</strong> 可以使用嵌套规则，使 CSS 代码更具结构性和可读性。</li><li><strong>混合（Mixins）：</strong> 可以定义可重用的 CSS 代码片段，并在需要的地方引用。</li><li><strong>运算：</strong> 可以进行简单的数学运算，如加、减、乘、除。</li><li><strong>函数：</strong> 可以使用内置函数或自定义函数来处理 CSS 值。</li><li><strong>导入：</strong> 可以将多个 CSS 文件合并成一个文件，减少 HTTP 请求。</li><li><strong>代码组织：</strong> 可以将 CSS 代码组织成更小的、更易于管理的模块。</li></ul><p><strong>Less 和 Sass 的区别：</strong></p><table><thead><tr><th>特性</th><th>Less</th><th>Sass</th></tr></thead><tbody><tr><td>语言</td><td>JavaScript</td><td>Ruby（最初），现在有 LibSass（C&#x2F;C++ 实现）</td></tr><tr><td>语法</td><td>类似于 CSS</td><td>两种语法：Sass（缩进语法）和 SCSS（类似于 CSS）</td></tr><tr><td>变量符号</td><td><code>@</code></td><td><code>$</code></td></tr><tr><td>混合</td><td>使用 <code>.</code> 或 <code>#</code> 开头</td><td>使用 <code>@mixin</code> 定义，使用 <code>@include</code> 引用</td></tr><tr><td>扩展</td><td></td><td>使用 <code>@extend</code> 继承选择器的样式</td></tr><tr><td>条件语句</td><td></td><td>使用 <code>@if</code>、<code>@else if</code>、<code>@else</code></td></tr><tr><td>循环语句</td><td></td><td>使用 <code>@for</code>、<code>@each</code>、<code>@while</code></td></tr><tr><td>函数</td><td>内置函数较少</td><td>内置函数更丰富</td></tr><tr><td>社区</td><td>较小</td><td>较大</td></tr></tbody></table><p>总的来说，Sass 的功能更强大，社区更活跃，但 Less 更容易上手，如果你的项目不需要 Sass 的高级功能，Less 可能是一个更轻量级的选择。</p><p><strong>9. Vue 的响应式原理，2 和 3 的区别</strong></p><ul><li><p><strong>Vue 2 的响应式原理：</strong></p><ul><li>Vue 2 使用 <strong>Object.defineProperty()</strong> 来劫持对象属性的 getter 和 setter。</li><li>当数据发生变化时，setter 会被触发，通知 Watcher 进行更新。</li><li><strong>缺点：</strong><ul><li>无法检测到对象属性的添加和删除。</li><li>无法检测到数组通过索引修改元素或修改数组长度。</li><li>需要对 data 中的每个属性进行遍历，性能开销较大。</li></ul></li></ul></li><li><p><strong>Vue 3 的响应式原理：</strong></p><ul><li>Vue 3 使用 <strong>Proxy</strong> 对象来代理整个对象或数组。</li><li>Proxy 可以拦截对象或数组的各种操作，如读取、修改、添加、删除等。</li><li>当数据发生变化时，Proxy 会触发相应的 trap（捕获器），通知 Watcher 进行更新。</li><li><strong>优点：</strong><ul><li>可以检测到对象属性的添加和删除。</li><li>可以检测到数组通过索引修改元素或修改数组长度。</li><li>不需要对 data 中的每个属性进行遍历，性能更好。</li><li>可以代理更复杂的数据类型，如 Map、Set。</li></ul></li></ul></li></ul><p><strong>10. Vue3 如何定义响应式数据</strong></p><p>Vue 3 提供了以下几种方式来定义响应式数据：</p><ul><li><p><strong><code>ref</code>：</strong></p><ul><li><p>用于定义基本数据类型（如数字、字符串、布尔值）的响应式数据。</p></li><li><p>返回一个包含 <code>.value</code> 属性的对象，通过 <code>.value</code> 访问和修改数据。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出 0</span><br>count.<span class="hljs-property">value</span>++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>reactive</code>：</strong></p><ul><li><p>用于定义对象或数组的响应式数据。</p></li><li><p>返回一个响应式代理对象，可以直接访问和修改对象的属性。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>); <span class="hljs-comment">// 输出 0</span><br>state.<span class="hljs-property">count</span>++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>readonly</code>:</strong></p><ul><li>创建只读版本的响应式数据</li></ul></li><li><p><strong><code>shallowReactive</code>:和 <code>shallowRef</code></strong></p></li><li><p>仅为对象创建浅层响应式&#x2F;仅为ref创建浅层作用。</p></li><li><p>浅层作用的意思是只有对象本身是响应式的，不执行嵌套对象的深层响应式转换 (暴露原始值)。</p></li></ul><p><strong>11. ref 和 shallowRef 的区别</strong></p><ul><li><p><strong><code>ref</code>：</strong></p><ul><li>创建一个深层响应式的数据，即如果 <code>ref</code> 的值是一个对象，那么对象内部的属性也会被转换为响应式。</li><li>通过 <code>.value</code> 访问和修改数据。</li></ul></li><li><p><strong><code>shallowRef</code>：</strong></p><ul><li>创建一个浅层响应式的数据，即只有 <code>.value</code> 属性是响应式的，如果 <code>.value</code> 的值是一个对象，那么对象内部的属性不会被转换为响应式。</li><li>通过 <code>.value</code> 访问和修改数据。</li><li>适用于只需要跟踪引用变化，不需要深层响应式的情况，可以提高性能。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, shallowRef, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> deep = <span class="hljs-title function_">ref</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>&#125;);<br><br><span class="hljs-keyword">const</span> shallow = <span class="hljs-title function_">shallowRef</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br> <span class="hljs-attr">nested</span>: &#123;<br>   <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br> &#125;<br>&#125;)<br><br><span class="hljs-comment">// deep.value.count 是响应式的</span><br>deep.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 会触发更新</span><br><br><span class="hljs-comment">// shallow.value.count 不是响应式的</span><br>shallow.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 不会触发更新</span><br><br><span class="hljs-comment">// 只有 shallow.value 本身是响应式的</span><br>shallow.<span class="hljs-property">value</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;; <span class="hljs-comment">// 会触发更新</span><br><br><span class="hljs-comment">// shallowReactive 示例</span><br><span class="hljs-comment">// state.nested 是响应式的</span><br>state.<span class="hljs-property">nested</span>.<span class="hljs-property">count</span>++<br><span class="hljs-comment">// state.nested 不是响应式的</span><br>state.<span class="hljs-property">nested</span> = &#123;<br> <span class="hljs-attr">count</span>: <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>12. Vue 组件通信方式</strong></p><p>（已在前面的回答中详细解释过，请参考前面的回答）</p><p><strong>13. EventBus 的原理是什么</strong></p><ul><li><p><strong>EventBus（事件总线）</strong> 是一种用于在 Vue 组件之间进行通信的简单机制。</p></li><li><p><strong>原理：</strong></p><ul><li>创建一个空的 Vue 实例作为中央事件总线。</li><li>组件 A 通过 <code>$emit</code> 方法触发一个事件，并传递数据。</li><li>组件 B 通过 <code>$on</code> 方法监听该事件，并在事件触发时执行回调函数，接收数据。</li><li>组件可以通过<code>$off</code>方法移除事件监听器</li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建 EventBus</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();<br><br><span class="hljs-comment">// 组件 A</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello from Component A&#x27;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// 组件 B</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 输出 &quot;Hello from Component A&quot;</span><br>    &#125;);<br>  &#125;,<br>  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在组件销毁前移除事件监听，避免内存泄漏</span><br>    <span class="hljs-title class_">EventBus</span>.$off(<span class="hljs-string">&#x27;message&#x27;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p><strong>14. 多个回调函数嵌套会怎样</strong></p><ul><li><p><strong>回调地狱（Callback Hell）：</strong></p><ul><li>多个异步操作的回调函数层层嵌套，导致代码难以阅读、维护和调试。</li><li>代码呈现出“金字塔”形状，可读性差。</li></ul></li><li><p><strong>问题：</strong></p><ul><li><strong>可读性差：</strong> 代码难以理解和跟踪。</li><li><strong>难以维护：</strong> 修改或添加逻辑困难。</li><li><strong>错误处理困难：</strong> 难以捕获和处理错误。</li><li><strong>难以复用：</strong> 代码难以提取和复用。</li></ul></li><li><p><strong>解决方案：</strong></p><ul><li><strong>Promise：</strong> 使用 Promise 将异步操作链式化，避免回调地狱。</li><li><strong>async&#x2F;await：</strong> 使用 async&#x2F;await 语法糖，使异步代码看起来像同步代码，更易于阅读和理解。</li><li><strong>事件发布&#x2F;订阅模式：</strong> 使用事件发布&#x2F;订阅模式解耦异步操作。</li><li><strong>将回调函数拆分成独立的函数。</strong></li></ul></li></ul><p><strong>15. Promise 三种状态</strong></p><ul><li><strong>Pending（进行中）：</strong> 初始状态，既不是成功也不是失败。</li><li><strong>Fulfilled（已成功）：</strong> 操作成功完成。</li><li><strong>Rejected（已失败）：</strong> 操作失败。</li></ul><p><strong>16. async 和 await</strong></p><ul><li><p><strong><code>async</code>：</strong></p><ul><li>用于声明一个异步函数。</li><li>异步函数总是返回一个 Promise 对象。</li><li>如果异步函数没有显式返回一个 Promise，它会自动将返回值包装在一个 Promise 中。</li></ul></li><li><p><strong><code>await</code>：</strong></p><ul><li>只能在 <code>async</code> 函数内部使用。</li><li>用于等待一个 Promise 对象的结果。</li><li><code>await</code> 表达式会暂停 <code>async</code> 函数的执行，直到 Promise 对象的状态变为 Fulfilled 或 Rejected。</li><li>如果 Promise 对象的状态变为 Fulfilled，<code>await</code> 表达式会返回 Promise 的结果值。</li><li>如果 Promise 对象的状态变为 Rejected，<code>await</code> 表达式会抛出 Promise 的拒绝原因。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error fetching data:&#x27;</span>, error);<br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><p><strong>做题：</strong></p><p><strong>1. 二叉树层序遍历</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!root) &#123;<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> result = [];<br>  <span class="hljs-keyword">const</span> queue = [root];<br><br>  <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> levelSize = queue.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> currentLevel = [];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; levelSize; i++) &#123;<br>      <span class="hljs-keyword">const</span> node = queue.<span class="hljs-title function_">shift</span>();<br>      currentLevel.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br><br>      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span>) &#123;<br>        queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span>) &#123;<br>        queue.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>      &#125;<br>    &#125;<br><br>    result.<span class="hljs-title function_">push</span>(currentLevel);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. Promise 输出题（需要具体题目才能确定输出结果）</strong></p><p><strong>3. 判断链表是否有环</strong><br><strong>快慢指针</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">head</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-property">next</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> slow = head;<br>  <span class="hljs-keyword">let</span> fast = head.<span class="hljs-property">next</span>;<br><br>  <span class="hljs-keyword">while</span> (slow !== fast) &#123;<br>    <span class="hljs-keyword">if</span> (!fast || !fast.<span class="hljs-property">next</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    slow = slow.<span class="hljs-property">next</span>;<br>    fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JS-基本数据类型，存储位置"><a href="#JS-基本数据类型，存储位置" class="headerlink" title="JS 基本数据类型，存储位置**"></a>JS 基本数据类型，存储位置**</h4><ul><li><p><strong>基本数据类型（原始类型）：</strong></p><ul><li><strong>Number：</strong> 数字（整数、浮点数）</li><li><strong>String：</strong> 字符串</li><li><strong>Boolean：</strong> 布尔值（true 或 false）</li><li><strong>Null：</strong> 空值</li><li><strong>Undefined：</strong> 未定义</li><li><strong>Symbol：</strong> 符号（ES6 新增）</li><li><strong>BigInt:</strong> 大整数 (ES2020新增)</li></ul></li><li><p>复杂数据类型(引用类型):</p><ul><li>Object：对象<ul><li>Array：数组</li><li>Function: 函数</li><li>Date</li><li>RegExp</li></ul></li></ul></li><li><p><strong>存储位置：</strong></p><ul><li><strong>基本数据类型：</strong> 值直接存储在<strong>栈内存</strong>中。</li><li><strong>引用数据类型（对象）：</strong> 对象本身存储在<strong>堆内存</strong>中，栈内存中存储的是指向堆内存中对象的引用（地址）。</li></ul></li></ul><p><strong>2. 栈和堆存储有什么区别</strong></p><table><thead><tr><th>特性</th><th>栈（Stack）</th><th>堆（Heap）</th></tr></thead><tbody><tr><td>存储内容</td><td>基本数据类型的值、引用数据类型的引用（地址）</td><td>对象</td></tr><tr><td>管理方式</td><td>自动分配和释放（由操作系统或 JavaScript 引擎管理）</td><td>手动分配和释放（在 C&#x2F;C++ 中）或通过垃圾回收机制自动管理（在 JavaScript 中）</td></tr><tr><td>存储顺序</td><td>后进先出（LIFO）</td><td>无特定顺序</td></tr><tr><td>大小</td><td>较小，固定大小</td><td>较大，动态分配</td></tr><tr><td>速度</td><td>较快</td><td>较慢</td></tr><tr><td>用途</td><td>存储局部变量、函数参数、函数调用栈等</td><td>存储对象、数组等复杂数据结构</td></tr><tr><td>空间分配</td><td>空间由操作系统自动分配</td><td>动态分配,大小不定</td></tr><tr><td>存取方式</td><td>先进后出</td><td></td></tr></tbody></table><p><strong>3. OSI 七层网络模型</strong></p><p>OSI（Open Systems Interconnection，开放系统互连）七层网络模型是一个概念模型，用于描述网络通信的各个层次。</p><table><thead><tr><th>层级</th><th>名称</th><th>功能</th><th>常见协议</th></tr></thead><tbody><tr><td>7</td><td>应用层（Application）</td><td>为应用程序提供网络服务，如文件传输、电子邮件、远程登录等。</td><td>HTTP、HTTPS、FTP、SMTP、POP3、DNS、Telnet 等</td></tr><tr><td>6</td><td>表示层（Presentation）</td><td>数据表示、数据加密、数据压缩等。</td><td>SSL、TLS、JPEG、GIF、ASCII 等</td></tr><tr><td>5</td><td>会话层（Session）</td><td>建立、管理和终止会话（应用程序之间的连接）。</td><td></td></tr><tr><td>4</td><td>传输层（Transport）</td><td>提供可靠的或不可靠的数据传输服务，如 TCP 和 UDP。</td><td>TCP、UDP</td></tr><tr><td>3</td><td>网络层（Network）</td><td>负责数据包的路由和转发，将数据包从源主机传输到目标主机。</td><td>IP、ICMP、ARP、RARP 等</td></tr><tr><td>2</td><td>数据链路层（Data Link）</td><td>将数据包封装成帧，在物理链路上传输，提供差错检测和纠正。</td><td>Ethernet、Wi-Fi、PPP、HDLC 等</td></tr><tr><td>1</td><td>物理层（Physical）</td><td>定义物理介质的特性，如电压、数据速率、连接器类型等，负责传输比特流。</td><td></td></tr></tbody></table><p><strong>4. TCP 和 UDP</strong></p><table><thead><tr><th>特性</th><th>TCP（Transmission Control Protocol，传输控制协议）</th><th>UDP（User Datagram Protocol，用户数据报协议）</th></tr></thead><tbody><tr><td>连接方式</td><td>面向连接（三次握手建立连接，四次挥手断开连接）</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠（数据按序、无差错、不丢失、不重复）</td><td>不可靠（数据可能丢失、重复、乱序）</td></tr><tr><td>传输效率</td><td>较低</td><td>较高</td></tr><tr><td>流量控制</td><td>支持</td><td>不支持</td></tr><tr><td>拥塞控制</td><td>支持</td><td>不支持</td></tr><tr><td>头部开销</td><td>较大（至少 20 字节）</td><td>较小（8 字节）</td></tr><tr><td>应用场景</td><td>对数据可靠性要求较高的应用，如文件传输、电子邮件、网页浏览等</td><td>对数据可靠性要求不高，但对实时性要求较高的应用，如在线视频、语音通话、网络游戏、DNS 查询等</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报</td></tr></tbody></table><p><strong>5. HTTP 和 HTTPS</strong></p><p>（已在前面的回答中详细解释过，请参考前面的回答）</p><p><strong>6. ES6 新特性</strong></p><ul><li><strong>let 和 const：</strong> 块级作用域变量声明。</li><li><strong>箭头函数：</strong> 更简洁的函数定义语法，<code>this</code> 指向定义时的上下文。</li><li><strong>模板字符串：</strong> 使用反引号（&#96;）定义字符串，支持多行字符串和插值表达式。</li><li><strong>解构赋值：</strong> 可以从数组或对象中提取值，并赋给变量。</li><li><strong>默认参数：</strong> 可以为函数参数设置默认值。</li><li><strong>剩余参数：</strong> 使用 <code>...</code> 运算符将剩余的参数收集到一个数组中。</li><li><strong>展开运算符：</strong> 使用 <code>...</code> 运算符将数组或对象展开。</li><li><strong>类（Class）：</strong> 基于原型的面向对象编程的语法糖。</li><li><strong>模块（Module）：</strong> 使用 <code>import</code> 和 <code>export</code> 导入和导出模块。</li><li><strong>Promise：</strong> 用于处理异步操作。</li><li><strong>async&#x2F;await：</strong> 基于 Promise 的异步编程语法糖。</li><li><strong>Set 和 Map：</strong> 新的数据结构。</li><li><strong>Symbol：</strong> 一种新的基本数据类型，表示独一无二的值。</li><li><strong>Proxy 和 Reflect：</strong> 用于创建对象的代理和进行元编程。</li><li><strong>迭代器（Iterator）和生成器（Generator）：</strong> 用于遍历数据结构。</li><li><strong>for…of 循环：</strong> 用于遍历可迭代对象。</li></ul><p><strong>7. 事件循环</strong></p><p>（已在前面的回答中详细解释过，请参考前面的回答）</p><p><strong>8. 安全问题（跨站脚本攻击和伪造跨站请求）</strong></p><ul><li><p><strong>XSS（Cross-Site Scripting，跨站脚本攻击）：</strong></p><ul><li><strong>原理：</strong> 攻击者将恶意脚本注入到受信任的网站中，当用户访问该网站时，恶意脚本会在用户的浏览器中执行。</li><li><strong>类型：</strong><ul><li><strong>存储型 XSS：</strong> 恶意脚本存储在服务器端（如数据库中），当其他用户访问包含恶意脚本的页面时，脚本会被执行。</li><li><strong>反射型 XSS：</strong> 恶意脚本通过 URL 参数或其他方式注入到页面中，当用户点击包含恶意脚本的链接时，脚本会被执行。</li><li><strong>DOM 型 XSS：</strong> 恶意脚本通过修改页面的 DOM 结构来执行。</li></ul></li><li><strong>危害：</strong><ul><li>窃取用户 Cookie 或其他敏感信息。</li><li>劫持用户会话。</li><li>篡改页面内容。</li><li>传播恶意软件。</li></ul></li><li><strong>防御：</strong><ul><li><strong>输入验证：</strong> 对用户输入的数据进行严格的验证和过滤，去除或转义特殊字符。</li><li><strong>输出编码：</strong> 对输出到页面的数据进行 HTML 编码，将特殊字符转换为 HTML 实体。</li><li><strong>使用 HttpOnly Cookie：</strong> 禁止 JavaScript 访问 Cookie，防止 Cookie 被窃取。</li><li><strong>设置 CSP（Content Security Policy）：</strong> 通过 HTTP 响应头或 HTML meta 标签设置内容安全策略，限制浏览器可以加载的资源来源。</li><li><strong>使用 XSS 过滤器：</strong> 使用一些工具或库来自动检测和过滤 XSS 攻击。</li></ul></li></ul></li><li><p><strong>CSRF（Cross-Site Request Forgery，跨站请求伪造）：</strong></p><ul><li><strong>原理：</strong> 攻击者诱导用户在已登录的网站上执行非本意的操作，利用用户的登录状态发起恶意请求。</li><li><strong>危害：</strong><ul><li>修改用户资料。</li><li>发布恶意内容。</li><li>进行非法交易。</li></ul></li><li><strong>防御：</strong><ul><li><strong>验证 Referer 头部：</strong> 检查 HTTP 请求的 <code>Referer</code> 头部，确保请求来自合法的来源。</li><li><strong>使用 CSRF Token：</strong> 服务器端生成一个随机的 CSRF Token，并将其嵌入到表单或 URL 中。用户提交请求时，需要携带该 Token。服务器端验证 Token 的合法性。</li><li><strong>使用 SameSite Cookie：</strong> 将 Cookie 的 <code>SameSite</code> 属性设置为 <code>Strict</code> 或 <code>Lax</code>，限制 Cookie 在跨站请求中的发送。</li><li><strong>验证码</strong></li><li><strong>双重 Cookie 验证</strong></li></ul></li></ul></li></ul><p><strong>9. 跨域的几种方法</strong></p><p>（已在前面的回答中详细解释过，请参考前面的回答）</p><p><strong>10. Vue2 和 Vue3 的区别</strong></p><p>（已在前面的回答中详细解释过，请参考前面的回答）</p><p><strong>11. Vue 生命周期</strong></p><p>（已在前面的回答中详细解释过，请参考前面的回答）</p><p><strong>事件循环和手撕快排</strong></p><p>（已在前面的回答中详细解释过，请参考前面的回答）</p><p>希望这些解答对你有所帮助！</p><h4 id="1-HTTP-和-HTTPS-有什么区别"><a href="#1-HTTP-和-HTTPS-有什么区别" class="headerlink" title="1. HTTP 和 HTTPS 有什么区别**"></a>1. HTTP 和 HTTPS 有什么区别**</h4><table><thead><tr><th>特性</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>全称</td><td>Hypertext Transfer Protocol</td><td>Hypertext Transfer Protocol Secure</td></tr><tr><td>安全性</td><td>不安全，明文传输</td><td>安全，通过 SSL&#x2F;TLS 加密传输</td></tr><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>连接方式</td><td>无状态</td><td>需要建立 SSL&#x2F;TLS 连接，有状态</td></tr><tr><td>性能</td><td>较快</td><td>较慢（因为加密和解密需要消耗计算资源）</td></tr><tr><td>证书</td><td>不需要</td><td>需要 CA 证书</td></tr><tr><td>作用</td><td>用于在 Web 浏览器和服务器之间传输数据</td><td>用于在 Web 浏览器和服务器之间安全地传输数据，保护数据隐私和完整性，防止中间人攻击。</td></tr><tr><td>URL开头</td><td><code>http://</code></td><td><code>https://</code></td></tr></tbody></table><p><strong>总结区别：</strong></p><ul><li><strong>安全性：</strong> HTTPS 通过 SSL&#x2F;TLS 协议对数据进行加密，提供了身份验证、数据完整性和机密性，而 HTTP 是明文传输，容易被窃听和篡改。</li><li><strong>端口：</strong> HTTP 默认端口是 80，HTTPS 默认端口是 443。</li><li><strong>连接方式：</strong> HTTPS 需要建立 SSL&#x2F;TLS 连接，这个过程涉及到证书验证和密钥交换，因此 HTTPS 连接比 HTTP 连接更复杂，也更耗时。</li><li><strong>证书：</strong> HTTPS 需要向 CA（证书颁发机构）申请证书，用于验证服务器的身份，而 HTTP 不需要。</li></ul><h4 id="2-HTTPS-怎么校验"><a href="#2-HTTPS-怎么校验" class="headerlink" title="2. HTTPS 怎么校验**"></a>2. HTTPS 怎么校验**</h4><p>HTTPS 的校验过程（也称为 SSL&#x2F;TLS 握手）主要包括以下几个步骤：</p><ol><li><p><strong>客户端发起 HTTPS 请求：</strong></p><ul><li>客户端向服务器发送一个 HTTPS 请求，请求中包含客户端支持的 SSL&#x2F;TLS 版本、加密算法等信息。</li></ul></li><li><p><strong>服务器返回证书：</strong></p><ul><li>服务器收到请求后，返回其 SSL&#x2F;TLS 证书。</li><li>证书中包含服务器的公钥、证书颁发机构（CA）的信息、证书的有效期等。</li></ul></li><li><p><strong>客户端验证证书：</strong></p><ul><li>客户端收到证书后，会验证证书的合法性：<ul><li><strong>检查证书是否由受信任的 CA 签发。</strong> 浏览器内置了受信任的 CA 列表。</li><li><strong>检查证书是否过期。</strong></li><li><strong>检查证书中的域名是否与请求的域名匹配。</strong></li><li><strong>检查证书的吊销状态。</strong> 浏览器会通过 CRL（证书吊销列表）或 OCSP（在线证书状态协议）来检查证书是否已被吊销。</li></ul></li><li>如果证书验证失败，浏览器会向用户发出警告。</li></ul></li><li><p><strong>客户端生成随机密钥：</strong></p><ul><li>如果证书验证通过，客户端会生成一个随机的对称密钥（也称为会话密钥）。</li></ul></li><li><p><strong>客户端使用服务器公钥加密密钥：</strong></p><ul><li>客户端使用服务器证书中的公钥加密生成的对称密钥，并将加密后的密钥发送给服务器。</li></ul></li><li><p><strong>服务器使用私钥解密密钥：</strong></p><ul><li>服务器收到加密后的密钥后，使用自己的私钥解密，得到客户端生成的对称密钥。</li></ul></li><li><p><strong>建立安全连接：</strong></p><ul><li>客户端和服务器都拥有了相同的对称密钥，后续的通信都使用该密钥进行加密和解密。</li></ul></li></ol><p><strong>总结：</strong><br>HTTPS 的校验过程主要依靠 SSL&#x2F;TLS 证书和非对称加密、对称加密算法。证书用于验证服务器的身份，公钥用于加密对称密钥，对称密钥用于加密后续的通信数据。</p><h4 id="3-浏览器怎么渲染页面"><a href="#3-浏览器怎么渲染页面" class="headerlink" title="3. 浏览器怎么渲染页面**"></a>3. 浏览器怎么渲染页面**</h4><p>浏览器渲染页面的过程（也称为关键渲染路径）大致如下：</p><ol><li><p><strong>解析 HTML：</strong></p><ul><li>浏览器从上到下解析 HTML 文档，构建 DOM（Document Object Model）树。DOM 树表示了 HTML 文档的结构。</li></ul></li><li><p><strong>解析 CSS：</strong></p><ul><li>浏览器解析 CSS 样式表，构建 CSSOM（CSS Object Model）树。CSSOM 树表示了 CSS 样式的结构。</li></ul></li><li><p><strong>构建渲染树（Render Tree）：</strong></p><ul><li>浏览器将 DOM 树和 CSSOM 树合并成渲染树。渲染树只包含可见的节点，以及这些节点的样式信息。</li></ul></li><li><p><strong>布局（Layout）：</strong></p><ul><li>浏览器计算渲染树中每个节点在屏幕上的位置和大小。这个过程也称为重排（Reflow）。</li></ul></li><li><p><strong>绘制（Paint）：</strong></p><ul><li>浏览器根据渲染树和布局信息，将每个节点绘制到屏幕上。这个过程也称为重绘（Repaint）。</li></ul></li><li><p><strong>合成(Composite):</strong></p></li></ol><ul><li>浏览器将多个层进行和成。</li></ul><p><strong>4. 手写一个树结点的 search，要求返回节点和节点以上的路径的值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">searchTreeNode</span>(<span class="hljs-params">root, targetValue</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!root) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> path = [];<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>) &#123;<br>    path.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">value</span>);<br><br>    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">value</span> === targetValue) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">node</span>: node,<br>        <span class="hljs-attr">path</span>: path,<br>      &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> node.<span class="hljs-property">children</span>) &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">traverse</span>(child);<br>        <span class="hljs-keyword">if</span> (result) &#123;<br>          <span class="hljs-keyword">return</span> result;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    path.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 回溯，移除当前节点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">traverse</span>(root);<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> tree = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">children</span>: [<br>        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> &#125;,<br>        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">5</span> &#125;,<br>      ],<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">children</span>: [<br>        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">6</span> &#125;,<br>        &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">7</span> &#125;,<br>      ],<br>    &#125;,<br>  ],<br>&#125;;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">searchTreeNode</span>(tree, <span class="hljs-number">6</span>);<br><span class="hljs-keyword">if</span> (result) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Found node:&quot;</span>, result.<span class="hljs-property">node</span>); <span class="hljs-comment">// 输出：Found node: &#123;value: 6&#125;</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Path:&quot;</span>, result.<span class="hljs-property">path</span>); <span class="hljs-comment">// 输出：Path: [1, 3, 6]</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Node not found&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>代码解释：</strong></p><ul><li><code>searchTreeNode(root, targetValue)</code>：<ul><li><code>root</code>：树的根节点。</li><li><code>targetValue</code>：要查找的目标值。</li><li>返回值：如果找到目标节点，返回一个包含 <code>node</code>（找到的节点）和 <code>path</code>（从根节点到目标节点的路径值数组）的对象；如果未找到，返回 <code>null</code>。</li></ul></li><li><code>path</code> 数组：用于存储从根节点到当前节点的路径值。</li><li><code>traverse(node)</code>：递归遍历树的函数。<ul><li>将当前节点的值添加到 <code>path</code> 数组。</li><li>如果当前节点的值等于目标值，返回包含 <code>node</code> 和 <code>path</code> 的对象。</li><li>如果当前节点有子节点，递归遍历子节点。</li><li>如果子节点中找到目标节点，直接返回结果。</li><li>如果当前节点的所有子节点都没有找到目标节点，将当前节点从 <code>path</code> 数组中移除（回溯），并返回 <code>null</code>。</li></ul></li></ul><p>希望这些解答对你有所帮助！</p><h4 id="1-前端怎么携带-Cookie，后端怎么配置携带-Cookie"><a href="#1-前端怎么携带-Cookie，后端怎么配置携带-Cookie" class="headerlink" title="1. 前端怎么携带 Cookie，后端怎么配置携带 Cookie**"></a>1. 前端怎么携带 Cookie，后端怎么配置携带 Cookie**</h4><ul><li><p><strong>前端携带 Cookie：</strong></p><ul><li><strong>自动携带：</strong> 浏览器会自动携带符合以下条件的 Cookie：<ul><li>Cookie 的 <code>domain</code> 属性与当前请求的域名匹配（或为父域名）。</li><li>Cookie 的 <code>path</code> 属性与当前请求的路径匹配。</li><li>Cookie 没有过期。</li><li>Cookie 没有设置 <code>HttpOnly</code> 属性（如果设置了，则只能通过 HTTP 请求携带，JavaScript 无法访问）。</li><li>Cookie 的 <code>Secure</code> 属性与当前请求的协议匹配（如果设置了 <code>Secure</code>，则只能通过 HTTPS 请求携带）。</li><li>SameSite 属性:</li><li>Strict: 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</li><li>Lax: 允许部分第三方请求携带 Cookie</li><li>None: 无论是否跨站都会发送 Cookie</li></ul></li><li><strong>手动设置：</strong> 前端可以使用 JavaScript 的 <code>document.cookie</code> 属性来设置、读取和删除 Cookie。但是需要注意，手动设置的 Cookie 同样需要满足上述条件才能被自动携带。</li></ul></li><li><p><strong>后端配置携带 Cookie：</strong></p><ul><li>后端通过在 HTTP 响应头中设置 <code>Set-Cookie</code> 字段来告诉浏览器设置 Cookie。</li><li><code>Set-Cookie</code> 字段的格式：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-attribute">Domain</span>=&lt;domain-value&gt;; <span class="hljs-attribute">Path</span>=&lt;path-value&gt;; <span class="hljs-attribute">Expires</span>=&lt;date&gt;; <span class="hljs-attribute">Max-Age</span>=&lt;number&gt;; Secure; HttpOnly; <span class="hljs-attribute">SameSite</span>=&lt;Strict|Lax|None&gt;<br></code></pre></td></tr></table></figure><ul><li><code>&lt;cookie-name&gt;=&lt;cookie-value&gt;</code>：Cookie 的名称和值。</li><li><code>Domain=&lt;domain-value&gt;</code>：Cookie 的作用域（域名）。</li><li><code>Path=&lt;path-value&gt;</code>：Cookie 的作用路径。</li><li><code>Expires=&lt;date&gt;</code>：Cookie 的过期时间（绝对时间）。</li><li><code>Max-Age=&lt;number&gt;</code>：Cookie 的过期时间（相对时间，单位为秒）。</li><li><code>Secure</code>：仅通过 HTTPS 连接传输 Cookie。</li><li><code>HttpOnly</code>：禁止 JavaScript 访问 Cookie。</li><li><code>SameSite</code>: 控制 Cookie 在跨站请求中的行为</li></ul></li></ul></li></ul><p><strong>2. 跨域问题</strong></p><ul><li><p><strong>什么是跨域？</strong></p><ul><li>当一个请求的协议、域名、端口号三者之一与当前页面的协议、域名、端口号不一致时，就会发生跨域。</li><li>跨域是浏览器的同源策略（Same-Origin Policy）导致的，同源策略是一种安全机制，用于限制不同源之间的资源访问。</li></ul></li><li><p><strong>跨域解决方案：</strong></p><ul><li><strong>CORS（Cross-Origin Resource Sharing）</strong>：跨域资源共享，是一种 W3C 标准，也是最常用的跨域解决方案。<ul><li>服务器端设置 HTTP 响应头 <code>Access-Control-Allow-Origin</code> 来允许指定的域名访问资源。</li><li>还可以设置其他相关的响应头，如 <code>Access-Control-Allow-Methods</code>、<code>Access-Control-Allow-Headers</code>、<code>Access-Control-Allow-Credentials</code> 等。</li></ul></li><li><strong>JSONP</strong>：利用 <code>&lt;script&gt;</code> 标签可以跨域请求资源的特性，通过动态创建 <code>&lt;script&gt;</code> 标签来实现跨域数据访问。<ul><li>只支持 GET 请求。</li><li>需要服务器端配合返回特定格式的数据。</li></ul></li><li><strong>代理服务器</strong>：在同源服务器上设置代理，将跨域请求转发到目标服务器，并将结果返回给客户端。<ul><li>可以隐藏真实的请求地址。</li><li>需要配置代理服务器。</li></ul></li><li><strong>postMessage</strong>: HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一</li><li><strong>WebSocket:</strong> WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯.</li></ul></li></ul><h4 id="3-浏览器合成层"><a href="#3-浏览器合成层" class="headerlink" title="3. 浏览器合成层**"></a>3. 浏览器合成层**</h4><ul><li><p><strong>什么是合成层？</strong></p><ul><li>浏览器渲染页面时，会将页面分成多个层（Layer），每个层独立渲染。</li><li>合成层（Compositing Layer）是指具有特定属性的层，它们会被提升到 GPU 中进行渲染，从而提高渲染性能。</li></ul></li><li><p><strong>哪些属性会触发合成层？</strong></p><ul><li><code>transform: translateZ(0)</code> 或 <code>transform-3d</code></li><li><code>will-change: transform</code></li><li><code>opacity</code></li><li><code>filter</code></li><li>具有 CSS 动画或过渡的元素</li><li>具有 <code>position: fixed</code> 的元素</li><li>视频元素 (<code>&lt;video&gt;</code>)</li></ul></li><li><p><strong>合成层的好处：</strong></p><ul><li>GPU 加速，提高渲染性能。</li><li>减少重绘和重排，优化页面流畅度。</li></ul></li><li><p><strong>合成层的缺点：</strong></p><ul><li>占用额外的内存。</li><li>过多的合成层可能会导致性能下降。</li></ul></li></ul><h4 id="4-浏览器缓存机制，挖的比较深"><a href="#4-浏览器缓存机制，挖的比较深" class="headerlink" title="4. 浏览器缓存机制，挖的比较深**"></a>4. 浏览器缓存机制，挖的比较深**</h4><ul><li><p><strong>浏览器缓存的分类：</strong></p><ul><li><strong>强缓存</strong>：<ul><li>浏览器直接从本地缓存中读取资源，不发送请求到服务器。</li><li>通过 <code>Expires</code> 和 <code>Cache-Control</code> 响应头控制。<ul><li><code>Expires</code>：指定资源的过期时间（绝对时间）。</li><li><code>Cache-Control</code>：更灵活的缓存控制，可以设置 <code>max-age</code>（相对时间）、<code>no-cache</code>、<code>no-store</code>、<code>public</code>、<code>private</code> 等指令。</li></ul></li></ul></li><li><strong>协商缓存</strong>：<ul><li>浏览器发送请求到服务器，服务器判断资源是否过期，如果未过期则返回 304 Not Modified，浏览器从本地缓存中读取资源；如果已过期则返回新的资源。</li><li>通过 <code>Last-Modified</code> &#x2F; <code>If-Modified-Since</code> 和 <code>ETag</code> &#x2F; <code>If-None-Match</code> 响应头控制。<ul><li><code>Last-Modified</code>：服务器返回资源的最后修改时间。</li><li><code>If-Modified-Since</code>：浏览器发送请求时携带上次获取到的 <code>Last-Modified</code> 值。</li><li><code>ETag</code>：服务器返回资源的唯一标识符。</li><li><code>If-None-Match</code>：浏览器发送请求时携带上次获取到的 <code>ETag</code> 值。</li></ul></li></ul></li></ul></li><li><p><strong>缓存流程：</strong></p><ol><li>浏览器发起请求。</li><li>检查是否有强缓存，如果有且未过期，则直接从本地缓存读取资源（状态码 200 OK (from cache)）。</li><li>如果没有强缓存或强缓存已过期，则发送请求到服务器。</li><li>服务器检查协商缓存，如果资源未修改，则返回 304 Not Modified，浏览器从本地缓存读取资源。</li><li>如果资源已修改，则服务器返回新的资源（状态码 200 OK）。</li></ol></li><li><p><strong>更深入的缓存机制：</strong></p><ul><li><strong>Service Worker 缓存</strong>：可以拦截和处理网络请求，实现更精细的缓存控制，甚至可以实现离线访问。</li><li><strong>HTTP&#x2F;2 Server Push</strong>：服务器可以主动推送资源到浏览器缓存，减少请求延迟。</li><li><strong>Cache API</strong>: 提供了对缓存的编程控制。</li></ul></li></ul><h4 id="5-option-预检查是什么意思"><a href="#5-option-预检查是什么意思" class="headerlink" title="5. option 预检查是什么意思**"></a>5. option 预检查是什么意思**</h4><ul><li><p>OPTIONS 请求是 HTTP 协议中的一种方法，用于获取服务器支持的请求方法、允许的请求头、是否允许跨域等信息。</p></li><li><p>预检查 (Preflight Request): 浏览器在发送跨域请求前自动发起的 options 请求。</p></li><li><p><strong>什么情况下会触发预检请求？</strong></p><ul><li>跨域请求。</li><li>请求方法不是 GET、HEAD、POST。</li><li>请求头中包含自定义头部（除了 <code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code> 等安全头部）。</li><li><code>Content-Type</code> 的值不是 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>。</li></ul></li><li><p><strong>预检请求的作用：</strong></p><ul><li>检查服务器是否允许跨域请求。</li><li>获取服务器支持的请求方法和请求头。</li><li>确保跨域请求的安全性。</li></ul></li></ul><h4 id="6-Vite-的预构建是什么意思"><a href="#6-Vite-的预构建是什么意思" class="headerlink" title="6. Vite 的预构建是什么意思**"></a>6. Vite 的预构建是什么意思**</h4><ul><li>Vite 的预构建（Pre-bundling）是指在开发环境下，Vite 会将项目中的依赖（如 npm 包）预先打包成 ES 模块，并缓存起来。</li><li><strong>预构建的好处：</strong><ul><li><strong>提高开发服务器启动速度</strong>：Vite 不需要每次启动都重新打包所有依赖，只需要加载缓存的预构建结果。</li><li><strong>减少模块转换次数</strong>：Vite 将 CommonJS 或 UMD 格式的依赖转换为 ES 模块，只需要转换一次，后续可以直接使用。</li><li><strong>优化模块解析</strong>：Vite 将具有多个内部模块的依赖（如 lodash-es）合并成一个模块，减少 HTTP 请求数量。</li></ul></li></ul><h4 id="7-手写防抖和防抖的进阶版本"><a href="#7-手写防抖和防抖的进阶版本" class="headerlink" title="7. 手写防抖和防抖的进阶版本**"></a>7. 手写防抖和防抖的进阶版本**</h4><ul><li><p><strong>防抖（Debounce）</strong>：</p><ul><li>在事件触发后，延迟一段时间执行回调函数。如果在这段时间内再次触发事件，则重新计时。</li><li>适用于只需要最后一次触发结果的场景，如搜索框输入、窗口大小调整。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timerId;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timerId);<br>    timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>防抖的进阶版本（立即执行）</strong>：</p><ul><li>第一次触发事件时立即执行回调函数，后续触发事件则延迟执行。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay, immediate = <span class="hljs-literal">false</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-comment">// 如果已经执行过，不再执行</span><br>            <span class="hljs-keyword">let</span> callNow = !timeout;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>            &#125;, delay)<br>            <span class="hljs-keyword">if</span> (callNow) func.<span class="hljs-title function_">apply</span>(context, args)<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                func.<span class="hljs-title function_">apply</span>(context, args)<br>            &#125;, delay);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>8. 虚拟列表定高和不定高</strong></p><ul><li><p><strong>虚拟列表（Virtual List）</strong>：</p><ul><li>一种优化长列表渲染性能的技术，只渲染可见区域的列表项，不可见区域的列表项不渲染或延迟渲染。</li></ul></li><li><p><strong>定高虚拟列表：</strong></p><ul><li>每个列表项的高度是固定的。</li><li>实现简单，只需要计算可见区域的起始索引和结束索引即可。</li><li>适用于列表项高度一致的场景。</li></ul></li><li><p><strong>不定高虚拟列表：</strong></p><ul><li>每个列表项的高度是不确定的。</li><li>实现复杂，需要预估每个列表项的高度，并在渲染过程中动态调整。</li><li>适用于列表项高度不一致的场景。</li><li>常用方法：<ul><li><strong>预估高度</strong>：根据列表项的平均高度或典型高度进行预估。</li><li><strong>测量高度</strong>：在渲染过程中，使用 <code>getBoundingClientRect()</code> 等方法测量实际高度，并更新缓存的高度。</li><li><strong>二分查找</strong>：对于已排序的列表，可以使用二分查找来快速定位可见区域的起始索引。</li><li>使用 Intersection Observer API: 监听元素是否出现在可视区域内。</li></ul></li></ul></li></ul><p><strong>9. 重绘和重排</strong></p><ul><li><p><strong>重排（Reflow）</strong>：</p><ul><li>当 DOM 结构、元素的尺寸、位置、隐藏&#x2F;显示等发生变化时，浏览器需要重新计算元素的几何属性，并重新构建渲染树。</li><li>开销较大，应尽量避免。</li></ul></li><li><p><strong>重绘（Repaint）</strong>：</p><ul><li>当元素的样式（如颜色、背景）发生变化，但不影响其几何属性时，浏览器只需要重新绘制元素的外观。</li><li>开销较小，但仍应尽量减少。</li></ul></li><li><p><strong>触发重排的操作：</strong></p><ul><li>添加或删除可见的 DOM 元素。</li><li>改变元素的尺寸、位置。</li><li>改变窗口大小。</li><li>获取元素的偏移量（<code>offsetLeft</code>、<code>offsetTop</code>、<code>offsetWidth</code>、<code>offsetHeight</code> 等）。</li></ul></li><li><p><strong>触发重绘的操作：</strong></p><ul><li>改变元素的颜色、背景、边框样式等。</li></ul></li><li><p><strong>优化建议：</strong></p><ul><li><strong>减少 DOM 操作</strong>：合并多次 DOM 操作为一次，使用 DocumentFragment 或虚拟 DOM。</li><li><strong>避免频繁获取元素的偏移量</strong>：将偏移量缓存起来，避免重复计算。</li><li><strong>使用 CSS3 动画</strong>：CSS3 动画通常会创建合成层，减少重绘和重排。</li><li><strong>使用 will-change 属性</strong>：提前告知浏览器元素将要发生变化，优化渲染性能。</li></ul></li></ul><h4 id="3-懒加载具体是怎么做的"><a href="#3-懒加载具体是怎么做的" class="headerlink" title="3. 懒加载具体是怎么做的**"></a>3. 懒加载具体是怎么做的**</h4><ul><li><p><strong>原理：</strong></p><ul><li>懒加载（Lazy Loading）是一种延迟加载资源（如图片、视频）的技术，只在资源进入可视区域时才加载。</li><li>可以减少页面初始加载时间，提高页面性能。</li></ul></li><li><p><strong>实现方式：</strong></p><ol><li><p><strong>设置占位符：</strong></p><ul><li>将 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性设置为一个占位符图片（如 1x1 像素的透明 GIF 或低质量的缩略图）。</li><li>将真实的图片 URL 存储在 <code>&lt;img&gt;</code> 标签的自定义属性中（如 <code>data-src</code>）。</li></ul></li><li><p><strong>监听滚动事件：</strong></p><ul><li>监听 <code>window</code> 对象的 <code>scroll</code> 事件（或使用 <code>Intersection Observer API</code>）。</li><li>在滚动事件处理函数中，检查图片是否进入可视区域。</li></ul></li><li><p><strong>判断是否进入可视区域：</strong></p><ul><li>使用 <code>getBoundingClientRect()</code> 方法获取图片元素相对于视口的位置信息。</li><li>判断图片的 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 属性是否在视口的范围内。</li></ul></li><li><p><strong>加载图片：</strong></p><ul><li>如果图片进入可视区域，将 <code>data-src</code> 属性的值赋给 <code>src</code> 属性，浏览器会自动加载图片。</li><li>（可选）移除 <code>data-src</code> 属性。</li></ul></li><li><p><strong>使用 Intersection Observer API（推荐）：</strong></p><ul><li>Intersection Observer API 是一种更现代、更高效的监听元素可见性的方法。</li><li>它可以异步观察目标元素与其祖先元素或视口的交叉状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> images = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img[data-src]&#x27;</span>);<br><br><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> &#123;<br>  entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">entry</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) &#123;<br>      <span class="hljs-keyword">const</span> img = entry.<span class="hljs-property">target</span>;<br>      img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>;<br>      observer.<span class="hljs-title function_">unobserve</span>(img); <span class="hljs-comment">// 加载完成后停止观察</span><br>    &#125;<br>  &#125;);<br>&#125;);<br><br>images.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> &#123;<br>  observer.<span class="hljs-title function_">observe</span>(img);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol></li></ul><p><strong>4. 关于图片的渲染，除了懒加载还有没有其他的方式可以提升性能</strong></p><ul><li><strong>图片压缩：</strong><ul><li>使用工具（如 TinyPNG、ImageOptim）或在线服务压缩图片大小，减少带宽消耗。</li><li>选择合适的图片格式（如 WebP、JPEG、PNG）。</li></ul></li><li><strong>使用适当的图片尺寸：</strong><ul><li>根据图片在页面上的显示大小，提供相应尺寸的图片，避免加载过大的图片。</li><li>使用响应式图片技术（如 <code>&lt;picture&gt;</code> 元素、<code>srcset</code> 属性）根据不同的屏幕尺寸加载不同尺寸的图片。</li></ul></li><li><strong>图片懒加载：</strong> （已在上面详细解释）</li><li><strong>渐进式图片：</strong> 使用渐进式 JPEG 或交错式 PNG，图片会先显示模糊的轮廓，然后逐渐清晰。</li><li><strong>CSS Sprites（雪碧图）：</strong><ul><li>将多个小图标合并成一张大图，通过 CSS 的 <code>background-position</code> 属性来显示不同的图标。</li><li>减少 HTTP 请求数量。</li></ul></li><li><strong>使用 CDN：</strong><ul><li>将图片等静态资源部署到 CDN（内容分发网络）上，从离用户最近的服务器加载资源，加快加载速度。</li></ul></li><li><strong>使用 Base64 编码：</strong><ul><li>将小图标或小图片转换为 Base64 编码，直接嵌入到 HTML 或 CSS 中，减少 HTTP 请求。</li><li>适用于非常小的图片，不适用于大图。</li></ul></li><li><strong>使用 WebP 格式：</strong><ul><li>WebP 是一种现代的图片格式，提供更好的压缩效果和图像质量。</li><li>需要考虑浏览器兼容性。</li></ul></li><li><strong>使用矢量图（SVG）：</strong><ul><li>对于图标、logo 等简单图形，使用 SVG 格式可以实现无损缩放，并且文件体积通常更小。</li></ul></li><li><strong>预加载：</strong><br>*   使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 预加载关键图片。<br>*   <code>&lt;link rel=&quot;preload&quot; as=&quot;image&quot; href=&quot;important.jpg&quot;&gt;</code></li><li><strong>HTTP缓存</strong>：<ul><li>对图片开启HTTP缓存</li></ul></li></ul><p><strong>5. ES6 里 var 和 let 的区别</strong></p><table><thead><tr><th>特性</th><th><code>var</code></th><th><code>let</code></th></tr></thead><tbody><tr><td>作用域</td><td>函数作用域</td><td>块级作用域（<code>&#123;&#125;</code>）</td></tr><tr><td>变量提升</td><td>存在变量提升（声明会被提升到函数顶部，但初始化不会）</td><td>不存在变量提升（在声明之前访问会抛出 <code>ReferenceError</code>）</td></tr><tr><td>重复声明</td><td>允许重复声明</td><td>不允许在同一作用域内重复声明</td></tr><tr><td>全局对象属性</td><td>在全局作用域中声明的 <code>var</code> 变量会成为全局对象（如 <code>window</code>）的属性</td><td>在全局作用域中声明的 <code>let</code> 变量不会成为全局对象的属性</td></tr><tr><td>暂时性死区</td><td>无</td><td>存在暂时性死区（Temporal Dead Zone，TDZ），在声明之前访问变量会抛出错误</td></tr><tr><td>循环中的行为</td><td>在循环中使用 <code>var</code> 声明的变量，循环结束后该变量的值是最后一次循环的值</td><td>在循环中使用 <code>let</code> 声明的变量，每次循环都会创建一个新的变量，作用域仅限于当前循环</td></tr><tr><td><code>const</code></td><td><code>const</code> 声明一个常量，其值不能被重新赋值。</td><td>与let 一样具有块级作用域</td></tr></tbody></table><p><strong>6. 在浏览器里没有声明一个 const 变量但先使用它，后面再去声明它，这样会出现什么问题吗</strong></p><p>会抛出 <code>ReferenceError</code> 错误。</p><ul><li><strong>原因：</strong><ul><li><code>const</code> 声明的变量存在暂时性死区（TDZ）。</li><li>在变量声明之前访问该变量会抛出 <code>ReferenceError</code>。</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myVar); <span class="hljs-comment">// 抛出 ReferenceError: Cannot access &#x27;myVar&#x27; before initialization</span><br><span class="hljs-keyword">const</span> myVar = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><strong>7. HTTP 的请求方法有哪些</strong></p><ul><li><strong>GET：</strong> 获取资源。</li><li><strong>POST：</strong> 提交数据（如表单提交）。</li><li><strong>PUT：</strong> 更新资源（提供完整资源）。</li><li><strong>PATCH：</strong> 更新资源（提供部分资源）。</li><li><strong>DELETE：</strong> 删除资源。</li><li><strong>HEAD：</strong> 获取资源的元信息（如响应头），不返回响应体。</li><li><strong>OPTIONS：</strong> 获取服务器支持的请求方法、允许的请求头等信息（用于跨域预检请求）。</li><li><strong>TRACE：</strong> 回显服务器收到的请求，主要用于测试或诊断。</li><li><strong>CONNECT：</strong> 建立到服务器的隧道，用于代理服务器。</li></ul><p><strong>8. 什么是跨域？解决跨域问题有哪些方式（已在前面的回答中详细解释过，请参考前面的回答）</strong></p><p><strong>9. 为什么这些请求不能跨域，但这些 js 和 css 静态资源可以跨域</strong></p><ul><li><p><strong>不能跨域的请求：</strong></p><ul><li>XMLHttpRequest（XHR）和 Fetch API 发起的请求受到同源策略的限制，不能跨域。</li><li>这是为了防止恶意网站窃取用户数据或进行跨站脚本攻击（XSS）。</li></ul></li><li><p><strong>可以跨域的静态资源：</strong></p><ul><li><code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;iframe&gt;</code> 等标签引入的资源不受同源策略的限制，可以跨域。</li><li>这是因为这些标签通常用于加载外部资源，如 JavaScript 库、图片、样式表等，如果限制跨域会影响 Web 的正常使用。</li></ul></li><li><p><strong>根本原因：</strong></p><ul><li>同源策略是针对 XMLHttpRequest 和 Fetch API 等用于数据交互的 API 的限制，而不是针对所有网络请求的限制。</li><li>浏览器认为加载 JavaScript、CSS、图片等静态资源通常是安全的，不会导致数据泄露或安全问题。</li></ul></li></ul><p><strong>10. 手写题</strong></p><p><strong>1. 找最大版本号</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMaxVersion</span>(<span class="hljs-params">versions</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!versions || versions.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> maxVersion = versions[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; versions.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> currentVersion = versions[i];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareVersions</span>(currentVersion, maxVersion) &gt; <span class="hljs-number">0</span>) &#123;<br>      maxVersion = currentVersion;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> maxVersion;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">compareVersions</span>(<span class="hljs-params">v1, v2</span>) &#123;<br>    <span class="hljs-keyword">const</span> v1Parts = v1.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">const</span> v2Parts = v2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br><br>    <span class="hljs-keyword">const</span> maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(v1Parts.<span class="hljs-property">length</span>, v2Parts.<span class="hljs-property">length</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxLength; i++) &#123;<br>      <span class="hljs-keyword">const</span> v1Part = <span class="hljs-built_in">parseInt</span>(v1Parts[i] || <span class="hljs-number">0</span>); <span class="hljs-comment">// 处理位数不足的情况</span><br>      <span class="hljs-keyword">const</span> v2Part = <span class="hljs-built_in">parseInt</span>(v2Parts[i] || <span class="hljs-number">0</span>);<br><br>      <span class="hljs-keyword">if</span> (v1Part &gt; v2Part) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1Part &lt; v2Part) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 版本号相等</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>分割子串的函数：</strong> JavaScript 中分割字符串的函数是 <code>split()</code>。</li></ul><p><strong>2. 对象路径解构（对象扁平化）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">flattenObject</span>(<span class="hljs-params">obj, prefix = <span class="hljs-string">&#x27;&#x27;</span>, result = []</span>) &#123;<br>   <span class="hljs-keyword">if</span> (!obj || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">const</span> newKey = prefix ? <span class="hljs-string">`<span class="hljs-subst">$&#123;prefix&#125;</span>.<span class="hljs-subst">$&#123;key&#125;</span>`</span> : key;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-title function_">flattenObject</span>(obj[key], newKey, result);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        result.<span class="hljs-title function_">push</span>(&#123;[newKey]: obj[key]&#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;111&quot;</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;222&quot;</span>,<br>    <span class="hljs-attr">d</span>: &#123;<br>      <span class="hljs-attr">e</span>: <span class="hljs-string">&quot;333&quot;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;peter&quot;</span><br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> flattened = <span class="hljs-title function_">flattenObject</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flattened);<br></code></pre></td></tr></table></figure><p>希望这些解答对你有所帮助！</p><h4 id="1-CSS-盒模型"><a href="#1-CSS-盒模型" class="headerlink" title="1. CSS 盒模型**"></a>1. CSS 盒模型**</h4><ul><li><p><strong>什么是盒模型？</strong></p><ul><li>CSS 盒模型是 CSS 用于布局和渲染 HTML 元素的一种模型。</li><li>每个 HTML 元素都被视为一个矩形的盒子，由内容（content）、内边距（padding）、边框（border）和外边距（margin）组成。</li></ul></li><li><p><strong>盒模型的两种类型：</strong></p><ul><li><strong>标准盒模型（content-box）</strong>：<ul><li>元素的宽度和高度只包含内容区域（content），不包括内边距、边框和外边距。</li><li><code>box-sizing: content-box;</code> （默认值）</li></ul></li><li><strong>IE 盒模型（border-box）</strong>：<ul><li>元素的宽度和高度包含内容区域、内边距和边框，不包括外边距。</li><li><code>box-sizing: border-box;</code></li></ul></li></ul></li><li><p><strong>盒模型的组成部分：</strong></p><ul><li><strong>Content（内容）</strong>：元素的实际内容，如文本、图片等。</li><li><strong>Padding（内边距）</strong>：内容区域与边框之间的空白区域，用于控制内容与边框的距离。</li><li><strong>Border（边框）</strong>：围绕内边距和内容的边框。</li><li><strong>Margin（外边距）</strong>：边框之外的空白区域，用于控制元素与其他元素之间的距离。</li></ul></li></ul><p><strong>2. CSS 优先级</strong></p><p>CSS 优先级（也称为 CSS 特异性）是指当多个 CSS 规则应用于同一个元素时，浏览器用来确定哪个规则具有更高优先级的机制。</p><ul><li><p><strong>优先级计算规则：</strong></p><ul><li><strong>内联样式</strong>（<code>style</code> 属性） &gt; <strong>ID 选择器</strong>（<code>#id</code>） &gt; <strong>类选择器、属性选择器、伪类选择器</strong>（<code>.class</code>、<code>[attribute]</code>、<code>:hover</code>） &gt; <strong>元素选择器、伪元素选择器</strong>（<code>div</code>、<code>::before</code>） &gt; <strong>通配符选择器</strong>（<code>*</code>）、<strong>关系选择器</strong>（<code>+</code>、<code>&gt;</code>、<code>~</code>、<code> </code>）</li><li>相同类型的选择器，后定义的规则覆盖先定义的规则。</li><li><code>!important</code> 规则具有最高优先级，会覆盖其他所有规则（慎用）。</li></ul></li><li><p><strong>优先级计算方法：</strong></p><ul><li>通常使用一个四位数的权重值来表示优先级，格式为：<code>a, b, c, d</code><ul><li><code>a</code>：内联样式（有则为 1，无则为 0）</li><li><code>b</code>：ID 选择器的数量</li><li><code>c</code>：类选择器、属性选择器、伪类选择器的数量</li><li><code>d</code>：元素选择器、伪元素选择器的数量</li></ul></li><li>比较优先级时，从左到右逐位比较，数值越大优先级越高。</li></ul><p>例如：</p><ul><li><code>#id .class</code> 的优先级为：<code>0, 1, 1, 0</code></li><li><code>.class div</code> 的优先级为：<code>0, 0, 1, 1</code></li><li><code>div</code> 的优先级为：<code>0, 0, 0, 1</code></li></ul></li></ul><p><strong>3. CSS 行内和块级元素区别</strong></p><table><thead><tr><th>特性</th><th>行内元素（Inline Elements）</th><th>块级元素（Block-level Elements）</th></tr></thead><tbody><tr><td>默认宽度</td><td>内容的宽度</td><td>父元素的宽度（或 100%）</td></tr><tr><td>默认高度</td><td>内容的高度</td><td>内容的高度</td></tr><tr><td>宽度设置</td><td>无效（<code>width</code> 属性无效）</td><td>有效</td></tr><tr><td>高度设置</td><td>无效（<code>height</code> 属性无效）</td><td>有效</td></tr><tr><td>水平排列</td><td>从左到右水平排列，直到一行排不下才换行</td><td>独占一行，垂直排列</td></tr><tr><td>垂直排列</td><td>不支持垂直外边距（<code>margin-top</code>、<code>margin-bottom</code>）</td><td>支持所有外边距</td></tr><tr><td>内边距</td><td>支持所有内边距</td><td>支持所有内边距</td></tr><tr><td>边框</td><td>支持所有边框</td><td>支持所有边框</td></tr><tr><td>盒子模型</td><td>只有内容区域、内边距和边框</td><td>包含内容区域、内边距、边框和外边距</td></tr><tr><td>转换</td><td>可以通过 <code>display: block;</code> 转换为块级元素</td><td>可以通过 <code>display: inline;</code> 转换为行内元素，<code>display: inline-block</code>转换为行内块元素</td></tr></tbody></table><p><strong>4. 常见的行内元素和块级元素有哪些</strong></p><ul><li><p><strong>行内元素：</strong></p><ul><li><code>&lt;span&gt;</code></li><li><code>&lt;a&gt;</code></li><li><code>&lt;img&gt;</code></li><li><code>&lt;strong&gt;</code></li><li><code>&lt;em&gt;</code></li><li><code>&lt;i&gt;</code></li><li><code>&lt;b&gt;</code></li><li><code>&lt;input&gt;</code> (部分类型)</li><li><code>&lt;textarea&gt;</code></li><li><code>&lt;select&gt;</code></li><li><code>&lt;label&gt;</code></li><li><code>&lt;button&gt;</code> (部分类型)</li></ul></li><li><p><strong>块级元素：</strong></p><ul><li><code>&lt;div&gt;</code></li><li><code>&lt;p&gt;</code></li><li><code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code></li><li><code>&lt;header&gt;</code></li><li><code>&lt;footer&gt;</code></li><li><code>&lt;nav&gt;</code></li><li><code>&lt;article&gt;</code></li><li><code>&lt;aside&gt;</code></li><li><code>&lt;section&gt;</code></li><li><code>&lt;ul&gt;</code></li><li><code>&lt;ol&gt;</code></li><li><code>&lt;li&gt;</code></li><li><code>&lt;form&gt;</code></li><li><code>&lt;hr&gt;</code></li><li><code>&lt;table&gt;</code></li><li><code>&lt;figure&gt;</code></li><li><code>&lt;video&gt;</code></li><li><code>&lt;canvas&gt;</code></li></ul></li></ul><p><strong>5. Position 几种</strong></p><ul><li>static: 默认值，没有定位。</li><li>relative: 相对定位，相对于自身原本位置进行偏移。</li><li>absolute: 绝对定位，相对于最近的已定位的祖先元素进行定位，如果没有，则相对于初始包含块(body)。</li><li>fixed: 固定定位，相对于浏览器窗口进行定位。</li><li>sticky: 粘性定位，它是 relative 和 fixed 的结合体。</li><li>inherit: 继承父元素的 position 属性的值。</li></ul><p><strong>6. DOM</strong></p><ul><li><p><strong>什么是 DOM？</strong></p><ul><li>DOM（Document Object Model，文档对象模型）是 HTML 和 XML 文档的编程接口。</li><li>它将文档表示为一个树形结构，每个节点代表文档的一部分（如元素、属性、文本等）。</li><li>通过 DOM，JavaScript 可以访问和操作文档的内容、结构和样式。</li></ul></li><li><p><strong>DOM 的作用：</strong></p><ul><li><strong>动态修改页面内容：</strong> 可以添加、删除、修改 HTML 元素和属性。</li><li><strong>响应用户事件：</strong> 可以监听用户的鼠标点击、键盘输入等事件，并执行相应的操作。</li><li><strong>实现交互效果：</strong> 可以实现动画、表单验证、数据交互等功能。</li></ul></li></ul><p><strong>7. 虚拟 DOM</strong></p><ul><li><p><strong>什么是虚拟 DOM？</strong></p><ul><li>虚拟 DOM（Virtual DOM）是真实 DOM 的 JavaScript 对象表示。</li><li>它是一个轻量级的、与平台无关的 DOM 抽象，用于优化 DOM 操作的性能。</li></ul></li><li><p><strong>虚拟 DOM 的作用：</strong></p><ul><li><strong>减少 DOM 操作次数：</strong> 在虚拟 DOM 中进行修改，然后一次性更新到真实 DOM 中，减少不必要的 DOM 操作。</li><li><strong>提高渲染性能：</strong> 通过 Diff 算法比较新旧虚拟 DOM 树的差异，只更新发生变化的部分，避免不必要的重绘和重排。</li><li><strong>跨平台：</strong> 虚拟 DOM 可以用于不同的渲染环境，如浏览器、服务器端渲染（SSR）、原生应用（如 React Native）。</li></ul></li></ul><p><strong>8. Vue2 和 Vue3 区别</strong></p><table><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td>响应式系统</td><td>Object.defineProperty()</td><td>Proxy</td></tr><tr><td>API 风格</td><td>Options API（选项式 API）</td><td>Composition API（组合式 API）</td></tr><tr><td>性能</td><td>较好</td><td>更好（更小的包体积、更快的渲染速度）</td></tr><tr><td>TypeScript 支持</td><td>较差</td><td>更好</td></tr><tr><td>代码组织</td><td>基于选项（data、methods、computed、watch 等）</td><td>基于函数，将相关的逻辑放在一起</td></tr><tr><td>逻辑复用</td><td>Mixins</td><td>Composition API（更好的逻辑复用和可读性）</td></tr><tr><td>模板编译</td><td>运行时编译</td><td>编译时优化（静态分析、模板优化）</td></tr><tr><td>Tree Shaking</td><td>不支持</td><td>支持（更好的 Tree Shaking，移除未使用的代码）</td></tr><tr><td>其他</td><td></td><td>Teleport（传送门）、Fragments（片段）、Suspense（异步组件加载）、更好的错误处理、自定义渲染器 API</td></tr><tr><td>全局API</td><td>Vue 2 中，我们会通过全局 Vue 对象来使用一些功能，比如通过<code>Vue.use()</code>来安装插件。</td><td>Vue 3 中，这些全局 API 发生了变化，它们现在需要通过应用的实例来调用。例如，使用<code>createApp</code>创建一个应用实例，然后在这个实例上调用<code>use</code>、<code>component</code>等方法</td></tr></tbody></table><p><strong>9. 路由两种模式区别</strong></p><ul><li><p><strong>Hash 模式：</strong></p><ul><li>使用 URL 的 hash（<code>#</code>）部分来模拟路由，例如：<code>http://example.com/#/home</code>。</li><li>hash 的变化不会导致页面重新加载，只会触发 <code>hashchange</code> 事件。</li><li>兼容性好，支持所有浏览器。</li><li>不需要服务器配置。</li></ul></li><li><p><strong>History 模式：</strong></p><ul><li>使用 HTML5 History API（<code>pushState</code>、<code>replaceState</code>）来管理路由，例如：<code>http://example.com/home</code>。</li><li>URL 更加美观，更符合传统的 URL 格式。</li><li>需要服务器配置，将所有路由请求都重定向到入口文件（如 <code>index.html</code>）。</li><li>兼容性较差，不支持 IE9 及以下浏览器。</li></ul></li></ul><p><strong>10. 项目里写到了 JS 升级为 TS，讲一下项目升级的步骤</strong></p><ol><li><p><strong>环境准备：</strong></p><ul><li>安装 TypeScript：<code>npm install -g typescript</code></li><li>安装相关的构建工具（如 Webpack、Rollup）的 TypeScript 插件。</li><li>配置 <code>tsconfig.json</code> 文件，指定 TypeScript 编译选项。</li></ul></li><li><p><strong>逐步迁移：</strong></p><ul><li><strong>从简单模块开始：</strong> 选择项目中相对独立、简单的模块开始迁移。</li><li><strong>将 <code>.js</code> 文件重命名为 <code>.ts</code> 文件。</strong></li><li><strong>添加类型注解：</strong> 为变量、函数参数、函数返回值等添加类型注解。</li><li><strong>处理类型错误：</strong> 解决 TypeScript 编译器报告的类型错误。</li><li><strong>逐步扩大范围：</strong> 逐步将更多的模块迁移到 TypeScript。</li></ul></li><li><p><strong>类型定义：</strong></p><ul><li><strong>为第三方库添加类型定义：</strong><ul><li>使用 DefinitelyTyped 提供的类型定义（<code>npm install @types/xxx</code>）。</li><li>如果 DefinitelyTyped 没有提供，可以自己编写类型定义文件（<code>.d.ts</code>）。</li></ul></li><li><strong>为项目中的自定义代码添加类型定义。</strong></li></ul></li><li><p><strong>构建和测试：</strong></p><ul><li>配置构建工具，使用 TypeScript 编译器编译 TypeScript 代码。</li><li>运行测试用例，确保代码功能正常。</li></ul></li><li><p><strong>持续集成：</strong></p><ul><li>将 TypeScript 编译和类型检查集成到持续集成流程中。</li></ul></li></ol><p><strong>11. Ts 和 Js 有哪些区别 优点</strong></p><table><thead><tr><th>特性</th><th>JavaScript</th><th>TypeScript</th></tr></thead><tbody><tr><td>类型系统</td><td>动态类型（运行时检查类型）</td><td>静态类型（编译时检查类型）</td></tr><tr><td>类型注解</td><td>无</td><td>支持</td></tr><tr><td>错误检查</td><td>运行时发现错误</td><td>编译时发现错误</td></tr><tr><td>代码可读性</td><td>较差</td><td>更好（类型注解可以提高代码的可读性和可维护性）</td></tr><tr><td>代码可维护性</td><td>较差</td><td>更好</td></tr><tr><td>重构</td><td>较难</td><td>更容易</td></tr><tr><td>IDE 支持</td><td>较弱</td><td>更好（IDE 可以提供更准确的代码补全、错误提示等）</td></tr><tr><td>学习曲线</td><td>较低</td><td>较高</td></tr><tr><td>适用场景</td><td>小型项目、快速原型开发</td><td>大型项目、长期维护的项目、需要更高代码质量的项目</td></tr><tr><td>优点</td><td>简单易学、灵活、生态系统庞大、跨平台</td><td>静态类型检查、更好的代码可读性和可维护性、更早发现错误、更好的 IDE 支持、更易于重构、更适合大型项目</td></tr><tr><td>缺点</td><td>动态类型容易出错、代码可读性和可维护性较差、重构困难</td><td>学习曲线较陡峭、需要编写类型注解、可能会增加开发时间（但长期来看可以减少调试时间）</td></tr><tr><td>TypeScript增加了代码的可读性和可维护性，减少了出错几率。</td><td></td><td></td></tr></tbody></table><p><strong>12. Js 里能不能实现枚举</strong></p><p>JavaScript 本身没有内置的枚举类型，但可以通过以下几种方式模拟实现枚举：</p><ol><li><p><strong>对象字面量：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Color</span> = &#123;<br>  <span class="hljs-attr">RED</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">GREEN</span>: <span class="hljs-string">&#x27;green&#x27;</span>,<br>  <span class="hljs-attr">BLUE</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">RED</span>); <span class="hljs-comment">// 输出 &quot;red&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>Object.freeze()</code> 冻结对象：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(&#123;<br>  <span class="hljs-attr">RED</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">GREEN</span>: <span class="hljs-string">&#x27;green&#x27;</span>,<br>  <span class="hljs-attr">BLUE</span>: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">RED</span>); <span class="hljs-comment">// 输出 &quot;red&quot;</span><br><span class="hljs-title class_">Color</span>.<span class="hljs-property">YELLOW</span> = <span class="hljs-string">&quot;yellow&quot;</span>; <span class="hljs-comment">// 无法添加新属性</span><br><span class="hljs-keyword">delete</span> <span class="hljs-title class_">Color</span>.<span class="hljs-property">RED</span>        <span class="hljs-comment">//无法删除属性</span><br></code></pre></td></tr></table></figure></li><li><p><strong>类模拟</strong></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Weekday</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Monday</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-string">&quot;Monday&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Tuesday</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-string">&quot;Tuesday&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Wednesday</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-string">&quot;Wednesday&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Thursday</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-string">&quot;Thursday&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Friday</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-string">&quot;Friday&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Saturday</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-string">&quot;Saturday&quot;</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-title class_">Sunday</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-string">&quot;Sunday&quot;</span>);<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用第三方库：</strong></p><ul><li><code>enumify</code></li><li><code>enum</code></li></ul></li></ol><p><strong>13. 跨域问题</strong></p><p>（已在之前的回答中详细解释过，请参考前面的回答）</p><p><strong>14. 算法：找出数组中第 K 大的数 堆排序&#x2F;快排</strong></p><p><strong>方法一：快速选择（基于快速排序）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">nums, k</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSelect</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, nums.<span class="hljs-property">length</span> - k); <span class="hljs-comment">// 注意这里的索引转换</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSelect</span>(<span class="hljs-params">arr, left, right, indexToFind</span>) &#123;<br>    <span class="hljs-keyword">if</span> (left === right) &#123;<br>      <span class="hljs-keyword">return</span> arr[left];<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> pivotIndex = <span class="hljs-title function_">partition</span>(arr, left, right);<br><br>    <span class="hljs-keyword">if</span> (indexToFind === pivotIndex) &#123;<br>      <span class="hljs-keyword">return</span> arr[indexToFind];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (indexToFind &lt; pivotIndex) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSelect</span>(arr, left, pivotIndex - <span class="hljs-number">1</span>, indexToFind);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSelect</span>(arr, pivotIndex + <span class="hljs-number">1</span>, right, indexToFind);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">arr, left, right</span>) &#123;<br>    <span class="hljs-keyword">const</span> pivot = arr[right];<br>    <span class="hljs-keyword">let</span> i = left;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = left; j &lt; right; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>        [arr[i], arr[j]] = [arr[j], arr[i]];<br>        i++;<br>      &#125;<br>    &#125;<br><br>    [arr[i], arr[right]] = [arr[right], arr[i]];<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：平均情况下为 O(n)，最坏情况下为 O(n^2)。<br>空间复杂度：O(log n)（递归栈的平均深度），最坏情况下为 O(n)。</p><p><strong>方法二：最小堆</strong><br>维护一个大小为k的最小堆</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findKthLargest</span>(<span class="hljs-params">nums, k</span>) &#123;<br>    <span class="hljs-keyword">const</span> minHeap = []; <span class="hljs-comment">// 使用数组模拟最小堆</span><br><br>    <span class="hljs-comment">// 辅助函数：交换数组中的两个元素</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">i, j</span>) &#123;<br>        [nums[i], nums[j]] = [nums[j], nums[i]];<br>    &#125;<br><br>    <span class="hljs-comment">// 辅助函数：将元素下沉到正确的位置</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">heapifyDown</span>(<span class="hljs-params">index, heapSize</span>) &#123;<br>        <span class="hljs-keyword">let</span> smallest = index;<br>        <span class="hljs-keyword">const</span> left = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &lt; nums[smallest]) &#123;<br>            smallest = left;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &lt; nums[smallest]) &#123;<br>            smallest = right;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (smallest !== index) &#123;<br>            <span class="hljs-title function_">swap</span>(index, smallest);<br>            <span class="hljs-title function_">heapifyDown</span>(smallest, heapSize);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 构建初始的最小堆（大小为k）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        minHeap.<span class="hljs-title function_">push</span>(nums[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 对前k个元素进行堆化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-title function_">heapifyDown</span>(i, k);<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历剩余的元素，如果大于堆顶元素，则替换堆顶元素并重新堆化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = k; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[<span class="hljs-number">0</span>]) &#123;<br>          nums[<span class="hljs-number">0</span>] = nums[i];<br>          <span class="hljs-title function_">heapifyDown</span>(<span class="hljs-number">0</span>,k)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 堆顶元素即为第k大的数</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：O(n log k)，其中 n 是数组的长度，k 是堆的大小。<br>空间复杂度：O(k)，用于存储堆的额外空间。</p><p>希望这些解答对你有所帮助！</p><h4 id="3-内部表单组件和-Formily-之间的差异"><a href="#3-内部表单组件和-Formily-之间的差异" class="headerlink" title="3. 内部表单组件和 Formily 之间的差异"></a>3. 内部表单组件和 Formily 之间的差异</h4><p>我们把“内部表单组件”理解为在公司或项目内部自行开发的、用于特定业务场景的表单组件。它们和 Formily 这样的专业表单解决方案的主要差异体现在以下几个方面：</p><p><strong>1. 定位与目标：</strong></p><ul><li><p><strong>内部表单组件：</strong></p><ul><li>通常针对特定业务需求定制，解决特定场景下的表单问题。</li><li>可能更注重与内部系统（如权限、数据字典）的集成。</li><li>可能更贴合内部 UI 规范和交互习惯。</li></ul></li><li><p><strong>Formily：</strong></p><ul><li>通用、专业的表单解决方案，旨在解决各种复杂表单场景。</li><li>注重表单的性能、可扩展性、可维护性，以及与各种 UI 库（如 Ant Design、Element UI）的集成。</li><li>提供更全面的表单功能，如字段联动、校验、异步数据加载、自定义渲染等。</li></ul></li></ul><p><strong>2. 功能与灵活性：</strong></p><ul><li><p><strong>内部表单组件：</strong></p><ul><li>功能可能相对简单，主要满足基本表单需求。</li><li>灵活性可能较低，难以应对需求变化。</li></ul></li><li><p><strong>Formily：</strong></p><ul><li>功能强大，提供丰富的 API 和配置选项，可以灵活应对各种复杂表单场景。</li><li>高度可定制，可以通过 Schema、自定义组件、自定义校验等方式扩展功能。</li></ul></li></ul><p><strong>3. 开发与维护成本：</strong></p><ul><li><p><strong>内部表单组件：</strong></p><ul><li>前期开发成本较低，但长期维护成本可能较高。</li><li>可能依赖于特定开发者，存在人员变动风险。</li></ul></li><li><p><strong>Formily：</strong></p><ul><li>学习成本相对较高，但长期维护成本较低。</li><li>有活跃的社区支持，文档齐全，更容易找到解决方案。</li></ul></li></ul><p><strong>4. 生态系统与社区支持：</strong></p><ul><li><strong>内部表单组件:</strong></li></ul><pre><code class="hljs">*    通常没有生态系统与社区支持。*    问题需要靠内部人员解决。</code></pre><ul><li><strong>Formily：</strong><ul><li>拥有庞大的生态系统和活跃的社区。</li><li>有大量的插件、工具和示例可供参考。</li><li>遇到问题可以更容易地找到解决方案。</li></ul></li></ul><p><strong>总结：</strong></p><table><thead><tr><th>特性</th><th>内部表单组件</th><th>Formily</th></tr></thead><tbody><tr><td>定位</td><td>针对特定业务需求定制</td><td>通用、专业的表单解决方案</td></tr><tr><td>目标</td><td>解决特定场景下的表单问题</td><td>解决各种复杂表单场景</td></tr><tr><td>功能</td><td>相对简单，满足基本需求</td><td>强大，提供丰富的 API 和配置选项</td></tr><tr><td>灵活性</td><td>较低</td><td>高度可定制</td></tr><tr><td>开发成本</td><td>前期较低，长期可能较高</td><td>学习成本较高，长期维护成本较低</td></tr><tr><td>维护成本</td><td>可能较高</td><td>较低</td></tr><tr><td>生态&#x2F;社区</td><td>无</td><td>活跃</td></tr></tbody></table><p>选择使用内部表单组件还是 Formily，取决于具体的项目需求、团队规模、技术栈以及长期维护成本的考虑。如果只需要解决简单的表单问题，并且有足够的人力进行维护，那么内部表单组件可能是一个更轻量级的选择。如果需要构建复杂、可扩展的表单，并且希望降低长期维护成本，那么 Formily 这样的专业表单解决方案可能更合适。</p><h4 id="Merge-Two-Sorted-Lists-算法题"><a href="#Merge-Two-Sorted-Lists-算法题" class="headerlink" title="Merge Two Sorted Lists 算法题**"></a>Merge Two Sorted Lists 算法题**</h4><p>这道题是 LeetCode 上的经典题目，题目编号 21. 合并两个有序链表。</p><p><strong>题目描述：</strong></p><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>JavaScript 解法（迭代）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>  <span class="hljs-comment">// 创建一个哑节点作为新链表的头部</span><br>  <span class="hljs-keyword">const</span> dummyHead = &#123; <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> &#125;;<br>  <span class="hljs-keyword">let</span> tail = dummyHead;<br><br>  <span class="hljs-comment">// 遍历两个链表，直到其中一个链表为空</span><br>  <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>    <span class="hljs-keyword">if</span> (l1.<span class="hljs-property">val</span> &lt;= l2.<span class="hljs-property">val</span>) &#123;<br>      tail.<span class="hljs-property">next</span> = l1;<br>      l1 = l1.<span class="hljs-property">next</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      tail.<span class="hljs-property">next</span> = l2;<br>      l2 = l2.<span class="hljs-property">next</span>;<br>    &#125;<br>    tail = tail.<span class="hljs-property">next</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 将剩余的链表连接到新链表的末尾</span><br>  tail.<span class="hljs-property">next</span> = l1 || l2;<br><br>  <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span>; <span class="hljs-comment">// 返回新链表的头部</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码解释：</strong></p><ol><li><strong>创建哑节点：</strong> <code>dummyHead</code> 是一个虚拟的头节点，它的作用是简化代码逻辑，避免对空链表的特殊处理。</li><li><strong>迭代比较：</strong> 使用 <code>while</code> 循环遍历两个链表，比较当前节点的值，将较小的节点添加到新链表的末尾。</li><li><strong>连接剩余部分：</strong> 当其中一个链表遍历完后，将另一个链表的剩余部分直接连接到新链表的末尾。</li><li><strong>返回结果：</strong> 返回 <code>dummyHead.next</code>，即新链表的头节点。</li></ol><p><strong>JavaScript 解法（递归）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!l1) &#123;<br>    <span class="hljs-keyword">return</span> l2;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!l2) &#123;<br>    <span class="hljs-keyword">return</span> l1;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (l1.<span class="hljs-property">val</span> &lt;= l2.<span class="hljs-property">val</span>) &#123;<br>    l1.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(l1.<span class="hljs-property">next</span>, l2);<br>    <span class="hljs-keyword">return</span> l1;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    l2.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(l1, l2.<span class="hljs-property">next</span>);<br>    <span class="hljs-keyword">return</span> l2;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码解释：</strong><br>如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。</p><h4 id="2-手撕-Promise-all"><a href="#2-手撕-Promise-all" class="headerlink" title="2. 手撕 Promise.all**"></a>2. 手撕 Promise.all**</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Argument must be an array&#x27;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> results = [];<br>    <span class="hljs-keyword">let</span> completedCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> promiseCount = promises.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">if</span> (promiseCount === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(results);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promiseCount; i++) &#123;<br>      <span class="hljs-comment">// 使用 Promise.resolve() 确保每个元素都是 Promise 对象</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>          results[i] = value;<br>          completedCount++;<br><br>          <span class="hljs-keyword">if</span> (completedCount === promiseCount) &#123;<br>            <span class="hljs-title function_">resolve</span>(results);<br>          &#125;<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          <span class="hljs-title function_">reject</span>(reason);<br>        &#125;<br>      );<br>    &#125;<br>  &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>代码解释：</strong></p><ol><li><strong>参数检查：</strong> 检查传入的参数是否为数组。</li><li><strong>空数组处理：</strong> 如果传入的是空数组，直接 <code>resolve</code> 一个空数组。</li><li><strong>结果数组和计数器：</strong><ul><li><code>results</code>：用于存储每个 Promise 的结果。</li><li><code>completedCount</code>：用于记录已完成的 Promise 数量。</li></ul></li><li><strong>遍历 Promise 数组：</strong><ul><li>使用 <code>Promise.resolve()</code> 将每个元素转换为 Promise 对象，以处理非 Promise 值。</li><li>使用 <code>.then()</code> 监听每个 Promise 的状态变化。</li><li>如果 Promise 成功，将结果存储到 <code>results</code> 数组中，并增加 <code>completedCount</code>。</li><li>如果 Promise 失败，直接 <code>reject</code> 整个 <code>Promise.all</code>。</li><li>当 <code>completedCount</code> 等于 Promise 数组的长度时，说明所有 Promise 都已完成，<code>resolve</code> 结果数组。</li></ul></li></ol><p><strong>3. JavaScript 的闭包能说一下吗</strong></p><p><strong>什么是闭包？</strong></p><p>闭包是指有权访问另一个函数作用域中变量的函数。更简单地说，闭包是一个能够记住并访问其所在词法环境（创建时的环境）的函数，即使该函数在其原始词法环境之外执行。</p><p><strong>闭包的形成：</strong></p><p>闭包的形成通常涉及两个关键要素：</p><ol><li><strong>嵌套函数：</strong> 一个函数内部定义了另一个函数。</li><li><strong>内部函数引用外部函数变量：</strong> 内部函数引用了外部函数的变量（或参数）。</li></ol><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> outerVar = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// innerFunction 访问了 outerFunction 的变量 outerVar</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> innerFunction;<br>&#125;<br><br><span class="hljs-keyword">const</span> myClosure = <span class="hljs-title function_">outerFunction</span>();<br><span class="hljs-title function_">myClosure</span>(); <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>outerFunction</code> 内部定义了 <code>innerFunction</code>。</li><li><code>innerFunction</code> 访问了 <code>outerFunction</code> 的变量 <code>outerVar</code>。</li><li><code>outerFunction</code> 返回了 <code>innerFunction</code>。</li><li>即使 <code>outerFunction</code> 执行完毕，<code>myClosure</code>（即 <code>innerFunction</code>）仍然可以访问 <code>outerVar</code>。</li></ul><p><strong>闭包的用途：</strong></p><ul><li><strong>实现私有变量和方法：</strong> 可以将变量和方法隐藏在函数内部，只暴露必要的接口。</li><li><strong>状态保持：</strong> 可以让函数记住之前的状态，例如在事件处理函数中。</li><li><strong>柯里化（Currying）：</strong> 将一个接受多个参数的函数转换为一系列接受单个参数的函数。</li><li><strong>模块化：</strong> 可以将代码组织成独立的模块，避免全局命名空间污染。</li><li><strong>实现高阶函数:</strong> 例如JavaScript中的回调函数。</li></ul><p><strong>闭包的缺点：</strong></p><ul><li><strong>内存泄漏：</strong> 如果闭包引用的变量一直不被释放，可能会导致内存泄漏。</li><li><strong>性能问题：</strong> 过多的闭包可能会影响性能，因为闭包会增加作用域链的长度。</li></ul><p><strong>4. JS 的定时器有哪些，setTimeout，setInterval 有什么区别</strong></p><p><strong>JavaScript 的定时器：</strong></p><p>JavaScript 提供了两种定时器：</p><ol><li><p><strong><code>setTimeout(callback, delay, ...args)</code>：</strong></p><ul><li>在指定的延迟时间（<code>delay</code>，单位为毫秒）后执行一次回调函数（<code>callback</code>）。</li><li><code>...args</code> 是可选参数，会作为参数传递给回调函数。</li><li>返回一个唯一的定时器 ID，可以用于 <code>clearTimeout()</code> 取消定时器。</li></ul></li><li><p><strong><code>setInterval(callback, delay, ...args)</code>：</strong></p><ul><li>每隔指定的延迟时间（<code>delay</code>，单位为毫秒）重复执行一次回调函数（<code>callback</code>）。</li><li><code>...args</code> 是可选参数，会作为参数传递给回调函数。</li><li>返回一个唯一的定时器 ID，可以用于 <code>clearInterval()</code> 取消定时器。</li></ul></li></ol><p><strong><code>setTimeout</code> 和 <code>setInterval</code> 的区别：</strong></p><table><thead><tr><th>特性</th><th><code>setTimeout</code></th><th><code>setInterval</code></th></tr></thead><tbody><tr><td>执行次数</td><td>单次</td><td>多次（重复）</td></tr><tr><td>执行方式</td><td>延迟指定时间后执行一次</td><td>每隔指定时间重复执行</td></tr><tr><td>取消定时器</td><td><code>clearTimeout()</code></td><td><code>clearInterval()</code></td></tr><tr><td>适用场景</td><td>只需要执行一次的任务，如延迟加载、动画效果</td><td>需要重复执行的任务，如轮播图、实时数据更新</td></tr><tr><td>注意事项</td><td>如果回调函数执行时间超过延迟时间，不会累积执行</td><td>如果回调函数执行时间超过间隔时间，可能会导致累积执行</td></tr></tbody></table><ul><li><strong>关于setInterval累计执行的问题</strong><br>如果回调函数执行时间过长，超过了间隔时间，<code>setInterval</code> 可能会出现“堆积”现象，即回调函数会连续执行多次，而没有间隔。为了避免这种情况，可以使用 <code>setTimeout</code> 模拟 <code>setInterval</code>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetInterval</span>(<span class="hljs-params">callback, delay</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">interval</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">callback</span>();<br>    <span class="hljs-built_in">setTimeout</span>(interval, delay);<br>  &#125;<br>  <span class="hljs-built_in">setTimeout</span>(interval, delay);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-内部表单组件如何实现联动关系？"><a href="#4-内部表单组件如何实现联动关系？" class="headerlink" title="4. 内部表单组件如何实现联动关系？"></a>4. 内部表单组件如何实现联动关系？</h4><p>内部表单组件实现联动关系，通常有以下几种方式：</p><p><strong>1. 基于事件监听和状态管理：</strong></p><ul><li><p><strong>原理：</strong></p><ul><li>监听触发联动字段的 <code>change</code> 事件（或其他相关事件，如 <code>input</code>、<code>blur</code>）。</li><li>在事件处理函数中，根据触发字段的值，更新其他相关字段的状态（如 <code>value</code>、<code>disabled</code>、<code>visible</code>）。</li><li>使用组件内部的状态管理（如 Vue 的 <code>data</code>、React 的 <code>state</code>）来存储和更新字段状态。</li></ul></li><li><p><strong>示例（Vue）：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;select v-model=&quot;country&quot; @change=&quot;onCountryChange&quot;&gt;<br>      &lt;option value=&quot;China&quot;&gt;China&lt;/option&gt;<br>      &lt;option value=&quot;USA&quot;&gt;USA&lt;/option&gt;<br>    &lt;/select&gt;<br><br>    &lt;input v-if=&quot;country === &#x27;China&#x27;&quot; v-model=&quot;province&quot; placeholder=&quot;Province&quot;&gt;<br>    &lt;input v-if=&quot;country === &#x27;USA&#x27;&quot; v-model=&quot;state&quot; placeholder=&quot;State&quot;&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      country: &#x27;&#x27;,<br>      province: &#x27;&#x27;,<br>      state: &#x27;&#x27;,<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    onCountryChange() &#123;<br>      // 清空联动字段的值<br>      this.province = &#x27;&#x27;;<br>      this.state = &#x27;&#x27;;<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>2. 基于计算属性（Computed Properties）：</strong></p><ul><li><p><strong>原理：</strong></p><ul><li>将联动字段的状态（如 <code>disabled</code>、<code>visible</code>）定义为计算属性。</li><li>计算属性依赖于触发联动字段的值，当触发字段的值变化时，计算属性会自动重新计算，从而更新联动字段的状态。</li></ul></li><li><p><strong>示例（Vue）：</strong></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;select v-model=&quot;country&quot;&gt;<br>      &lt;option value=&quot;China&quot;&gt;China&lt;/option&gt;<br>      &lt;option value=&quot;USA&quot;&gt;USA&lt;/option&gt;<br>    &lt;/select&gt;<br><br>    &lt;input v-model=&quot;province&quot; :disabled=&quot;isProvinceDisabled&quot; placeholder=&quot;Province&quot;&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      country: &#x27;&#x27;,<br>      province: &#x27;&#x27;,<br>    &#125;;<br>  &#125;,<br>  computed: &#123;<br>    isProvinceDisabled() &#123;<br>      return this.country !== &#x27;China&#x27;;<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>3. 基于自定义指令（Custom Directives）：</strong></p><ul><li><p><strong>原理：</strong></p><ul><li>创建自定义指令，用于处理联动逻辑。</li><li>在指令的 <code>update</code> 钩子函数中，根据触发字段的值，更新联动字段的状态。</li></ul></li><li><p><strong>示例（Vue）：</strong><br>   这种方法较为复杂，需要对vue的底层实现有了解，不推荐。</p></li></ul><p><strong>4. 基于表单状态管理库（如 Vuex、Redux）：</strong></p><ul><li><p><strong>原理：</strong></p><ul><li>将表单状态存储在全局状态管理库中。</li><li>在触发联动字段的组件中，通过 <code>dispatch</code> 或 <code>commit</code> 修改状态。</li><li>在联动字段的组件中，通过 <code>mapState</code> 或 <code>useSelector</code> 获取状态，并根据状态更新组件。</li></ul></li><li><p>这种方法适用于大型复杂表单，小型表单不推荐。</p></li></ul><p><strong>5. 基于Schema描述配置</strong></p><ul><li><strong>原理：</strong><ul><li>通过一份JSON配置来描述表单的结构，字段，校验规则与联动关系。</li><li>运行时根据Schema配置渲染表单，并处理联动，</li><li>Formily就是基于这种方式实现。</li></ul></li></ul><p>选择哪种方式取决于表单的复杂程度、团队的技术栈以及项目的具体需求。对于简单的联动关系，基于事件监听和状态管理或计算属性就足够了。对于复杂的联动关系，可以考虑使用自定义指令或表单状态管理库。</p><h4 id="场景题代码手撕"><a href="#场景题代码手撕" class="headerlink" title="场景题代码手撕**"></a>场景题代码手撕**</h4><p><strong>1. CSS 水平垂直居中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 方法一：Flexbox */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-comment">/* 方法二：Grid */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  place-items: center;<br>&#125;<br><br><span class="hljs-comment">/* 方法三：绝对定位 + transform */</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. Promise 看输出</strong><br>这个需要具体代码才能确定输出结果。</p><p><strong>3. 递归 + 定时器</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursiveTimer</span>(<span class="hljs-params">count, delay</span>) &#123;<br>  <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">recursiveTimer</span>(count - <span class="hljs-number">1</span>, delay);<br>  &#125;, delay);<br>&#125;<br><br><span class="hljs-title function_">recursiveTimer</span>(<span class="hljs-number">5</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 每隔1秒输出 5, 4, 3, 2, 1</span><br></code></pre></td></tr></table></figure><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><ol><li>既然给你面试机会，那么简历上的东西肯定是有吸引面试官的地方；面试的过程中一定不要吹技术，要是问到不会的就要扣分了；</li><li>展现自信，不要太紧张和拘束；</li><li>针对JD去写简历，去准备面试</li></ol><p>以下是前端开发面试中 <strong>JavaScript 核心知识点</strong>和 <strong>网络协议基础</strong>的常见考题及参考答案整理，结合最新技术趋势和面试动态：</p><h2 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h2><h3 id="vue3核心语法"><a href="#vue3核心语法" class="headerlink" title="vue3核心语法"></a>vue3核心语法</h3><ul><li>hook<ul><li><p>简单来讲就是自定义的包&#x2F;库（python等各种语言中都有）；是Vue 3中的重要特性，通过组合式API实现了对状态和副作用的管理，使得逻辑复用变得更加简单和高效。与传统的mixins相比，Hooks提供了更好的灵活性和可维护性，是现代Vue开发中不可或缺的一部分。主要用于封装可重用的逻辑和管理组件的状态、生命周期以及副作用。允许开发者以函数的形式组织和复用代码，从而提高代码的可维护性和可读性。</p></li><li><p>Vue Hook的作用</p><ul><li><p><strong>状态逻辑复用</strong>：Vue Hook允许在多个组件之间共享状态逻辑，避免重复代码。例如，可以创建一个自定义Hook来处理表单输入状态，然后在多个表单组件中使用。</p></li><li><p><strong>生命周期管理</strong>：Hooks提供了一系列生命周期钩子函数，如<code>onMounted</code>、<code>onUpdated</code>、<code>onUnmounted</code>等，帮助开发者在组件不同阶段执行特定操作。例如，可以在组件挂载后发起数据请求，或在组件卸载前清理定时器。</p></li><li><p><strong>简化代码结构</strong>：通过将逻辑封装到Hooks中，可以使组件代码更简洁，逻辑更集中，便于理解和维护。这种方式比传统的mixins更清晰，因为Hooks是以函数形式存在，避免了命名冲突和逻辑散落的问题。</p></li><li><p><strong>响应式数据处理</strong>：使用Hooks时，可以利用Vue 3中的响应式API（如<code>ref</code>、<code>reactive</code>、<code>computed</code>）来创建响应式数据，使得状态管理更加直观和高效。</p></li></ul></li><li><p>自定义Hooks：是开发者根据需要创建的函数，通常以<code>use</code>开头，例如<code>useFetchData</code>。这些函数可以调用其他Hooks，并返回响应式数据或方法，以供组件使用。自定义Hooks的基本规范包括：</p><ul><li><p>函数名以<code>use</code>开头。</p></li><li><p>在组件的<code>setup</code>函数中调用自定义Hook。</p></li><li><p>返回响应式变量或方法，以便在组件中解构使用。</p><p>例如，一个简单的自定义Hook可以用于处理本地存储：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) &#123;<br>   <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(initialValue);<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)) &#123;<br>      data.<span class="hljs-property">value</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key));<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(initialValue));<br>   &#125;<br><br>   <span class="hljs-title function_">watch</span>(data, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newValue));<br>   &#125;);<br><br>   <span class="hljs-keyword">return</span> &#123; data &#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   1. **数据持久化存储**:</span><br><span class="hljs-comment">   if (localStorage.getItem(key)) &#123;</span><br><span class="hljs-comment">      data.value = JSON.parse(localStorage.getItem(key));</span><br><span class="hljs-comment">   &#125; else &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(initialValue));</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   - 当首次使用时，如果 localStorage 中不存在数据，则存入初始值</span><br><span class="hljs-comment">   - 如果已存在数据，则读取已保存的数据</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   1. **响应式数据管理**:</span><br><span class="hljs-comment">   const data = ref(initialValue);</span><br><span class="hljs-comment">   - 使用 ref创建响应式数据，可以在组件中实时反映数据变化</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   1. **自动同步到 localStorage**:</span><br><span class="hljs-comment">   watch(data, (newValue) =&gt; &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(newValue));</span><br><span class="hljs-comment">   &#125;);</span><br><span class="hljs-comment">   - 通过 watch监听数据变化</span><br><span class="hljs-comment">   - 当数据发生变化时，自动更新到 localStorage 中</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   使用示例(在src/view/try.vue中):</span><br><span class="hljs-comment">   const &#123; data &#125; = useLocalStorage(&#x27;myData&#x27;, &#123; name: &#x27;default&#x27; &#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   这样就创建了一个在组件和 localStorage 之间自动同步的响应式数据。</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><p>在组件中使用时，可以这样引入并使用这个Hook：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> useLocalStorage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useLocalStorage&#x27;</span>;<br><br><span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">&#x27;myData&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;default&#x27;</span> &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>&lt;RouterView /&gt; </code><a id="RouterView"></a><ul><li><p><code>&lt;RouterView /&gt;</code> 是 Vue Router 的核心组件之一，它的主要作用是作为路由匹配到的组件的渲染出口。是实现前端路由的关键组件，它让我们能够根据 URL 的变化动态渲染不同的组件内容。</p></li><li><p>主要作用</p><ol><li><p><strong>组件渲染容器</strong></p><ul><li>它会根据当前的路由路径（URL）</li><li>自动渲染与该路径匹配的组件</li><li>相当于一个动态组件的占位符</li></ul></li><li><p><strong>动态更新</strong></p><ul><li>当路由发生变化时<code>&lt;RouterView /&gt;</code> 会自动更新渲染的内容,无需手动干预</li></ul></li></ol></li><li><p>使用场景:内容需要根据路由变化而变化</p><ul><li>看他的上一级路由的组件的相应变化位置就是它的出口；<ul><li>比如项目中整个&#x2F;下的第一级路由的出口就在src\App.vue（在&#x2F;xx下随着路由整个页面都变化）</li><li>菜单嵌套路由的出口在src\view\Main.vue（Layout组件）中的el-main中；在&#x2F;path&#x2F;xx下切换路由只相应修改页面布局中的el-main中的内容</li></ul></li></ul><ol><li><p><strong>布局组件中</strong></p><ul><li>作为内容区域的容器</li><li>常见于后台管理系统的布局中</li></ul></li><li><p><strong>嵌套路由</strong></p><ul><li>当需要实现多层级路由时,父路由组件相应位置放置 <code>&lt;RouterView /&gt;</code>，子路由的组件会在这里渲染</li></ul></li><li><p><strong>路由过渡动画</strong></p><ul><li>可以配合 <code>&lt;transition&gt;</code> 使用</li><li>为路由切换添加动画效果</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;transition name=<span class="hljs-string">&quot;fade&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li>在 Vue 2、3 中，<code>@</code> 是 <code>v-on</code> 指令的简写，用于监听 DOM 事件并执行相应的 JavaScript 代码。在 Vue 3 中，使用 <code>:</code> 符号来表示属性绑定是一个重要的语法特性。这种写法源于 Vue 的响应式特性，允许开发者将组件的属性（props）与数据模型进行绑定，从而实现动态更新。<ul><li><p>注意绑定的值必须满足如下规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//可行的情况</span><br> 变量：:value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//message必须是被定义过的变量</span><br> 表达式：:value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//count必须是被定义过的变量</span><br> 字符串字面量：:value=<span class="hljs-string">&quot;&#x27;hello&#x27;&quot;</span>（三个引号）<br> 对象：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span><br> 数组：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span><br> 布尔值：:disabled=<span class="hljs-string">&quot;false&quot;</span><br> <span class="hljs-comment">//不可行</span><br> :value=<span class="hljs-string">&#x27;hello&#x27;</span><br> :value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//但是message没有被定义</span><br> :value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//但是count没有被定义</span><br> <span class="hljs-comment">//举例说明:当我插入ep input组件时</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  :prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;显示不了，因为v-bing绑定了<span class="hljs-title class_">Search</span>但它没有被定义<br> <span class="hljs-comment">//其实我想要的search就是一个常量字符串，正确写法如下：去掉:或者使用三引号表示字符串常量</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;验证码&quot;</span>  <span class="hljs-attr">:prefix-icon</span>=<span class="hljs-string">&quot;&#x27;Search&#x27;&quot;</span> &gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure></li><li><p>属性绑定语法</p><ul><li><p>基本用法</p><ul><li><strong>属性绑定</strong>：使用 <code>:</code> 符号（相当于 <code>v-bind</code> 的简写）来将数据绑定到组件的属性上。例如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">:some-prop</span>=<span class="hljs-string">&quot;dataValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>   <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;width:&#x27;230px&#x27;&#125;&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>some-prop</code> 是子组件的一个 prop，而 <code>dataValue</code> 是父组件中的一个数据属性。</p><ul><li><p>动态绑定</p></li><li><p><strong>动态属性</strong>：可以使用表达式动态计算属性值。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;inputValue&quot;</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;isDisabled&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这里，<code>value</code> 和 <code>disabled</code> 属性会根据 <code>inputValue</code> 和 <code>isDisabled</code> 的值动态更新。</p><ul><li><p>使用对象语法</p></li><li><p><strong>对象语法</strong>：可以将多个属性一起绑定到组件上。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; propA: valueA, propB: valueB &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用这种方式，可以在一个对象中传递多个属性。</p></li></ul></li><li><p>事件处理语法</p><p>  <strong><strong>基本用法</strong></strong></p><ul><li><p><strong>监听事件</strong>：使用 <code>v-on</code> 指令（简写为 <code>@</code>）来监听事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 上述代码中的 <code>handleClick</code> 是一个在组件中定义的方法，当按钮被点击时，该方法将被调用。</p></li><li><p><strong>内联事件处理器</strong>：可以直接在模板中编写 JavaScript 代码，例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;alert(&#x27;Button clicked!&#x27;)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 在这个例子中，点击按钮会弹出一个警告框。</p></li></ul><p>  <strong><strong>事件参数</strong></strong></p><ul><li><p><strong>访问原生事件</strong>：在事件处理方法中，可以访问原生 DOM 事件对象。该对象会自动作为参数传递给方法。例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br><span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 输出触发事件的元素</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>**使用 <code>$event</code>**：在内联处理器中，可以通过特殊变量 <code>$event</code> 来访问原生事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick($event)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>  <strong><strong>修饰符</strong></strong></p><p>  Vue 提供了一些修饰符来控制事件的行为，例如：</p><ul><li><p>**<code>.stop</code>**：阻止事件冒泡。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>.prevent</code>**：阻止默认行为。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;submitForm&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>.self</code>**：仅当事件目标是元素本身时才触发处理器。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>Click me only if clicked on this div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>自定义事件</p></li></ul><p>  Vue 的组件之间可以通过自定义事件进行通信。子组件可以使用 <code>$emit</code> 方法向父组件发送事件。例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;custom-event&#x27;</span>, payload);<br></code></pre></td></tr></table></figure><p>  父组件则可以通过 <code>@custom-event</code> 来监听这个自定义事件：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">custom-event</span>=<span class="hljs-string">&quot;parentMethod&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>变量： Vue3 中变量的使用场景</p><ol><li>使用 <code>&#123;&#123; &#125;&#125;</code> 插值语法</li></ol><ul><li>在模板中显示变量值 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 显示数据 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count + 1 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; isActive ? &#x27;激活&#x27; : &#x27;未激活&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>使用单引号 <code>&#39;&#39;</code></li></ol><ul><li>字符串字面量</li><li>静态值</li><li>变量作各种参数，比如store.commit&#x2F;dispatch等等 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>使用 <code>:</code> 或 <code>v-bind</code></li></ol><ul><li>动态绑定属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 动态绑定 --&gt;<br>&lt;div :class=&quot;&#123;&#x27;click-enabled&#x27;: !flag&#125;&quot;&gt;//代表flag为false时，class为click-enabled，否则没有class<br>&lt;img :src=&quot;imgUrl&quot;&gt;<br>&lt;el-button :type=&quot;buttonType&quot;&gt;<br>&lt;div :style=&quot;&#123; width: width + &#x27;px&#x27; &#125;&quot;&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>使用 <code>@</code> 或 <code>v-on</code></li></ol><ul><li>事件绑定 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 事件绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;handleInput&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>使用 <code>v-model</code></li></ol><ul><li>双向数据绑定 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 双向绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li>使用 <code>v-if/v-show</code></li></ol><ul><li><p>条件渲染</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>总结：</p><ul><li><code>&#123;&#123; &#125;&#125;</code>: 显示变量值</li><li><code>&#39;&#39;</code>: 静态值</li><li><code>:</code>: 动态属性绑定</li><li><code>@</code>: 事件绑定</li><li><code>v-model</code>: 双向绑定</li><li><code>v-if/v-show</code>: 条件渲染</li></ul></li></ul></li></ul></li></ul><h4 id="nextTick-object-assign"><a href="#nextTick-object-assign" class="headerlink" title="nextTick&amp;object.assign "></a><a id="nextTick&object.assign">nextTick&amp;object.assign </a></h4><h4 id="nextTick-1"><a href="#nextTick-1" class="headerlink" title="nextTick"></a><code>nextTick</code></h4><p><code>nextTick</code> 是 <strong>Vue.js</strong> 提供的一个方法，用于在下一次 DOM 更新循环结束之后执行延迟回调。在修改数据后立即使用 <code>nextTick</code>，可以在回调中获取更新后的 DOM。</p><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    count.<span class="hljs-property">value</span>++;<br>    <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 在这里可以访问更新后的 DOM</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM 已更新&#x27;</span>);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123; count, increment &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>当你在修改响应式数据后，需要在 DOM 更新完成后执行某些操作时，使用 <code>nextTick</code>。</li><li>常见场景包括获取更新后的 DOM 元素的尺寸或状态。</li></ul><hr><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h4><p><code>Object.assign</code> 是 <strong>JavaScript</strong> 中的一个静态方法，用于将一个或多个源对象的可枚举属性复制到目标对象中。返回目标对象。也称为合并对象。</p><p><strong>语法：</strong></p><ol><li>如果target存在source中的属性就会被重写赋值，如果不存在就会创造这个属性然后赋值过去；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, ...sources);<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：目标对象。</li><li><code>sources</code>：源对象。</li></ul><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//或者&#123;a:1&#125;,输出结果一样</span><br><span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source1, source2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target); <span class="hljs-comment">// 输出：&#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>Object.assign</code> 常用于对象的合并或浅拷贝。</li><li>如果目标对象与源对象有相同的属性，后面的属性会覆盖前面的属性。</li></ul><h3 id="文件结构及其作用、执行顺序："><a href="#文件结构及其作用、执行顺序：" class="headerlink" title="文件结构及其作用、执行顺序："></a>文件结构及其作用、执行顺序：</h3><ol><li>根目录：<ol><li>package.json：这个文件包含了项目的依赖项、脚本等信息，是整个项目的元数据。</li><li>vue.config.js：这是用于配置 Vite 的主要文件。在这里，你可以定义环境变量、设置插件、调整打包选项等。这是一个非常重要的配置文件，它会影响到你的开发体验和生产部署过程</li></ol></li><li>public：包含了一些静态资源，比如图标、favicon.ico、robots.txt 等。这些文件会被直接复制到构建目录中，不会经过 Vite 的处理。<ol><li>在组件中导入public中的静态资源时不需要完整的路径，直接&#x2F;文件名即可比如<code>import qrImg from &#39;/qr.png&#39;</code>;导入public中的二维码图片</li></ol></li><li>src 文件夹：在 Vite 中最核心的一个文件夹，因为它存放着所有的源代码： index.htm-main.js-index.js、App.vue-其他view、components组件-静态资源（图片、cdn等等）<ol><li>assets 文件夹：用来存储静态资源，如图片、样式表等，这些资源通常不会经常变化，可以直接复制到服务器上</li><li>components 文件夹：存放的是你写好的复用组件，每个子文件夹代表一类相关的组件，比如说有一个 base 或者 app 组件，然后再根据具体功能划分出不同的模块（例如：button、table 等）。在vue项目中可以将其中的文件称为vue文件：封装和组织组件的模板、逻辑和样式，使得组件的开发和管理更加高效和模块化（往往在components下创造组件，在view下的vue文件中引用组件），提高了代码的可维护性和复用性：其基础结构如下：<ol><li><p><code>&lt;template&gt;&lt;/template&gt;</code>:内含html代码，用于组成页面结构</p><ol><li>浏览器中不会存在<code>&lt;template&gt;</code>标签的原因是，Vue会在编译过程中将<code>&lt;template&gt;</code>中的内容转换为JavaScript渲染函数。在这个过程中，Vue会解析<code>&lt;template&gt;</code>的内容并生成虚拟DOM，而这个虚拟DOM最终会被渲染到实际的DOM中。</li><li>编译过程：<ol><li>解析模板：Vue使用vue-template-compiler库将<code>&lt;template&gt;</code>块中的HTML字符串解析为抽象语法树（AST），这表示了模板的结构。</li><li>生成渲染函数：AST会被转换为JavaScript代码，这些代码负责创建虚拟DOM节点。每当组件需要渲染时，Vue会调用这些渲染函数，而不是直接使用<code>&lt;template&gt;</code>中的内容。</li><li>更新DOM：当数据变化时，Vue会根据虚拟DOM的变化来更新实际的DOM。</li></ol></li></ol></li><li><p>调用组件</p><ol><li>引入组件有两种方式<ol><li>直接在要使用的页面中导入</li><li>在main.js中导入，然后app.component（”组件名称”,组件）注入全局这样就可以在全局使用了</li></ol></li><li>在组件中调用的组件名称也有两种方式<br>在 Vue.js 中，当您在 <code>main.js</code> 中全局注册组件时，例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PanelHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/PanelHead.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;PanelHead&#x27;</span>, <span class="hljs-title class_">PanelHead</span>);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><p>尽管您注册的组件名称是 <code>&#39;PanelHead&#39;</code>，但在模板中可以使用 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code> 或<code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code>的形式来引用，</p><p><strong>原因如下：</strong></p><ol start="3"><li><p><strong>组件名的大小写不敏感解析：</strong></p><p>Vue 在解析模板时，会将自定义组件标签名中的连字符形式（kebab-case）和大驼峰形式（PascalCase）都识别为同一个组件。例如：</p><ul><li><code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code></li><li><code>&lt;panel-head&gt;&lt;/panel-head&gt;</code></li></ul><p>上述两种写法都会被解析为注册的 <code>&#39;PanelHead&#39;</code> 组件。</p></li><li><p><strong>组件名的规范化：</strong></p><p>根据 Vue 的组件名解析规则，注册时的组件名会被标准化处理，模板中的标签名也会被转换为相应的格式，以进行匹配。</p><ul><li>注册组件时使用 PascalCase（大驼峰命名）的名称。</li><li>在模板中，可以使用 PascalCase 或 kebab-case（短横线命名）形式的组件标签。</li></ul></li><li><p><strong>HTML 中的大小写不敏感性：</strong></p><ul><li>在浏览器解析 HTML 时，标签名是大小写不敏感的。</li><li>为了遵循 HTML 规范，Vue 推荐在模板中使用 kebab-case 的组件名。</li></ul></li></ol><p><strong>总结：</strong></p><ul><li><strong>注册组件：</strong> 使用 PascalCase 命名，例如 <code>&#39;PanelHead&#39;</code>。</li><li><strong>在模板中引用：</strong> 可以使用 <code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code> 或 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，Vue 都能够正确解析。</li><li><strong>推荐使用：</strong> 在模板中使用 kebab-case 形式，即 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，以符合 HTML 规范和提高可读性。</li></ul></li><li><p><a id="vue3核心"></a>组合式API与选项式API的对比（本项目中使用组合式API）</p><ol><li><p>组合式API：Vue3提供了丰富的组合式API，帮助开发者管理组件的行为，核心功能如下：</p><ol><li><code>&lt;script setup&gt;</code> 是在单文件组件中使用组合式 API 的编译时语法糖。主要特点：<ol><li><p>顶层变量&#x2F;函数自动暴露给模板：意思是说<code>&lt;script setup&gt;</code> 中定义的变量和函数会自动暴露给当前组件的模板使用;这种暴露仅限于当前组件内部的 template 部分;</p><ol><li>无需 return 和 export 语句</li><li>引入的组件自动注册<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>   &lt;script setup&gt;<br>   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br>   <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span><br><br>   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++<br>   &lt;/script&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   <span class="hljs-string">``</span><span class="hljs-string">`              </span><br><span class="hljs-string">2. 组件实例的访问:父组件通过 ref 访问子组件时，访问的是子组件的实例;出于安全考虑，Vue 3 默认关闭了组件实例的属性访问需要通过 defineExpose 明确声明哪些属性/方法可以被父组件访问;</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br>      &lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)          <span class="hljs-comment">// ✅ 自动暴露给当前模板使用</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">defineExpose</span>(&#123; count &#125;) <span class="hljs-comment">// ✅ 显式暴露给父组件访问</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;&#123; count &#125;&#125;  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 count --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 increment --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 父组件 <span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// 访问子组件实例的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childRef.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>)        <span class="hljs-comment">// ✅ 可以访问（因为被 defineExpose 暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   childRef.<span class="hljs-property">value</span>.<span class="hljs-property">increment</span>          <span class="hljs-comment">// ❌ 不能访问（未被暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>这种设计的目的是：</p><pre><code class="hljs">     提高代码的可维护性     增强组件的封装性     避免父组件随意访问和修改子组件的内部状态</code></pre></li></ol></li><li>响应式系统：数据变更自动触发视图更新 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// ref 基本类型响应式</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>count.<span class="hljs-property">value</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br><br><span class="hljs-comment">// reactive 对象响应式</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;)<br>state.<span class="hljs-property">age</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br></code></pre></td></tr></table></figure></li><li><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html">生命周期钩子</a>(选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子。组合式 API：需要手动导入所需的响应式函数和生命周期钩子，从而提供更灵活和模块化的代码结构，他们俩周期钩子也有差别；比如组合式没有beforecreate，把setup当created用，其它就当改了个名)</li></ol><p><img src="/2024/10/25/MJ/note_vue/1731056688357.png" alt="1731056688357"></p><p><img src="/2024/10/25/MJ/note_vue/image.png" alt="alt text"><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span></span><br><span class="language-xml">      增加 1</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">import</span> &#123; ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染之前调用的时beforeMount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染完成调用的时mounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之前调用的时beforeUpdate函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之后调用的时updated函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之前调用的时beforeUnmount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之后调用的时unmounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><br> 4. 响应式监听<br>    1. watch的两个参数<br>       1. watch 的第一个参数需要是一个响应式数据（可以是多个），或者是一个返回值的函数。（比如返回一个对象obj的属性() &#x3D;&gt; obj.age）<br>       2. 箭头函数(newValue,oldValue) &#x3D;&gt; {}<br>          1. oldValue：监听的值在变化之前的值<br>          2. newValue：监听的值在变化之后的值<br>    2. watch的触发条件<br>       1. 要让 watch 监听器生效，需要在运行时修改被监听的响应式数据。直接在代码中修改变量的初始值（即在组件加载前设置的值）并不会触发 watch 的回调函数。watch 的作用是监听响应式数据的变化，当数据在运行时发生改变时（例如用户点击按钮触发事件函数），watch 才会检测到这种变化并执行回调函数。<br>    3.  watch的两个属性：<br>       1. immediate（获取初始化）：当设置为 true 时，监听器会在绑定后立即触发回调函数。这意味着在初始化阶段，即使被监听的值没有发生变化，回调函数也会被调用一次。作用如下<br>          1. 在组件加载时，需要根据初始值执行一些操作，例如根据初始参数请求数据。而不必等待被监听的值发生变化。<br>          2. 在组件创建时，需要将某些响应式数据同步到其他地方<br>          3. 在初始化组件的时候oldValue是undefined，newValue是当前值(初始值)<br>       2. deep：true<br>          1.  Vue3 的 reactive 会自动对对象进行深层代理（Proxy），所以：当直接修改 监听对象的内置嵌套对象时，两个监听器都会触发<br>          2.  deep: true 主要用于以下场景：<br>              1.  当你使用 reactive 对象作为 watch 的源，且需要在对象被整个替换时触发监听<br>              2.  当监听的是一个返回非响应式对象的 getter 函数时<br>            <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> deep = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,<br>   <span class="hljs-attr">info</span>: &#123;<br>      <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>      <span class="hljs-attr">contacts</span>: &#123;<br>         <span class="hljs-attr">phone</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>         <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;test@example.com&#x27;</span><br>      &#125;<br>&#125;<br>&#125;)<br><span class="hljs-title function_">watch</span>(deep, <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj changed&#x27;</span>)<br>&#125;)<span class="hljs-comment">//vue3自带不需要deep</span><br><br><span class="hljs-comment">// 如果是这种情况，则需要 deep: true：当改变的是 deep.info时，returnNonReactiveObj会被整个替换</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">returnNonReactiveObj</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br><span class="hljs-attr">info</span>: deep.<span class="hljs-property">info</span><br>&#125;)<br><span class="hljs-title function_">watch</span>(returnNonReactiveObj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;non-reactive obj changed:&#x27;</span>, newValue)<br>&#125;, &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;)<br><br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br> <span class="hljs-keyword">import</span> &#123; ref, reactive, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br> <span class="hljs-keyword">const</span> counter1 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-keyword">const</span> counter2 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-comment">// 监听多个</span><br> <span class="hljs-title function_">watch</span>([counter1, counter2], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter1 value is: &#x27;</span> + counter1.<span class="hljs-property">value</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter2 value is: &#x27;</span> + counter2.<span class="hljs-property">value</span>)<br> &#125;)<br><br> <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br> &#125;)<br> <span class="hljs-comment">//监听初始化值</span><br> <span class="hljs-title function_">watch</span>(obj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br> <span class="hljs-comment">// watch监听单个属性</span><br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">name</span>, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br><br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>计算属性:更加灵活，可以在定义响应式变量时声明;<code>computed</code> 可以用于任何类型的数据处理，不仅限于数值计算。</p><ol><li>核心优势<ul><li>可处理任何数据类型</li><li>自动跟踪依赖关系</li><li>具有缓存机制</li><li>提高代码可读性和维护性</li></ul></li><li>以下是一些常见用例<ol><li><p><strong>字符串处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串转换</span><br><span class="hljs-keyword">const</span> upperCase = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> name.<span class="hljs-property">value</span>.<span class="hljs-title function_">toUpperCase</span>())<br><span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;firstName.value&#125;</span> <span class="hljs-subst">$&#123;lastName.value&#125;</span>`</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>数组处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数组过滤</span><br><span class="hljs-keyword">const</span> activeTodos = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>))<br><span class="hljs-comment">// 数组排序</span><br><span class="hljs-keyword">const</span> sortedList = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> items.<span class="hljs-property">value</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>))<br></code></pre></td></tr></table></figure></li><li><p><strong>对象处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象转换</span><br><span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;user.value.firstName&#125;</span> <span class="hljs-subst">$&#123;user.value.lastName&#125;</span>`</span>,<br>  <span class="hljs-attr">age</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span>,<br>  <span class="hljs-attr">isAdult</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span><br>&#125;))<br></code></pre></td></tr></table></figure></li><li><p><strong>复杂逻辑</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 购物车计算</span><br><span class="hljs-keyword">const</span> cartTotal = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> cart.<span class="hljs-property">value</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> total + (item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>字符倒序</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;this is a value&#x27;</span>)<br><br><span class="hljs-comment">// 注意这里</span><br><span class="hljs-keyword">const</span> reversedValue = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// 使用 ref 需要 .value</span><br><span class="hljs-keyword">return</span> value.<span class="hljs-property">value</span><br>   .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>条件渲染和列表渲染</p><ol><li><p>v-for的参数</p><ol><li>如下代码中的v-for&#x3D;”(item, index) in props.menuData” 中：这个 index 是 Vue 提供的数组索引值，是 v-for 指令内置提供的第二个参数表示当前遍历项在数组中的索引值(从0开始)是可选参数,如果不需要索引值，可以省略<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">!-- 假设 props.<span class="hljs-property">menuData</span> 是这样的数组 --&gt;<br>  [<br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单1&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 0</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单2&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 1</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单3&#x27;</span> &#125; &#125;   <span class="hljs-comment">// index = 2</span><br>  ]                       <br>   v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, index) in array&quot;</span><br>  <span class="hljs-comment">// item: 当前项</span><br>  <span class="hljs-comment">// index: 当前项的索引</span><br>                       <br></code></pre></td></tr></table></figure></li></ol></li><li><p>v-if 中 index 和 key</p><ol><li><p>index&#x3D;”<code>$&#123;index&#125;-$&#123;item.meta.id&#125;</code>“</p><ol><li>这是 Element Plus 菜单组件特有的属性</li><li>用于标识每个菜单项的唯一路径</li><li>帮助菜单组件追踪当前选中的菜单项</li><li>通常用于控制菜单的激活状态</li></ol></li><li><p><code>key</code> 属性:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">:key=&quot;`$&#123;index&#125;-$&#123;item.meta.id&#125;`&quot;<br></code></pre></td></tr></table></figure></li></ol><ul><li>这是 Vue 框架要求的特殊属性</li><li>用于给 v-for 循环中的每个元素一个唯一标识</li><li>帮助 Vue 在虚拟 DOM 更新时准确识别节点</li><li>提高渲染性能和准确性</li></ul><p>  它们的主要区别：</p><ul><li><code>index</code> 是功能性的唯一标识，用于菜单组件的功能实现</li><li><code>key</code> 是结构性的唯一标识，用于 Vue 框架的 DOM 更新优化</li></ul></li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 项目中的菜单组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in props.menuData&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 无子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.children || item.children.length == 0&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:indx</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 结合路由信息以及动态元素实现图标渲染 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 菜单标题 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 有子菜单：分两个部分：标题+递归调用子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-sub-menu</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-else</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 标题区域的内容： #title是 Element Plus 的 el-sub-menu 组件预定义的插槽名称 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 递归调用此组件实现子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- index：1  1-2  1-3 实现每个菜单项的唯一标识 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">SubMenu</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:menuData</span>=<span class="hljs-string">&quot;item.children&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-sub-menu</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="hljs-string">``</span><span class="hljs-string">`                   </span><br><span class="hljs-string"></span><br><span class="hljs-string"> `</span><span class="hljs-string">``</span>js<br>&lt;template&gt;<br>   &lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>显示内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>其他内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   &lt;!-- 列表渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="language-xml">         &#123;&#123; item.name &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目1&#x27;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目2&#x27;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   ])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>v-if和v-show的区别</p><ul><li><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue.js 中用于条件渲染的指令，但它们有不同的作用和使用场景。</p></li><li><p>总结：</p><ul><li>使用 <code>v-if</code> 时，元素在条件为假时不会存在于 DOM 中。</li><li>使用 <code>v-show</code> 时，元素始终存在于 DOM 中，只是通过 CSS 控制显示或隐藏。</li></ul></li><li><p><code>v-if</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来有条件地渲染元素。</li><li><strong>特点</strong>：元素及其绑定的事件和子组件在条件为假时不会被渲染或销毁。</li><li><strong>性能</strong>：初始渲染时有更高的开销，因为需要添加或删除 DOM 元素。</li></ul></li><li><p><code>v-show</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来切换元素的显示状态。</li><li><strong>特点</strong>：元素始终会被渲染并保留在 DOM 中，只是通过 CSS 的 <code>display</code> 属性来控制显示或隐藏。</li><li><strong>性能</strong>：初始渲染开销较小，但频繁切换显示状态时性能更好。</li></ul></li><li><p>使用场景</p><ul><li>**<code>v-if</code>**：适用于在运行时条件很少改变的场景，因为它会在条件变化时进行 DOM 的添加和删除。</li><li>**<code>v-show</code>**：适用于需要频繁切换显示状态的场景，因为它只会切换 <code>display</code> 属性。</li></ul></li><li><p>示例</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;!-- v-<span class="hljs-keyword">if</span> 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>  &lt;!-- v-show 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isShow</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isVisible</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>事件处理与双向绑定</p><ol><li><code>v-model</code> 的用途:获取表单中的输入数据赋值给变量；<code>v-model</code> 是 Vue.js 中用于创建<strong>双向数据绑定</strong>的指令，主要用于表单输入元素与应用状态之间的同步。主要功能如下<ol><li><p><strong>双向绑定</strong>：</p><ul><li>自动将用户输入的值同步到组件的状态（如 <code>data</code> 或 <code>ref</code>）。</li><li>同时，当状态发生变化时，更新输入元素的显示值。</li></ul></li><li><p><strong>简化代码</strong>：</p><ul><li>替代手动编写 <code>:value</code> 和 <code>@input</code> 事件处理器，实现更简洁的双向绑定。</li></ul></li></ol></li><li>常见用法</li></ol><ul><li><p><strong>文本输入</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>复选框</strong>：</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input type=&quot;checkbox&quot; v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>选择框</strong>：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">      &lt;select v-model=&quot;变量名&quot;&gt;<br>         &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt;<br>         &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt;<br>      &lt;/select&gt;<br><br> ```js<br>&lt;template&gt;<br>      &lt;input v-model=&quot;username&quot; /&gt;<br>   &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const username = ref(&#x27;&#x27;)<br>const handleClick = () =&gt; &#123;<br>console.log(username.value)<br>&#125;<br>&lt;/script&gt;<br>/*<br>   - **`v-model=&quot;username&quot;`**：<br>   - 将输入框的值与 `username` 变量绑定。<br>   - 用户在输入框中输入内容时，`username` 会自动更新。<br>   - 如果在代码中修改 `username` 的值，输入框的显示内容也会相应更新。<br><br>*/<br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>对比一下选项式API：在 Vue 2 和 Vue 3 的选项式 API 中的<code>&lt;script&gt;</code>中需要 return 和 export 的原因：(这些在组合式API中都不用考虑)</p><ol><li>export default 的目的：<ol><li>将组件配置对象导出，使其可以被其他组件引入使用</li><li>这是 ES6 模块系统的要求</li><li>Vue 通过这个导出的对象来创建组件实例</li></ol></li><li>return 的目的：<ol><li>在 data() 函数中返回数据对象，使其成为响应式数据</li><li>每个组件实例都需要独立的数据副本，避免数据共享<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-comment">// 选项式 API</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyComponent&#x27;</span>,<br><br><span class="hljs-comment">// data 必须是函数并返回对象，确保每个组件实例有独立的数据副本</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">methods</span>: &#123;<br>   <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">computed</span>: &#123;<br>   <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>   &#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br><span class="hljs-comment">// ❌ 错误示例</span><br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//组合式API中：组合式API基础语法</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 方式1：使用 ref() 定义基础类型</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><br><span class="hljs-comment">// 方式2：使用 reactive() 定义对象类型</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 使用时：(在template之外)</span><br><span class="hljs-comment">// ref 需要 .value </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>)<br><br><span class="hljs-comment">// reactive 直接使用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">message</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在模板中使用 ref 不需要 .value --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- reactive 对象的使用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>选项式与组合式API的区别（除了上述之外）： </p><ol><li><p>选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子等等。</p></li><li><p>组合式 API：需要手动导入所需的响应式函数和生命周期钩子等等，从而提供更灵活和模块化的代码结构。（除了编译器宏比如defineProps，编译器宏：由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 ‘vue’ 中导入。自动可用：在<code>&lt;script setup&gt;</code>块内，defineProps 会被自动识别并处理。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//拿子传父举例</span><br><span class="hljs-comment">// 选项式 API</span><br>&lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);<span class="hljs-comment">//自动处理this.$emit</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// 组合式 API</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>选项式 API 和 组合式 API 的主要区别补充：</p><ol><li><p><strong>组织代码的方式</strong></p><ul><li><strong>选项式 API</strong>：通过选项（如 <code>data</code>、<code>methods</code>、<code>computed</code> 等）组织代码，适合简单组件。</li><li><strong>组合式 API</strong>：通过组合函数（如 <code>setup</code>）组织代码，更适合复杂逻辑和代码复用。</li></ul></li><li><p><strong>逻辑复用</strong></p><ul><li><strong>选项式 API</strong>：依赖混入（mixins）和高阶组件（HOCs），可能导致命名冲突和难以追踪。</li><li><strong>组合式 API</strong>：使用组合函数（composables）实现逻辑复用，结构更清晰，避免命名冲突。</li></ul></li><li><p><strong>类型推导和 TypeScript 支持</strong></p><ul><li><strong>选项式 API</strong>：TypeScript 支持有限，类型推导较复杂。</li><li><strong>组合式 API</strong>：与 TypeScript 集成更好，提供更精准的类型推导。</li></ul></li><li><p><strong>代码组织与可维护性</strong></p><ul><li><strong>选项式 API</strong>：按选项分割，功能分散，难以管理大型组件。</li><li><strong>组合式 API</strong>：按功能分割，相关逻辑集中，提升可维护性。</li></ul></li><li><p><strong>生命周期钩子</strong></p><ul><li><strong>选项式 API</strong>：通过选项直接定义生命周期钩子（如 <code>mounted</code>、<code>created</code>）。</li><li><strong>组合式 API</strong>：在 <code>setup</code> 内使用函数（如 <code>onMounted</code>、<code>onCreated</code>）定义生命周期钩子。</li></ul></li><li><p><strong>响应式系统</strong></p><ul><li><strong>选项式 API</strong>：使用 <code>data</code> 对象进行响应式管理，自动处理响应式属性。</li><li><strong>组合式 API</strong>：使用 <code>ref</code>、<code>reactive</code> 等函数显式创建响应式数据，更灵活。</li></ul></li><li><p><strong>学习曲线</strong></p></li></ol><ul><li><strong>选项式 API</strong>：更直观，适合 Vue 新手。</li><li><strong>组合式 API</strong>：需要理解响应式原理和组合函数，学习曲线稍陡。</li></ul><ol start="8"><li><strong>调试和测试</strong></li></ol><ul><li><strong>选项式 API</strong>：由于逻辑分散，单独测试某一功能较困难。</li><li><strong>组合式 API</strong>：逻辑集中，单元测试和调试更容易。</li></ul></li><li><p>最后总结一下两者的异同：</p><ol><li>同：无论是选项式还是组合式API，都得遵循js的规范，比如任何变量使用前必须申明，否则会报错；调用其他组件时都需要导入相应文件；</li><li>异：<ol><li>选项式需要export default导出组件对象，并在其中使用components申明导入的组件、data（）函数return 返回数据变量&#x2F;对象（定义申明）以实现相应，而组合式直接ref&#x2F;reactive即可；</li><li>组合式中需要导入响应式函数和生命周期钩子等等，而选项式不需要；（除了编译器宏比如defineProps之外）</li></ol></li><li>在这个项目中我主要使用组合式，往后就不管选项式了</li></ol></li></ol></li></ol></li><li><p><code>&lt;style scoped&gt;&lt;/style&gt;</code>：用于定义组件的样式。开发者可以使用CSS或预处理器（如Sass、Less、Tailwind CSS，问perplexity）编写样式：</p><ol><li><code>&lt;style&gt;</code> 标签内编写的 CSS 样式默认是全局作用域，会影响到其他路由页面。要使样式仅作用于当前组件，需要在 <code>&lt;style&gt;</code> 标签上添加 scoped 属性：   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style lang=<span class="hljs-string">&quot;less&quot;</span> scoped&gt;<br> <span class="hljs-comment">/* 在这里添加样式 */</span><br> .<span class="hljs-property">logo</span>-lg &#123;<br> font-<span class="hljs-attr">size</span>: 20px;<br> text-<span class="hljs-attr">align</span>: center;<br> <span class="hljs-attr">height</span>: 50px;<br> line-<span class="hljs-attr">height</span>: 50px;<br> <span class="hljs-attr">color</span>: style<br> &#125;<br> &lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>根组件App.vue:包含了整个应用程序的布局结构<ol><li>页面渲染的入口点。所有其他组件都会嵌套在App.vue中</li><li>通常会与Vue Router的组件<code>&lt;RouterView /&gt;</code>结合使用，处理页面之间的导航和路由，实现不同页面的切换和展示；如果使用了路由，但是App.vue中没有<code>&lt;RouterView /&gt;</code>，则路由无法正常工作;经典内容如下：   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><br>&lt;template&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li><li>Vue应用的入口文件main.js：初始化Vue实例并将其挂载到DOM中，导出了整个应用程序所需的全局状态和方法。一般来说，在这里初始化一些全局变量或函数，以便于后续操作，其基础操作如下：<ol><li>导入router实例<code>import router from &#39;./router&#39;</code>；(访问router&#x2F;index.js文件)</li><li>创建app实例<code>const app = createApp(App)</code>，这里的App是根组件App.vue;</li><li>挂载router实例<code>app.use(router)</code></li><li>挂载app实例到指定ID的div元素上：<code>app.mount(&#39;#app&#39;)</code><ol><li>这里的#app是index.html中的一个div元素的id，Vue会将app实例挂载到这个元素上，从而渲染整个应用</li><li>你也可以将app实例挂载到其他元素上,但要在index.html中添加相应的元素以及id属性</li><li>默认使用#app的原因<ol><li>约定俗成：使用id&#x3D;”app”是Vue文档和许多示例中的常见做法，主要是为了简化学习和开发过程。开发者可以快速识别出这是Vue应用的挂载点。</li><li>避免冲突：在大型应用中，使用特定的id可以帮助避免与其他JavaScript库或框架的冲突，确保Vue应用的DOM元素明确且独特。</li></ol></li></ol></li></ol></li><li>router文件夹：<ol><li>功能：路由管理<ol><li>导入组件，定义路由规则,控制页面间的跳转逻辑</li><li>定义 URL 路径与组件的对应关系</li><li>管理路由参数传递</li><li>router&#x2F;index.js负责初始化和配置Vue应用; 主要功能如下<ol><li>定义路由routes</li><li>创造并导出router实例</li></ol></li><li>注意：不能重复导入同一个组件，否则会导致组件重复注册，从而引发错误</li></ol></li><li>典型结构<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router/index.js</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span><br><span class="hljs-keyword">const</span> routes = [<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Home.vue&#x27;</span>)<br>&#125;,<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/About.vue&#x27;</span>)<br>&#125;<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>routes<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br><br></code></pre></td></tr></table></figure></li></ol></li><li>View文件夹：<ol><li>视图功能:负责页面渲染<ol><li>存放页面级别的组件</li><li>对应具体的路由页面</li><li>组合和管理其他小组件</li></ol></li><li>与components的区别<ol><li>views：负责页面级别的组件，对应具体路由逻辑的页面（也就是说路由怎么设置的，view下就要有相应的页面组件），组合和管理其他小组件（可嵌入components中或者view中子组件）</li><li>components：负责通用的小组件，可以在多个页面中复用，不涉及具体的路由逻辑</li></ol></li><li>举例 Main.vue<ol><li>作用：主要负责页面的整体布局和结构，包含了整个页面的主要内容</li><li>典型结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- views/<span class="hljs-title class_">Main</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Aside</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><pre><code class="hljs"> 1.  services ：存放业务逻辑层面的代码，包括多个组件共用的服务端接口调用函数等 2.  utils：存放通用工具函数，不同的地方不重复书写相同的代码片段</code></pre><ol start="3"><li>当启动应用程序时，Vite 会按照如下顺序加载和处理这些文件：   <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">读取 package<span class="hljs-selector-class">.json</span>：获取项目依赖项和脚本信息。<br>解析 vue<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>：配置Vite的行为，包括环境变量管理、插件注册等。<br>载入 <span class="hljs-attribute">src</span>/App<span class="hljs-selector-class">.vue</span>：作为应用程序的根组件，负责渲染页面结构。<br>执行 <span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>：初始化应用程序，全局状态和方法的创建。<br>递归查找并加载各个组件：从根组件开始，逐级向下寻找并注入子组件，形成完整的DOM树结构。<br>优化与缓存处理：利用Vite提供的内置优化机制，对JS/CSS进行压缩混淆，以及对第三方库进行tree-shaking以减少无效代码。<br></code></pre></td></tr></table></figure></li></ol><h3 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h3><ol><li>父传子<ol><li>是组件间传递数据的主流方式，尤其是在父子组件关系明确且数据流向单一的情况下。这种方式简单且直观，适合大多数场景。</li><li>子组件使用 props 属性接收父组件传递的数据；</li><li>语法：<code>&lt;子组件 :属性名=&quot;父组件数据&quot;  :属性名=&quot;父组件数据&quot;/&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">   &lt;!-- 父组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;parentMessage&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>   &lt;!-- 选项式 --&gt;<br>&lt;script&gt;<br>   import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>   export default &#123;<br>   data() &#123;<br>      return &#123;<br>         parentMessage: &#x27;Hello from parent&#x27;<br>      &#125;;<br>   &#125;,<br>   components: &#123; ChildComponent &#125;<br>       /* 这行代码是关于组件注册的,必要的，但是如果使用&lt;script setup&gt;则可以省略<br>      组件注册目的：<br><br>      告诉 Vue 这个父组件要使用 ChildComponent 子组件<br>      建立组件间的关联关系<br>      为什么必要：<br><br>      Vue 规定必须先注册组件才能在模板中使用<br>      如果不注册就直接在模板中使用 &lt;ChildComponent&gt;，Vue 会报错<br><br>      */<br>   <br>   &#125;;<br>&lt;/script&gt;<br>&lt;!-- 组合式API --&gt;<br><br>&lt;script setup&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>const parentMessage = &#x27;Hello, Child!&#x27;;<br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 选项式<span class="hljs-variable constant_">API</span><br>   &lt;script &gt;<br>   <br>   <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>      <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;message&#x27;</span>]<br>   &#125;;<br>   &lt;/script&gt; --&gt;<br><br>   &lt;!-- 组合式<span class="hljs-variable constant_">API</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   //编译器宏：defineProps 是由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 &#x27;vue&#x27; 中导入。自动可用：在 <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"> 块内，defineProps 会被自动识别并处理。</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-comment">// 使用 defineProps 声明 props</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-attr">message</span>: &#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;);</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   </span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">   </span><br></code></pre></td></tr></table></figure></li></ol></li><li>子传父<ol><li>在子组件中触发事件</li><li>在父组件中监听事件</li><li>原理<ol><li>事件触发<ol><li>子组件通过 $emit() 触发自定义事件</li><li>可传递数据作为第二个参数</li></ol></li><li>事件监听<ol><li>父组件使用 @事件名 语法监听</li><li>通过回调函数接收数据</li></ol></li><li>数据流向:子组件 -&gt; 触发事件 -&gt; 父组件接收 -&gt; 更新数据</li></ol></li></ol></li></ol>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>发送消息到父组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br> <br>  &lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  选项式</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">     &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br><br>  &lt;!-- 组合式 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;message-event&#x27;</span>]);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ParentComponent</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>&lt;!-- 选项式 --&gt;<br>&lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title class_">ChildComponent</span><span class="hljs-comment">//注册组件</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">messageFromChild</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">handleMessageEvent</span>(<span class="hljs-params">message</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageFromChild</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br>&lt;!-- 组合式 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><a href="#%E9%80%9A%E8%BF%87useroot%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">直接通过useRoot获取全局数据，想要谁就直接通过options属性获取</a></li><li>全局状态管理：使用 Vuex 或者 Pinia 来管理全局状态，适用于复杂的应用场景。如下介绍vuex</li><li>Provide&#x2F;Inject API：适用于跨级组件间传递数据。</li><li>事件总线：使用事件总线（Event Bus）来传递数据，但这种方式在 Vue 3 中不推荐使用。</li><li>Context API：在组合式 API 中，可以通过 context 来传递数据。</li></ol><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><ul><li><p>安装：npm install vuex@next –save</p></li><li><p>核心概念</p><ol><li><p>创建和定义 store</p><ol><li>state: 存储状态信息<ol><li>store&#x2F;下定义状态信息</li><li>在组件中通过有三种方式获取state<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1内置函数computed (推荐)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 优点:</span><br><span class="hljs-comment"> 响应式: 状态变化时会自动更新视图</span><br><span class="hljs-comment"> 缓存: 计算结果会被缓存,只有依赖变化时才重新计算</span><br><span class="hljs-comment">*/</span><br><span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br><br><span class="hljs-comment">//2直接访问 (不推荐)</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  缺点:</span><br><span class="hljs-comment"> 非响应式: 状态变化时不会自动更新视图</span><br><span class="hljs-comment"> 需要手动触发更新</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-attr">count</span>: store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span><br><br><span class="hljs-comment">//3使用 ref + watch (特殊场景)</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 使用场景:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> 需要对状态变化做额外处理</span><br><span class="hljs-comment"> 需要本地维护状态副本</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br> count.<span class="hljs-property">value</span> = newVal<br> &#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>mutations: 同步修改状态<ol><li>store&#x2F;下定义修改状态的方法</li><li>当需要修改状态时，在组件中通过commit相应的mutation和参数(见store&#x2F;下定义修改状态的方法)触发重新处理&amp;赋值给state中的变量来实现状态更新</li></ol></li><li>actions: <a id="异步请求">异步操作</a><ol><li>异步请求是指发出请求后，不会立即得到结果，而是在未来某个时间点才会收到响应的操作。</li><li>为什么需要 Actions<ol><li>Mutations 必须是同步的</li><li>Actions 可以包含异步操作</li><li>Actions 可以组合多个 mutations</li></ol></li><li>使用场景          <ul><li>API 请求等延时操作</li><li>复杂的状态修改流程</li><li>需要组合多个 mutation</li><li>涉及异步操作的业务逻辑：比如定时器、延时操作、文件上传&#x2F;下载等</li></ul></li><li>特点:<ol><li>async 定义异步异步函数</li><li>通过 context 对象访问 store 实例的方法和属性</li><li>可以触发其他 actions (dispatch)</li><li>最终通过 commit 提交 mutation 修改状态</li></ol></li><li>在组件中通过dispatch提交action <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br><span class="hljs-attr">state</span>: &#123;<br>   <span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span>,<br>   <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span><br>&#125;,<br><span class="hljs-attr">mutations</span>: &#123;<br>   <span class="hljs-title function_">setUserInfo</span>(<span class="hljs-params">state, info</span>) &#123;<br>      state.<span class="hljs-property">userInfo</span> = info<br>   &#125;,<br>   <span class="hljs-title function_">setLoading</span>(<span class="hljs-params">state, status</span>) &#123;<br>      state.<span class="hljs-property">loading</span> = status<br>   &#125;<br>&#125;,<br><span class="hljs-attr">actions</span>: &#123;<br>   <span class="hljs-comment">// 1. 处理异步操作</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, credentials</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">login</span>(credentials)<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUserInfo&#x27;</span>, response.<span class="hljs-property">data</span>)<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">false</span>)<br>      &#125;<br>   &#125;,<br><br>   <span class="hljs-comment">// 2. 复杂业务逻辑</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">checkout</span>(<span class="hljs-params">&#123; commit, state, dispatch &#125;</span>) &#123;<br>      <span class="hljs-comment">// 检查库存</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;checkStock&#x27;</span>)<br>      <span class="hljs-comment">// 创建订单</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;createOrder&#x27;</span>)<br>      <span class="hljs-comment">// 清空购物车</span><br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;clearCart&#x27;</span>)<br>   &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>getters: 计算属性<ol><li>store&#x2F;下定义计算相关的方法</li><li>组件中通过store.getters调用相应的方法</li></ol></li><li>modules: 模块化管理状态<ol><li>针对不同联动事件之间有不同的关联状态和操作，因此划分成多个模块，每个模块管理相关的一部分的共享状态会更方便操作；<ol><li>比如Aside和headerNav之间的通信（联动）都是关于菜单的，于是将所有的菜单相关的状态（信息、操作等等）放在一个模块sotore&#x2F;menu.js中</li><li>需要在&#x2F;store&#x2F;index.js中导入所需模块，将创建的store导出；供main.js挂载和其他组件使用；同时模块中只需要定义被其他组件需要的state、mutations、actions、getters并导出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/sotre/index.js </span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br> <span class="hljs-keyword">import</span> menu <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./menu&quot;</span>;<br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>       menu<br>    &#125;<br> &#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//menu.js</span><br><br><span class="hljs-keyword">const</span> state=&#123;<br>   <span class="hljs-attr">isCollapse</span>:<span class="hljs-literal">false</span>,<span class="hljs-comment">//是否折叠</span><br>   <span class="hljs-attr">selectMenu</span>:[]<span class="hljs-comment">//选中的菜单</span><br>&#125;<br><br><span class="hljs-keyword">const</span> mutations=&#123;<br>   <span class="hljs-title function_">collapseMenu</span>(<span class="hljs-params">state</span>)&#123;<br>      state.<span class="hljs-property">isCollapse</span>=!state.<span class="hljs-property">isCollapse</span><span class="hljs-comment">//取反</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">//从此模块中导出此需要的数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>      state,<br>      mutations<br>&#125;<br><br><br>           <br></code></pre></td></tr></table></figure></li></ol></li><li>在vuex中如果有模块的话，组件在调用 state 时需要加上模块名，而调用 mutations、actions、getters 时则不需要加模块名。（在vue3_study_basic中亲测）   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span><br>    <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span><br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-comment">// 读取状态</span><br>       <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">count</span>),<br>       <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br>       <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">username</span>),<br>       newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span><br><br>       <span class="hljs-comment">// 状态修改：mutations</span><br>       <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br>       <span class="hljs-comment">// 重置用户名</span><br>       <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>       store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span><br>       newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span><br>       &#125;,<br>       <span class="hljs-comment">//action：异步操作</span><br>       <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span><br>    <br>    &#125;<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>在入口文件main.js中使用:</p><ol><li>创建 store 实例并挂载</li></ol></li><li><p>组件中通过 useStore() 访问和使用 </p><ol><li>如下是一个基础案例额</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br> <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>       <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br> &#125;,<br> <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">// 修改状态的方法</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>       state.<span class="hljs-property">count</span>++<br>    &#125;,<br>    <span class="hljs-title function_">setUsername</span>(<span class="hljs-params">state, username</span>) &#123;<br>       state.<span class="hljs-property">username</span> = username<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>       <span class="hljs-comment">// 模拟API调用</span><br>       <span class="hljs-comment">//使用 new Promise 和 setTimeout 模拟了一个耗时1秒的API调用</span><br>       <span class="hljs-comment">//await 会暂停执行，直到Promise完成</span><br>       <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br>       <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-comment">// 计算属性</span><br>    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params">state</span>) &#123;<br>       <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>    &#125;<br> &#125;<br> &#125;)<br><br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- main.<span class="hljs-property">js</span> --&gt;<br> <span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br> <span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br> <span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br> <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br> app.<span class="hljs-title function_">use</span>(store)<br> app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 组件.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Double Count: &#123;&#123; doubleCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Username: &#123;&#123; username || &#x27;未登录&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   </span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 点击按钮触发login方法,传入参数admin到login action --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login(&#x27;admin&#x27;)&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 添加重置按钮 --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;newUsername&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入新用户名&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">   &gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;resetUsername&quot;</span>&gt;</span>Reset User<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 读取状态</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">username</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 状态修改：mutations</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 重置用户名</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//action：异步操作</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="vuex持久化"><a href="#vuex持久化" class="headerlink" title="vuex持久化"></a><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%B7%BB%E5%8A%A0+vuex%E6%8C%81%E4%B9%85%E5%8C%96">vuex持久化</a></h4><ul><li><p>vuex-persistedstate 将 store 存储到浏览器的时机如下：这种机制确保了在页面刷新或重新打开后能够恢复之前的状态。</p></li><li><p>主要存储时机</p></li></ul><ol><li><p><strong>Store 发生变化时</strong></p><ul><li>当通过 mutation 修改 state 时</li><li>在每次 state 更新后自动触发</li></ul></li><li><p><strong>具体触发点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听 store 的变化</span><br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 将数据持久化到 localStorage</span><br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;vuex&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><ul><li>存储行为特点</li></ul><ol><li><p><strong>实时性</strong></p><ul><li>同步执行，立即存储</li><li>不需要手动触发</li></ul></li><li><p><strong>选择性存储</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> createPersistedState <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex-persistedstate&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">createPersistedState</span>(&#123;<br>      <span class="hljs-attr">paths</span>: [<span class="hljs-string">&#x27;需要持久化的state路径&#x27;</span>]  <span class="hljs-comment">// 可以选择性存储</span><br>    &#125;)<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>存储位置</strong></p><ul><li>默认使用 localStorage</li><li>可配置使用 sessionStorage 或其他存储方式</li></ul></li></ol><p><code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器。相反，它会从浏览器的存储（如<br>localStorage或 <code>sessionStorage</code>）中读取之前保存的状态，并将其恢复到 Vuex store 中。</p><ul><li>工作流程：</li></ul><ol><li><p><strong>页面加载时</strong>：</p><ul><li><code>vuex-persistedstate</code> 插件会从浏览器存储中读取之前保存的 Vuex 状态。</li><li>将读取到的状态合并到当前的 Vuex store 中。</li></ul></li><li><p><strong>状态变化时</strong>：</p><ul><li>当 Vuex store 中的状态发生变化时（通过 mutation），<code>vuex-persistedstate</code> 会将新的状态存储到浏览器中。</li></ul></li></ol><ul><li><p>总结：</p></li><li><p><strong>页面加载时</strong>：<code>vuex-persistedstate</code> 从浏览器存储中恢复状态到 Vuex store。</p></li><li><p><strong>状态变化时</strong>：<code>vuex-persistedstate</code> 将新的状态存储到浏览器中。</p></li></ul><p>因此，<code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器，而是从浏览器中读取之前保存的状态并恢复。</p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><ul><li><p>什么是<a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82">异步请求</a>？</p></li><li><p>Promise 是处理异步操作的一种方式，它代表一个异步操作的最终完成(或失败)及其结果值。</p><ul><li><p>基本用法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 基础语法</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">if</span> (成功) &#123;<br>    <span class="hljs-title function_">resolve</span>(结果)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(错误)<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 2. 使用Promise</span><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理成功</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理失败</span><br>  &#125;)<br></code></pre></td></tr></table></figure></li><li><p>实际示例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 封装API请求</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(response.<span class="hljs-property">data</span>))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">reject</span>(error))<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 2. 使用async/await简化</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserData</span>(userId)<br>    <span class="hljs-keyword">return</span> data<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取用户数据失败:&#x27;</span>, error)<br>  &#125;<br>&#125;<br><span class="hljs-comment">//3. 延时</span><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>   <span class="hljs-comment">//延时1秒</span><br><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br><span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<span class="hljs-comment">//最终通过 commit 提交 mutation 修改状态</span><br> &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>凡是内部调用多个函数且要讲究执行顺序的的函数要用异步async申明；异步操作内部要使用await调用已存在的方法，外部也要用async申明参数，每一环都是如此；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//group/index.vue的提交弹窗逻辑</span><br><span class="hljs-keyword">const</span> localData=<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;pz_v3pz&#x27;</span>)<br><span class="hljs-keyword">import</span> &#123; computed, toRaw &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> routerList=<span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>store.<span class="hljs-property">state</span>.<span class="hljs-property">menu</span>.<span class="hljs-property">routerList</span>)<br><span class="hljs-comment">//内有异步操作</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">confirm</span>=<span class="hljs-keyword">async</span> (<span class="hljs-params">formEl</span>)=&gt;&#123;<br>  <span class="hljs-keyword">if</span> (!formEl) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">//内有异步操作</span><br>  <span class="hljs-keyword">await</span> formEl.<span class="hljs-title function_">validate</span>( <span class="hljs-title function_">async</span>(valid,fields)=&gt;&#123;<br>    <span class="hljs-keyword">if</span> (valid) &#123;<br>      <span class="hljs-comment">//根据APi文档可知，其中一个参数为permissions：string,故要将选中的权限字符串化</span><br>      <span class="hljs-keyword">const</span> permissions = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(treeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">getCheckedKeys</span>())<br>      <span class="hljs-comment">// console.log(permissions)</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1. 先执行 userSetMenu请求重新设置菜单数据</span><br><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">userSetMenu</span>(&#123;<br>          <span class="hljs-attr">name</span>: form.<span class="hljs-property">name</span>,<br>          permissions,<span class="hljs-comment">//参数名与变量名同名时，可以简写：一个即可，不需要：</span><br><br>          <span class="hljs-attr">id</span>: form.<span class="hljs-property">id</span><br>        &#125;)<br>        <br>        <span class="hljs-comment">// 2. 更新列表数据</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">getListData</span>()<br>        <br>        <span class="hljs-comment">// 3. 关闭弹窗</span><br>        <span class="hljs-title function_">beforeClose</span>()<br>        <br>        <span class="hljs-comment">// 4. 再执行 menuPermissions</span><br>        <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">menuPermissions</span>()<br>        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;dynamicMenu&#x27;</span>, data.<span class="hljs-property">data</span>)<br>        <br>        <span class="hljs-comment">// 5. 添加路由</span><br>        <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>, item)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;操作失败:&#x27;</span>, error)<br>      &#125;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error submit!&#x27;</span>,fields)<br>    &#125;<br>  &#125;)<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><ul><li><a href="#axios%E6%A0%B8%E5%BF%83">axios核心</a></li><li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84network">浏览器的network</a></li></ul><h4 id="API"><a href="#API" class="headerlink" title="API"></a><a href="#%E5%AE%9A%E4%B9%89api%E6%8E%A5%E5%8F%A3">API</a></h4><h3 id="Router路由管理"><a href="#Router路由管理" class="headerlink" title="Router路由管理"></a>Router路由管理</h3><p>在 Vue 3 中，<code>useRoute</code> 和 <code>useRouter</code> 都是 Vue Router 提供的组合式 API，用于在组合式函数中访问路由。</p><p><strong>区别：</strong></p><ul><li><code>useRoute</code> 用于访问当前路由的状态，是只读的。</li><li><code>useRouter</code> 用于执行路由操作，如导航、切换、添加路由等。</li></ul><hr><ul><li><p><strong><code>useRoute</code></strong></p><ul><li><p>返回当前激活的路由信息，是一个只读的响应式对象。</p></li><li><p>可以获取路由的‘meta’、 <code>path</code>、<code>params</code>、<code>query</code>、<code>name</code> 等属性。</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">path</span>) <span class="hljs-comment">// 输出当前路径</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>) <span class="hljs-comment">// 获取路由参数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>useRouter</code></strong></p><ul><li><p>返回当前组件的路由实例对象，可以使用它进行添加路由、导航等操作。</p></li><li><p>提供了‘addRoute’、 <code>push</code>、<code>replace</code> 等方法</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">goHome</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span> &#125;) <span class="hljs-comment">// 导航到名为 &#x27;Home&#x27; 的路由</span><br>  <span class="hljs-comment">//遍历数据中的路由信息添加到main路由下</span><br>  <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>,item)<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="html-css-js基础补充"><a href="#html-css-js基础补充" class="headerlink" title="html+css+js基础补充"></a>html+css+js基础补充</h2><h3 id="html-css"><a href="#html-css" class="headerlink" title="html+css"></a>html+css</h3><ol><li>img等行内元素不吃&#x2F;同时吃高度和宽度，必须将其设置为块级元素:如下实现图片填充满整个父元素<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%;height: 100%;display: block;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="js-1"><a href="#js-1" class="headerlink" title="js"></a>js</h3><ol><li>导出导入<ol><li>export default:导出一个默认的对象，一个文件只能有一个默认导出 <ol><li>导入时可以自定义名字from ‘文件路径‘,<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模块A.js</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;John&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> name;<br><br><span class="hljs-comment">// 模块B.js</span><br><span class="hljs-keyword">import</span> myName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./A.js&#x27;</span>; <span class="hljs-comment">// 可以使用任意名称</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">// 输出: &#x27;John&#x27;</span><br>      <br></code></pre></td></tr></table></figure></li></ol></li><li>直接export导出（ 非默认）,导入时必须使用与导出时相同的名称，并且需要使用花括号<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模块A.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;John&#x27;</span>;<br><br><span class="hljs-comment">// 模块B.js</span><br><span class="hljs-keyword">import</span> &#123; name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./A.js&#x27;</span>; <span class="hljs-comment">// 必须使用相同的名称</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 输出: &#x27;John&#x27;</span><br><span class="hljs-comment">//导入组件</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElMessage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus/es&#x27;</span><br><span class="hljs-comment">//导入函数   </span><br><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br></code></pre></td></tr></table></figure></li><li>导出时的路径<ul><li>在JavaScript中，使用<code>import</code>语句时，路径是否必须包含文件后缀取决于多个因素，包括所使用的模块系统（如ES模块或CommonJS）以及运行环境（如Node.js或浏览器）。</li><li>在使用ES模块时，路径后面必须包含文件后缀，以确保代码在不同环境中的兼容性和可预测性。而在CommonJS模块中，虽然可以省略后缀，但为了提高代码的清晰度和一致性，建议始终使用完整的路径。</li></ul></li><li>最好把所有导入的东西写在script最前面，导出的东西写在最后面，这样方便查看和修改以及debug</li></ol></li><li>字符串中解析变量（即常量和变量混在一个字符串里），需要使用模板字符串，即用反引号(esc下方）包裹字符串，而不是单引号’<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">`../view<span class="hljs-subst">$&#123;route.meta.path&#125;</span>/index.vue;</span><br><span class="hljs-string">   </span><br></code></pre></td></tr></table></figure></li></ol><h3 id="token的作用以及为什么要检测是否过期"><a href="#token的作用以及为什么要检测是否过期" class="headerlink" title="token的作用以及为什么要检测是否过期"></a><a id="token详解">token的作用以及为什么要检测是否过期</a></h3><p>Token（令牌）是一种用于身份验证和授权的机制，通常在用户登录时生成，并在后续请求中用于验证用户身份。以下是Token的功能和检测Token是否过期的作用：</p><h4 id="Token的功能"><a href="#Token的功能" class="headerlink" title="Token的功能"></a>Token的功能</h4><ol><li><strong>身份验证</strong>：Token用于验证用户的身份，确保请求是由合法用户发起的。</li><li><strong>授权</strong>：Token可以包含用户的权限信息，用于控制用户对资源的访问权限。</li><li><strong>无状态</strong>：Token通常是无状态的，服务器不需要存储用户的会话信息，减轻了服务器的负担。<ul><li>用户的会话信息是指在用户与服务器交互期间，用于跟踪和管理用户状态的数据。会话信息通常包含以下内容：</li></ul><ol><li><strong>用户身份</strong>：用户的唯一标识符，如用户ID或用户名。</li><li><strong>认证信息</strong>：用于验证用户身份的凭证，如Token或Session ID。</li><li><strong>用户权限</strong>：用户在系统中的权限和角色信息，用于控制用户对资源的访问权限。</li><li><strong>会话状态</strong>：用户当前的状态信息，如登录状态、购物车内容等。</li><li><strong>其他上下文信息</strong>：与用户操作相关的临时数据，如表单数据、浏览历史等。</li></ol><ul><li>在传统的会话管理中，服务器会在内存或数据库中存储这些会话信息，并通过Session ID在客户端和服务器之间进行关联。而在使用Token的无状态认证机制中，会话信息通常包含在浏览器的cookie&#x2F;Token中，由客户端保存在本地，并在每次请求时发送给服务器进行验证,减轻了服务器的负担。</li></ul></li><li><strong>安全性</strong>：Token可以通过加密和签名来确保数据的完整性和安全性，防止篡改和伪造。</li></ol><h4 id="检测Token是否过期的作用"><a href="#检测Token是否过期的作用" class="headerlink" title="检测Token是否过期的作用"></a>检测Token是否过期的作用</h4><ol><li><strong>安全性</strong>：检测Token是否过期可以防止长期未使用的Token被恶意利用，确保用户的账户安全。</li><li><strong>用户体验</strong>：及时检测Token过期并提示用户重新登录，可以确保用户的操作不会因为Token失效而中断。</li><li><strong>资源保护</strong>：通过检测Token过期，可以防止未经授权的访问，保护服务器资源和数据的安全。</li><li><strong>合规性</strong>：一些安全标准和法规要求定期验证用户身份（类比身份证每隔一段时间也得检查），检测Token过期是实现这一要求的有效手段。</li></ol><h4 id="检测Token是否过期的实现"><a href="#检测Token是否过期的实现" class="headerlink" title="检测Token是否过期的实现"></a>检测Token是否过期的实现</h4><ol><li><strong>Token中包含过期时间</strong>：在生成Token时，将过期时间（如<code>exp</code>字段）包含在Token中，客户端和服务器可以根据这个时间判断Token是否过期。</li><li><strong>服务器端验证</strong>：每次请求时，服务器验证Token的有效性和过期时间，如果Token过期，则返回相应的错误码（如401 Unauthorized）。</li><li><strong>客户端处理</strong>：客户端在接收到Token过期的响应后，可以清除本地存储的Token，并引导用户重新登录。</li></ol><ul><li>通过上述机制，可以有效地管理Token的生命周期，确保系统的安全性和用户体验。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>router</title>
    <link href="/2024/10/20/router/"/>
    <url>/2024/10/20/router/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Vue3 Router</p></blockquote><span id="more"></span><h3 id="Router路由管理"><a href="#Router路由管理" class="headerlink" title="Router路由管理"></a>Router路由管理</h3><p>在 Vue 3 中，<code>useRoute</code> 和 <code>useRouter</code> 都是 Vue Router 提供的组合式 API，用于在组合式函数中访问路由。</p><p><strong>区别：</strong></p><ul><li><code>useRoute</code> 用于访问当前路由的状态，是只读的。</li><li><code>useRouter</code> 用于执行路由操作，如导航、切换、添加路由等。</li></ul><hr><ul><li><p><strong><code>useRoute</code></strong></p><ul><li><p>返回当前激活的路由信息，是一个只读的响应式对象。</p></li><li><p>可以获取路由的‘meta’、 <code>path</code>、<code>params</code>、<code>query</code>、<code>name</code> 等属性。</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">path</span>) <span class="hljs-comment">// 输出当前路径</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>) <span class="hljs-comment">// 获取路由参数</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>useRouter</code></strong></p><ul><li><p>返回当前组件的路由实例对象，可以使用它进行添加路由、导航等操作。</p></li><li><p>提供了‘addRoute’、 <code>push</code>、<code>replace</code> 等方法</p></li><li><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">goHome</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span> &#125;) <span class="hljs-comment">// 导航到名为 &#x27;Home&#x27; 的路由</span><br>  <span class="hljs-comment">//遍历数据中的路由信息添加到main路由下</span><br>  <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>,item)<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transData</title>
    <link href="/2024/10/19/transData/"/>
    <url>/2024/10/19/transData/</url>
    
    <content type="html"><![CDATA[<blockquote><p>讲述Vue3中数据传输的方法以及异步操作</p></blockquote><span id="more"></span><h2 id="Vue3中的数据传递"><a href="#Vue3中的数据传递" class="headerlink" title="Vue3中的数据传递"></a>Vue3中的数据传递</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ol><li>是组件间传递数据的主流方式，尤其是在父子组件关系明确且数据流向单一的情况下。这种方式简单且直观，适合大多数场景。</li><li>子组件使用 props 属性接收父组件传递的数据；</li><li>语法：<code>&lt;子组件 :属性名=&quot;父组件数据&quot;  :属性名=&quot;父组件数据&quot;/&gt;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">   &lt;!-- 父组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;parentMessage&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>   &lt;!-- 选项式 --&gt;<br>&lt;script&gt;<br>   import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>   export default &#123;<br>   data() &#123;<br>      return &#123;<br>         parentMessage: &#x27;Hello from parent&#x27;<br>      &#125;;<br>   &#125;,<br>   components: &#123; ChildComponent &#125;<br>       /* 这行代码是关于组件注册的,必要的，但是如果使用&lt;script setup&gt;则可以省略<br>      组件注册目的：<br><br>      告诉 Vue 这个父组件要使用 ChildComponent 子组件<br>      建立组件间的关联关系<br>      为什么必要：<br><br>      Vue 规定必须先注册组件才能在模板中使用<br>      如果不注册就直接在模板中使用 &lt;ChildComponent&gt;，Vue 会报错<br><br>      */<br>   <br>   &#125;;<br>&lt;/script&gt;<br>&lt;!-- 组合式API --&gt;<br><br>&lt;script setup&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>const parentMessage = &#x27;Hello, Child!&#x27;;<br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 选项式<span class="hljs-variable constant_">API</span><br>   &lt;script &gt;<br>   <br>   <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>      <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;message&#x27;</span>]<br>   &#125;;<br>   &lt;/script&gt; --&gt;<br><br>   &lt;!-- 组合式<span class="hljs-variable constant_">API</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   //编译器宏：defineProps 是由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 &#x27;vue&#x27; 中导入。自动可用：在 <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"> 块内，defineProps 会被自动识别并处理。</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-comment">// 使用 defineProps 声明 props</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   <span class="hljs-attr">message</span>: &#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   &#125;);</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">   </span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">   </span><br></code></pre></td></tr></table></figure></li></ol><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><ol><li><p>在子组件中触发事件</p></li><li><p>在父组件中监听事件</p></li><li><p>原理</p><ol><li>事件触发<ol><li>子组件通过 $emit() 触发自定义事件</li><li>可传递数据作为第二个参数</li></ol></li><li>事件监听<ol><li>父组件使用 @事件名 语法监听</li><li>通过回调函数接收数据</li></ol></li><li>数据流向:子组件 -&gt; 触发事件 -&gt; 父组件接收 -&gt; 更新数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>发送消息到父组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br> <br>  &lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  选项式</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">     &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br><br>  &lt;!-- 组合式 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;message-event&#x27;</span>]);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">ParentComponent</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>&lt;!-- 选项式 --&gt;<br>&lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title class_">ChildComponent</span><span class="hljs-comment">//注册组件</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">messageFromChild</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">handleMessageEvent</span>(<span class="hljs-params">message</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageFromChild</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span> --&gt;<br>&lt;!-- 组合式 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li><a href="#%E9%80%9A%E8%BF%87useroot%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">直接通过useRoot获取全局数据，想要谁就直接通过options属性获取</a></li><li>全局状态管理：使用 Vuex 或者 Pinia 来管理全局状态，适用于复杂的应用场景。如下介绍vuex</li><li>Provide&#x2F;Inject API：适用于跨级组件间传递数据。</li><li>事件总线：使用事件总线（Event Bus）来传递数据，但这种方式在 Vue 3 中不推荐使用。</li><li>Context API：在组合式 API 中，可以通过 context 来传递数据。</li></ol></li></ol><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><ul><li><p>安装：npm install vuex@next –save</p></li><li><p>核心概念</p><ol><li><p>创建和定义 store</p><ol><li>state: 存储状态信息<ol><li>store&#x2F;下定义状态信息</li><li>在组件中通过有三种方式获取state<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1内置函数computed (推荐)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 优点:</span><br><span class="hljs-comment"> 响应式: 状态变化时会自动更新视图</span><br><span class="hljs-comment"> 缓存: 计算结果会被缓存,只有依赖变化时才重新计算</span><br><span class="hljs-comment">*/</span><br><span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br><br><span class="hljs-comment">//2直接访问 (不推荐)</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  缺点:</span><br><span class="hljs-comment"> 非响应式: 状态变化时不会自动更新视图</span><br><span class="hljs-comment"> 需要手动触发更新</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-attr">count</span>: store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span><br><br><span class="hljs-comment">//3使用 ref + watch (特殊场景)</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 使用场景:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> 需要对状态变化做额外处理</span><br><span class="hljs-comment"> 需要本地维护状态副本</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br> count.<span class="hljs-property">value</span> = newVal<br> &#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>mutations: 同步修改状态<ol><li>store&#x2F;下定义修改状态的方法</li><li>当需要修改状态时，在组件中通过commit相应的mutation和参数(见store&#x2F;下定义修改状态的方法)触发重新处理&amp;赋值给state中的变量来实现状态更新</li></ol></li><li>actions: <a id="异步请求">异步操作</a><ol><li>异步请求是指发出请求后，不会立即得到结果，而是在未来某个时间点才会收到响应的操作。</li><li>为什么需要 Actions<ol><li>Mutations 必须是同步的</li><li>Actions 可以包含异步操作</li><li>Actions 可以组合多个 mutations</li></ol></li><li>使用场景          <ul><li>API 请求等延时操作</li><li>复杂的状态修改流程</li><li>需要组合多个 mutation</li><li>涉及异步操作的业务逻辑：比如定时器、延时操作、文件上传&#x2F;下载等</li></ul></li><li>特点:<ol><li>async 定义异步异步函数</li><li>通过 context 对象访问 store 实例的方法和属性</li><li>可以触发其他 actions (dispatch)</li><li>最终通过 commit 提交 mutation 修改状态</li></ol></li><li>在组件中通过dispatch提交action <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br><span class="hljs-attr">state</span>: &#123;<br>   <span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span>,<br>   <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span><br>&#125;,<br><span class="hljs-attr">mutations</span>: &#123;<br>   <span class="hljs-title function_">setUserInfo</span>(<span class="hljs-params">state, info</span>) &#123;<br>      state.<span class="hljs-property">userInfo</span> = info<br>   &#125;,<br>   <span class="hljs-title function_">setLoading</span>(<span class="hljs-params">state, status</span>) &#123;<br>      state.<span class="hljs-property">loading</span> = status<br>   &#125;<br>&#125;,<br><span class="hljs-attr">actions</span>: &#123;<br>   <span class="hljs-comment">// 1. 处理异步操作</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, credentials</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">login</span>(credentials)<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUserInfo&#x27;</span>, response.<span class="hljs-property">data</span>)<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setLoading&#x27;</span>, <span class="hljs-literal">false</span>)<br>      &#125;<br>   &#125;,<br><br>   <span class="hljs-comment">// 2. 复杂业务逻辑</span><br>   <span class="hljs-keyword">async</span> <span class="hljs-title function_">checkout</span>(<span class="hljs-params">&#123; commit, state, dispatch &#125;</span>) &#123;<br>      <span class="hljs-comment">// 检查库存</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;checkStock&#x27;</span>)<br>      <span class="hljs-comment">// 创建订单</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;createOrder&#x27;</span>)<br>      <span class="hljs-comment">// 清空购物车</span><br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;clearCart&#x27;</span>)<br>   &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol></li><li>getters: 计算属性<ol><li>store&#x2F;下定义计算相关的方法</li><li>组件中通过store.getters调用相应的方法</li></ol></li><li>modules: 模块化管理状态<ol><li>针对不同联动事件之间有不同的关联状态和操作，因此划分成多个模块，每个模块管理相关的一部分的共享状态会更方便操作；<ol><li>比如Aside和headerNav之间的通信（联动）都是关于菜单的，于是将所有的菜单相关的状态（信息、操作等等）放在一个模块sotore&#x2F;menu.js中</li><li>需要在&#x2F;store&#x2F;index.js中导入所需模块，将创建的store导出；供main.js挂载和其他组件使用；同时模块中只需要定义被其他组件需要的state、mutations、actions、getters并导出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/sotre/index.js </span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br> <span class="hljs-keyword">import</span> menu <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./menu&quot;</span>;<br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>       menu<br>    &#125;<br> &#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//menu.js</span><br><br><span class="hljs-keyword">const</span> state=&#123;<br>   <span class="hljs-attr">isCollapse</span>:<span class="hljs-literal">false</span>,<span class="hljs-comment">//是否折叠</span><br>   <span class="hljs-attr">selectMenu</span>:[]<span class="hljs-comment">//选中的菜单</span><br>&#125;<br><br><span class="hljs-keyword">const</span> mutations=&#123;<br>   <span class="hljs-title function_">collapseMenu</span>(<span class="hljs-params">state</span>)&#123;<br>      state.<span class="hljs-property">isCollapse</span>=!state.<span class="hljs-property">isCollapse</span><span class="hljs-comment">//取反</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">//从此模块中导出此需要的数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>      state,<br>      mutations<br>&#125;<br><br><br>           <br></code></pre></td></tr></table></figure></li></ol></li><li>在vuex中如果有模块的话，组件在调用 state 时需要加上模块名，而调用 mutations、actions、getters 时则不需要加模块名。（在vue3_study_basic中亲测）   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span><br>    <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span><br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-comment">// 读取状态</span><br>       <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">count</span>),<br>       <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),<br>       <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">Try</span>.<span class="hljs-property">username</span>),<br>       newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span><br><br>       <span class="hljs-comment">// 状态修改：mutations</span><br>       <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br>       <span class="hljs-comment">// 重置用户名</span><br>       <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>       store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span><br>       newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span><br>       &#125;,<br>       <span class="hljs-comment">//action：异步操作</span><br>       <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span><br>    <br>    &#125;<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>在入口文件main.js中使用:</p><ol><li>创建 store 实例并挂载</li></ol></li><li><p>组件中通过 useStore() 访问和使用 </p><ol><li>如下是一个基础案例额</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br> <span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br> <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>       <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>       <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br> &#125;,<br> <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">// 修改状态的方法</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>       state.<span class="hljs-property">count</span>++<br>    &#125;,<br>    <span class="hljs-title function_">setUsername</span>(<span class="hljs-params">state, username</span>) &#123;<br>       state.<span class="hljs-property">username</span> = username<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-comment">// 异步操作</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>       <span class="hljs-comment">// 模拟API调用</span><br>       <span class="hljs-comment">//使用 new Promise 和 setTimeout 模拟了一个耗时1秒的API调用</span><br>       <span class="hljs-comment">//await 会暂停执行，直到Promise完成</span><br>       <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br>       <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<br>    &#125;<br> &#125;,<br> <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-comment">// 计算属性</span><br>    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params">state</span>) &#123;<br>       <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>    &#125;<br> &#125;<br> &#125;)<br><br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- main.<span class="hljs-property">js</span> --&gt;<br> <span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br> <span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br> <span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br> <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br> app.<span class="hljs-title function_">use</span>(store)<br> app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 组件.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Double Count: &#123;&#123; doubleCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Username: &#123;&#123; username || &#x27;未登录&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">   </span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 点击按钮触发login方法,传入参数admin到login action --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;login(&#x27;admin&#x27;)&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-comment">&lt;!-- 添加重置按钮 --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;newUsername&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入新用户名&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">   &gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;resetUsername&quot;</span>&gt;</span>Reset User<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()<span class="hljs-comment">//获取store实例</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> newUsername = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 新增响应式变量存储输入值</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 读取状态</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">doubleCount</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">username</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">username</span>),</span></span><br><span class="language-javascript"><span class="language-xml">      newUsername,<span class="hljs-comment">//这其实是newUsername:newUsername的简写;代表将newUsername暴露给模板即将输入框的值暴重新赋值给newUsername（不能忽略）</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 状态修改：mutations</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 重置用户名</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">resetUsername</span>: <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, newUsername.<span class="hljs-property">value</span>)<span class="hljs-comment">//提交一个名为setUsername的变化</span></span></span><br><span class="language-javascript"><span class="language-xml">      newUsername.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// 清空输入框</span></span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">//action：异步操作</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">login</span>: <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;login&#x27;</span>, username),<span class="hljs-comment">//分发一个名为login的action</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h4 id="vuex持久化"><a href="#vuex持久化" class="headerlink" title="vuex持久化"></a><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E6%B7%BB%E5%8A%A0+vuex%E6%8C%81%E4%B9%85%E5%8C%96">vuex持久化</a></h4><ul><li><p>vuex-persistedstate 将 store 存储到浏览器的时机如下：这种机制确保了在页面刷新或重新打开后能够恢复之前的状态。</p></li><li><p>主要存储时机</p></li></ul><ol><li><p><strong>Store 发生变化时</strong></p><ul><li>当通过 mutation 修改 state 时</li><li>在每次 state 更新后自动触发</li></ul></li><li><p><strong>具体触发点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听 store 的变化</span><br>store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 将数据持久化到 localStorage</span><br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;vuex&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><ul><li>存储行为特点</li></ul><ol><li><p><strong>实时性</strong></p><ul><li>同步执行，立即存储</li><li>不需要手动触发</li></ul></li><li><p><strong>选择性存储</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> createPersistedState <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex-persistedstate&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">createPersistedState</span>(&#123;<br>      <span class="hljs-attr">paths</span>: [<span class="hljs-string">&#x27;需要持久化的state路径&#x27;</span>]  <span class="hljs-comment">// 可以选择性存储</span><br>    &#125;)<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>存储位置</strong></p><ul><li>默认使用 localStorage</li><li>可配置使用 sessionStorage 或其他存储方式</li></ul></li></ol><p><code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器。相反，它会从浏览器的存储（如<br>localStorage或 <code>sessionStorage</code>）中读取之前保存的状态，并将其恢复到 Vuex store 中。</p><ul><li>工作流程：</li></ul><ol><li><p><strong>页面加载时</strong>：</p><ul><li><code>vuex-persistedstate</code> 插件会从浏览器存储中读取之前保存的 Vuex 状态。</li><li>将读取到的状态合并到当前的 Vuex store 中。</li></ul></li><li><p><strong>状态变化时</strong>：</p><ul><li>当 Vuex store 中的状态发生变化时（通过 mutation），<code>vuex-persistedstate</code> 会将新的状态存储到浏览器中。</li></ul></li></ol><ul><li><p>总结：</p></li><li><p><strong>页面加载时</strong>：<code>vuex-persistedstate</code> 从浏览器存储中恢复状态到 Vuex store。</p></li><li><p><strong>状态变化时</strong>：<code>vuex-persistedstate</code> 将新的状态存储到浏览器中。</p></li></ul><p>因此，<code>vuex-persistedstate</code> 插件在页面刚刚打开进行渲染时，不会立即将 store 存储到浏览器，而是从浏览器中读取之前保存的状态并恢复。</p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><ul><li><p>什么是<a href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82">异步请求</a>？</p></li><li><p>Promise 是处理异步操作的一种方式，它代表一个异步操作的最终完成(或失败)及其结果值。</p><ul><li><p>基本用法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 基础语法</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">if</span> (成功) &#123;<br>    <span class="hljs-title function_">resolve</span>(结果)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(错误)<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 2. 使用Promise</span><br>promise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理成功</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理失败</span><br>  &#125;)<br></code></pre></td></tr></table></figure></li><li><p>实际示例</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 封装API请求</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/users/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(response.<span class="hljs-property">data</span>))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">reject</span>(error))<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 2. 使用async/await简化</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserData</span>(<span class="hljs-params">userId</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserData</span>(userId)<br>    <span class="hljs-keyword">return</span> data<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取用户数据失败:&#x27;</span>, error)<br>  &#125;<br>&#125;<br><span class="hljs-comment">//3. 延时</span><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">&#123; commit &#125;, username</span>) &#123;<br>   <span class="hljs-comment">//延时1秒</span><br><span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br><span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUsername&#x27;</span>, username)<span class="hljs-comment">//最终通过 commit 提交 mutation 修改状态</span><br> &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>凡是内部调用多个函数且要讲究执行顺序的的函数要用异步async申明；异步操作内部要使用await调用已存在的方法，外部也要用async申明参数，每一环都是如此；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//group/index.vue的提交弹窗逻辑</span><br><span class="hljs-keyword">const</span> localData=<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;pz_v3pz&#x27;</span>)<br><span class="hljs-keyword">import</span> &#123; computed, toRaw &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> routerList=<span class="hljs-title function_">computed</span>(<span class="hljs-function">()=&gt;</span>store.<span class="hljs-property">state</span>.<span class="hljs-property">menu</span>.<span class="hljs-property">routerList</span>)<br><span class="hljs-comment">//内有异步操作</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">confirm</span>=<span class="hljs-keyword">async</span> (<span class="hljs-params">formEl</span>)=&gt;&#123;<br>  <span class="hljs-keyword">if</span> (!formEl) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">//内有异步操作</span><br>  <span class="hljs-keyword">await</span> formEl.<span class="hljs-title function_">validate</span>( <span class="hljs-title function_">async</span>(valid,fields)=&gt;&#123;<br>    <span class="hljs-keyword">if</span> (valid) &#123;<br>      <span class="hljs-comment">//根据APi文档可知，其中一个参数为permissions：string,故要将选中的权限字符串化</span><br>      <span class="hljs-keyword">const</span> permissions = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(treeRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">getCheckedKeys</span>())<br>      <span class="hljs-comment">// console.log(permissions)</span><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1. 先执行 userSetMenu请求重新设置菜单数据</span><br><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">userSetMenu</span>(&#123;<br>          <span class="hljs-attr">name</span>: form.<span class="hljs-property">name</span>,<br>          permissions,<span class="hljs-comment">//参数名与变量名同名时，可以简写：一个即可，不需要：</span><br><br>          <span class="hljs-attr">id</span>: form.<span class="hljs-property">id</span><br>        &#125;)<br>        <br>        <span class="hljs-comment">// 2. 更新列表数据</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">getListData</span>()<br>        <br>        <span class="hljs-comment">// 3. 关闭弹窗</span><br>        <span class="hljs-title function_">beforeClose</span>()<br>        <br>        <span class="hljs-comment">// 4. 再执行 menuPermissions</span><br>        <span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">menuPermissions</span>()<br>        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;dynamicMenu&#x27;</span>, data.<span class="hljs-property">data</span>)<br>        <br>        <span class="hljs-comment">// 5. 添加路由</span><br>        <span class="hljs-title function_">toRaw</span>(routerList.<span class="hljs-property">value</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&#x27;main&#x27;</span>, item)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;操作失败:&#x27;</span>, error)<br>      &#125;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error submit!&#x27;</span>,fields)<br>    &#125;<br>  &#125;)<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEO</title>
    <link href="/2024/10/18/SEO/"/>
    <url>/2024/10/18/SEO/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Talk about SEO </p></blockquote><span id="more"></span><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><ul><li><p>对 SEO 的理解<br>  - <code>SEO</code> :“<a href="https://zhida.zhihu.com/search?content_id=247338801&content_type=Article&match_order=1&q=%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96&zhida_source=entity">搜索引擎优化</a>”（<code>Search Engine Optimization</code>）。</p><p>  - 旨在提高网站在<a href="https://zhida.zhihu.com/search?content_id=247338801&content_type=Article&match_order=1&q=%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%9C%E9%A1%B5%E9%9D%A2&zhida_source=entity">搜索引擎结果页面</a>（<code>SERP</code>）中可见性和排名的技术和策略。</p><p>  - 主要目标是增加有机（非付费）流量，也就是通过自然搜索结果吸引访问者，而不是通过付费广告获取流量。</p></li><li><p>如何做好SEO</p><ul><li>技术方面<ul><li>html中<ul><li>设置目标客群最常搜寻的关键字，推荐承载3-5个关键词</li><li>使用包含关键字的具有吸引力的标题、并在内容中自然地融入关键字；</li><li>写好description尽可能完整精确地地描述网站的内容；</li></ul></li><li>多使用html语义化标签布局页面比如Nav,h5、Aside、footer等等 建立清晰的网站架构，方便搜寻引擎爬虫抓取</li><li>结构化资料： 帮助搜寻引擎更好地理解网站内容</li><li>提高用户的体验感<ul><li>优化网站的速度、性能</li></ul></li><li>获得其他网站的连结，提升网站权威性</li></ul></li></ul></li><li><p>其余方面</p><ul><li>把网站内容丰富起来，控制好内容质量（比如stackflow），网站内容越丰富、质量越高，用户在上面停留的时间越长，搜索引擎就会将其放在越前面；其实谷歌搜索引擎影响结果占比权重最高的就是用户在搜索对应关键词时停留在页面上的时间，所有很多哪怕是在谷歌工作过的大牛，他们都明白谷歌的搜索引擎是没有漏洞可以钻的，最好的方式就是提高网站的内容质量和丰富性，让用户在你的网站停留的时间越长，你的网站在搜索结果中的排名就越高；<ul><li>网站内容质量高，也会被其他的网站大量引入链接、提高曝光率吸引流量</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>FontEnd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueKey</title>
    <link href="/2024/10/17/VueKey/"/>
    <url>/2024/10/17/VueKey/</url>
    
    <content type="html"><![CDATA[<blockquote><p>vue3核心语法</p></blockquote><span id="more"></span><h3 id="vue3核心语法"><a href="#vue3核心语法" class="headerlink" title="vue3核心语法"></a>vue3核心语法</h3><ul><li>hook<ul><li><p>简单来讲就是自定义的包&#x2F;库（python等各种语言中都有）；是Vue 3中的重要特性，通过组合式API实现了对状态和副作用的管理，使得逻辑复用变得更加简单和高效。与传统的mixins相比，Hooks提供了更好的灵活性和可维护性，是现代Vue开发中不可或缺的一部分。主要用于封装可重用的逻辑和管理组件的状态、生命周期以及副作用。允许开发者以函数的形式组织和复用代码，从而提高代码的可维护性和可读性。</p></li><li><p>Vue Hook的作用</p><ul><li><p><strong>状态逻辑复用</strong>：Vue Hook允许在多个组件之间共享状态逻辑，避免重复代码。例如，可以创建一个自定义Hook来处理表单输入状态，然后在多个表单组件中使用。</p></li><li><p><strong>生命周期管理</strong>：Hooks提供了一系列生命周期钩子函数，如<code>onMounted</code>、<code>onUpdated</code>、<code>onUnmounted</code>等，帮助开发者在组件不同阶段执行特定操作。例如，可以在组件挂载后发起数据请求，或在组件卸载前清理定时器。</p></li><li><p><strong>简化代码结构</strong>：通过将逻辑封装到Hooks中，可以使组件代码更简洁，逻辑更集中，便于理解和维护。这种方式比传统的mixins更清晰，因为Hooks是以函数形式存在，避免了命名冲突和逻辑散落的问题。</p></li><li><p><strong>响应式数据处理</strong>：使用Hooks时，可以利用Vue 3中的响应式API（如<code>ref</code>、<code>reactive</code>、<code>computed</code>）来创建响应式数据，使得状态管理更加直观和高效。</p></li></ul></li><li><p>自定义Hooks：是开发者根据需要创建的函数，通常以<code>use</code>开头，例如<code>useFetchData</code>。这些函数可以调用其他Hooks，并返回响应式数据或方法，以供组件使用。自定义Hooks的基本规范包括：</p><ul><li><p>函数名以<code>use</code>开头。</p></li><li><p>在组件的<code>setup</code>函数中调用自定义Hook。</p></li><li><p>返回响应式变量或方法，以便在组件中解构使用。</p><p>例如，一个简单的自定义Hook可以用于处理本地存储：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) &#123;<br>   <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(initialValue);<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)) &#123;<br>      data.<span class="hljs-property">value</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key));<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(initialValue));<br>   &#125;<br><br>   <span class="hljs-title function_">watch</span>(data, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(newValue));<br>   &#125;);<br><br>   <span class="hljs-keyword">return</span> &#123; data &#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   1. **数据持久化存储**:</span><br><span class="hljs-comment">   if (localStorage.getItem(key)) &#123;</span><br><span class="hljs-comment">      data.value = JSON.parse(localStorage.getItem(key));</span><br><span class="hljs-comment">   &#125; else &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(initialValue));</span><br><span class="hljs-comment">   &#125;</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   - 当首次使用时，如果 localStorage 中不存在数据，则存入初始值</span><br><span class="hljs-comment">   - 如果已存在数据，则读取已保存的数据</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   2. **响应式数据管理**:</span><br><span class="hljs-comment">   const data = ref(initialValue);</span><br><span class="hljs-comment">   - 使用 ref创建响应式数据，可以在组件中实时反映数据变化</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   3. **自动同步到 localStorage**:</span><br><span class="hljs-comment">   watch(data, (newValue) =&gt; &#123;</span><br><span class="hljs-comment">      localStorage.setItem(key, JSON.stringify(newValue));</span><br><span class="hljs-comment">   &#125;);</span><br><span class="hljs-comment">   - 通过 watch监听数据变化</span><br><span class="hljs-comment">   - 当数据发生变化时，自动更新到 localStorage 中</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   使用示例(在src/view/try.vue中):</span><br><span class="hljs-comment">   const &#123; data &#125; = useLocalStorage(&#x27;myData&#x27;, &#123; name: &#x27;default&#x27; &#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   这样就创建了一个在组件和 localStorage 之间自动同步的响应式数据。</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><p>在组件中使用时，可以这样引入并使用这个Hook：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> useLocalStorage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useLocalStorage&#x27;</span>;<br><br><span class="hljs-keyword">const</span> &#123; data &#125; = <span class="hljs-title function_">useLocalStorage</span>(<span class="hljs-string">&#x27;myData&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;default&#x27;</span> &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>&lt;RouterView /&gt; </code><a id="RouterView"></a><ul><li><p><code>&lt;RouterView /&gt;</code> 是 Vue Router 的核心组件之一，它的主要作用是作为路由匹配到的组件的渲染出口。是实现前端路由的关键组件，它让我们能够根据 URL 的变化动态渲染不同的组件内容。</p></li><li><p>主要作用</p><ol><li><p><strong>组件渲染容器</strong></p><ul><li>它会根据当前的路由路径（URL）</li><li>自动渲染与该路径匹配的组件</li><li>相当于一个动态组件的占位符</li></ul></li><li><p><strong>动态更新</strong></p><ul><li>当路由发生变化时<code>&lt;RouterView /&gt;</code> 会自动更新渲染的内容,无需手动干预</li></ul></li></ol></li><li><p>使用场景:内容需要根据路由变化而变化</p><ul><li>看他的上一级路由的组件的相应变化位置就是它的出口；<ul><li>比如项目中整个&#x2F;下的第一级路由的出口就在src\App.vue（在&#x2F;xx下随着路由整个页面都变化）</li><li>菜单嵌套路由的出口在src\view\Main.vue（Layout组件）中的el-main中；在&#x2F;path&#x2F;xx下切换路由只相应修改页面布局中的el-main中的内容</li></ul></li></ul><ol><li><p><strong>布局组件中</strong></p><ul><li>作为内容区域的容器</li><li>常见于后台管理系统的布局中</li></ul></li><li><p><strong>嵌套路由</strong></p><ul><li>当需要实现多层级路由时,父路由组件相应位置放置 <code>&lt;RouterView /&gt;</code>，子路由的组件会在这里渲染</li></ul></li><li><p><strong>路由过渡动画</strong></p><ul><li>可以配合 <code>&lt;transition&gt;</code> 使用</li><li>为路由切换添加动画效果</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;transition name=<span class="hljs-string">&quot;fade&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li>在 Vue 2、3 中，<code>@</code> 是 <code>v-on</code> 指令的简写，用于监听 DOM 事件并执行相应的 JavaScript 代码。在 Vue 3 中，使用 <code>:</code> 符号来表示属性绑定是一个重要的语法特性。这种写法源于 Vue 的响应式特性，允许开发者将组件的属性（props）与数据模型进行绑定，从而实现动态更新。<ul><li><p>注意绑定的值必须满足如下规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//可行的情况</span><br> 变量：:value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//message必须是被定义过的变量</span><br> 表达式：:value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//count必须是被定义过的变量</span><br> 字符串字面量：:value=<span class="hljs-string">&quot;&#x27;hello&#x27;&quot;</span>（三个引号）<br> 对象：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span><br> 数组：:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span><br> 布尔值：:disabled=<span class="hljs-string">&quot;false&quot;</span><br> <span class="hljs-comment">//不可行</span><br> :value=<span class="hljs-string">&#x27;hello&#x27;</span><br> :value=<span class="hljs-string">&quot;message&quot;</span><span class="hljs-comment">//但是message没有被定义</span><br> :value=<span class="hljs-string">&quot;count + 1&quot;</span><span class="hljs-comment">//但是count没有被定义</span><br> <span class="hljs-comment">//举例说明:当我插入ep input组件时</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  :prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;显示不了，因为v-bing绑定了<span class="hljs-title class_">Search</span>但它没有被定义<br> <span class="hljs-comment">//其实我想要的search就是一个常量字符串，正确写法如下：去掉:或者使用三引号表示字符串常量</span><br> &lt;el-input v-model=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  placeholder=<span class="hljs-string">&quot;验证码&quot;</span>  prefix-icon=<span class="hljs-string">&#x27;Search&#x27;</span> &gt;<br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;loginForm.vaildCode&quot;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;验证码&quot;</span>  <span class="hljs-attr">:prefix-icon</span>=<span class="hljs-string">&quot;&#x27;Search&#x27;&quot;</span> &gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure></li><li><p>属性绑定语法</p><ul><li><p>基本用法</p><ul><li><strong>属性绑定</strong>：使用 <code>:</code> 符号（相当于 <code>v-bind</code> 的简写）来将数据绑定到组件的属性上。例如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">:some-prop</span>=<span class="hljs-string">&quot;dataValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span>   <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;width:&#x27;230px&#x27;&#125;&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>some-prop</code> 是子组件的一个 prop，而 <code>dataValue</code> 是父组件中的一个数据属性。</p><ul><li><p>动态绑定</p></li><li><p><strong>动态属性</strong>：可以使用表达式动态计算属性值。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;inputValue&quot;</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;isDisabled&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这里，<code>value</code> 和 <code>disabled</code> 属性会根据 <code>inputValue</code> 和 <code>isDisabled</code> 的值动态更新。</p><ul><li><p>使用对象语法</p></li><li><p><strong>对象语法</strong>：可以将多个属性一起绑定到组件上。例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; propA: valueA, propB: valueB &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用这种方式，可以在一个对象中传递多个属性。</p></li></ul></li><li><p>事件处理语法</p><p>  <strong><strong>基本用法</strong></strong></p><ul><li><p><strong>监听事件</strong>：使用 <code>v-on</code> 指令（简写为 <code>@</code>）来监听事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 上述代码中的 <code>handleClick</code> 是一个在组件中定义的方法，当按钮被点击时，该方法将被调用。</p></li><li><p><strong>内联事件处理器</strong>：可以直接在模板中编写 JavaScript 代码，例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;alert(&#x27;Button clicked!&#x27;)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 在这个例子中，点击按钮会弹出一个警告框。</p></li></ul><p>  <strong><strong>事件参数</strong></strong></p><ul><li><p><strong>访问原生事件</strong>：在事件处理方法中，可以访问原生 DOM 事件对象。该对象会自动作为参数传递给方法。例如：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br><span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 输出触发事件的元素</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>**使用 <code>$event</code>**：在内联处理器中，可以通过特殊变量 <code>$event</code> 来访问原生事件。例如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick($event)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>  <strong><strong>修饰符</strong></strong></p><p>  Vue 提供了一些修饰符来控制事件的行为，例如：</p><ul><li><p>**<code>.stop</code>**：阻止事件冒泡。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>.prevent</code>**：阻止默认行为。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;submitForm&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>.self</code>**：仅当事件目标是元素本身时才触发处理器。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>Click me only if clicked on this div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>自定义事件</p></li></ul><p>  Vue 的组件之间可以通过自定义事件进行通信。子组件可以使用 <code>$emit</code> 方法向父组件发送事件。例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;custom-event&#x27;</span>, payload);<br></code></pre></td></tr></table></figure><p>  父组件则可以通过 <code>@custom-event</code> 来监听这个自定义事件：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">custom-event</span>=<span class="hljs-string">&quot;parentMethod&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>变量： Vue3 中变量的使用场景</p><ol><li>使用 <code>&#123;&#123; &#125;&#125;</code> 插值语法</li></ol><ul><li>在模板中显示变量值 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 显示数据 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count + 1 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; isActive ? &#x27;激活&#x27; : &#x27;未激活&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>使用单引号 <code>&#39;&#39;</code></li></ol><ul><li>字符串字面量</li><li>静态值</li><li>变量作各种参数，比如store.commit&#x2F;dispatch等等 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>),<span class="hljs-comment">//提交一个名为increment的变化</span><br><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>使用 <code>:</code> 或 <code>v-bind</code></li></ol><ul><li>动态绑定属性 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 动态绑定 --&gt;<br>&lt;div :class=&quot;&#123;&#x27;click-enabled&#x27;: !flag&#125;&quot;&gt;//代表flag为false时，class为click-enabled，否则没有class<br>&lt;img :src=&quot;imgUrl&quot;&gt;<br>&lt;el-button :type=&quot;buttonType&quot;&gt;<br>&lt;div :style=&quot;&#123; width: width + &#x27;px&#x27; &#125;&quot;&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>使用 <code>@</code> 或 <code>v-on</code></li></ol><ul><li>事件绑定 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 事件绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;handleInput&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>使用 <code>v-model</code></li></ol><ul><li>双向数据绑定 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 双向绑定 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li>使用 <code>v-if/v-show</code></li></ol><ul><li><p>条件渲染</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>&lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">      这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>总结：</p><ul><li><code>&#123;&#123; &#125;&#125;</code>: 显示变量值</li><li><code>&#39;&#39;</code>: 静态值</li><li><code>:</code>: 动态属性绑定</li><li><code>@</code>: 事件绑定</li><li><code>v-model</code>: 双向绑定</li><li><code>v-if/v-show</code>: 条件渲染</li></ul></li></ul></li></ul></li></ul><h4 id="nextTick-object-assign"><a href="#nextTick-object-assign" class="headerlink" title="nextTick&amp;object.assign "></a><a id="nextTick&object.assign">nextTick&amp;object.assign </a></h4><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><code>nextTick</code></h4><p><code>nextTick</code> 是 <strong>Vue.js</strong> 提供的一个方法，用于在下一次 DOM 更新循环结束之后执行延迟回调。在修改数据后立即使用 <code>nextTick</code>，可以在回调中获取更新后的 DOM。</p><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    count.<span class="hljs-property">value</span>++;<br>    <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 在这里可以访问更新后的 DOM</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM 已更新&#x27;</span>);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123; count, increment &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>当你在修改响应式数据后，需要在 DOM 更新完成后执行某些操作时，使用 <code>nextTick</code>。</li><li>常见场景包括获取更新后的 DOM 元素的尺寸或状态。</li></ul><hr><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h4><p><code>Object.assign</code> 是 <strong>JavaScript</strong> 中的一个静态方法，用于将一个或多个源对象的可枚举属性复制到目标对象中。返回目标对象。也称为合并对象。</p><p><strong>语法：</strong></p><ol><li>如果target存在source中的属性就会被重写赋值，如果不存在就会创造这个属性然后赋值过去；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, ...sources);<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：目标对象。</li><li><code>sources</code>：源对象。</li></ul><p><strong>用法示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-comment">//或者&#123;a:1&#125;,输出结果一样</span><br><span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source1, source2);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target); <span class="hljs-comment">// 输出：&#123; a: 1, b: 2, c: 3 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p><code>Object.assign</code> 常用于对象的合并或浅拷贝。</p></li><li><p>如果目标对象与源对象有相同的属性，后面的属性会覆盖前面的属性。</p></li><li><p>参考</p><ul><li><a href="https://www.bilibili.com/video/BV1nV411Q7RX/?vd_source=a02025349c3063d9c9143f9bd7489fdf">【2024最新版】3小时学会Vue3，小白零基础视频教程，web前端快速入门实战课程_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1oj411D7jk/?vd_source=a02025349c3063d9c9143f9bd7489fdf">30分钟学会Vue之核心语法 趁着暑假掌握一门技能 大学生前端实习毕业设计必备技能_哔哩哔哩_bilibili</a></li><li><a href="https://juejin.cn/post/7225267685763907621#heading-1">十分钟，带你了解 Vue3 的新写法最近因为项目需要，不得不学习一下 Vue3。于是花了 4 个小时，把 Vue3 过了 - 掘金</a></li><li><a href="https://juejin.cn/post/7122760155707473956?searchId=20241108152858B987C89A8A08662B99ED">超极速的Vue3上手指北笔者之前是Vue2+React开发者，因项目需要直接上手Vue3，所以快速学习一下，中间会对比一 - 掘金</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vueVite</title>
    <link href="/2024/10/16/vueVite/"/>
    <url>/2024/10/16/vueVite/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述使用Vite搭建Vue3项目的结构及其作用</p></blockquote><span id="more"></span><h2 id="项目结构及其作用"><a href="#项目结构及其作用" class="headerlink" title="项目结构及其作用"></a>项目结构及其作用</h2><ol><li>根目录：<ol><li>package.json：这个文件包含了项目的依赖项、脚本等信息，是整个项目的元数据。</li><li>vue.config.js：这是用于配置 Vite 的主要文件。在这里，你可以定义环境变量、设置插件、调整打包选项等。这是一个非常重要的配置文件，它会影响到你的开发体验和生产部署过程</li></ol></li><li>public：包含了一些静态资源，比如图标、favicon.ico、robots.txt 等。这些文件会被直接复制到构建目录中，不会经过 Vite 的处理。<ol><li>在组件中导入public中的静态资源时不需要完整的路径，直接&#x2F;文件名即可比如<code>import qrImg from &#39;/qr.png&#39;</code>;导入public中的二维码图片</li></ol></li><li>src 文件夹：在 Vite 中最核心的一个文件夹，因为它存放着所有的源代码： index.htm-main.js-index.js、App.vue-其他view、components组件-静态资源（图片、cdn等等）<ol><li>assets 文件夹：用来存储静态资源，如图片、样式表等，这些资源通常不会经常变化，可以直接复制到服务器上</li><li>components 文件夹：存放的是你写好的复用组件，每个子文件夹代表一类相关的组件，比如说有一个 base 或者 app 组件，然后再根据具体功能划分出不同的模块（例如：button、table 等）。在vue项目中可以将其中的文件称为vue文件：封装和组织组件的模板、逻辑和样式，使得组件的开发和管理更加高效和模块化（往往在components下创造组件，在view下的vue文件中引用组件），提高了代码的可维护性和复用性：其基础结构如下：<ol><li><p><code>&lt;template&gt;&lt;/template&gt;</code>:内含html代码，用于组成页面结构</p><ol><li>浏览器中不会存在<code>&lt;template&gt;</code>标签的原因是，Vue会在编译过程中将<code>&lt;template&gt;</code>中的内容转换为JavaScript渲染函数。在这个过程中，Vue会解析<code>&lt;template&gt;</code>的内容并生成虚拟DOM，而这个虚拟DOM最终会被渲染到实际的DOM中。</li><li>编译过程：<ol><li>解析模板：Vue使用vue-template-compiler库将<code>&lt;template&gt;</code>块中的HTML字符串解析为抽象语法树（AST），这表示了模板的结构。</li><li>生成渲染函数：AST会被转换为JavaScript代码，这些代码负责创建虚拟DOM节点。每当组件需要渲染时，Vue会调用这些渲染函数，而不是直接使用<code>&lt;template&gt;</code>中的内容。</li><li>更新DOM：当数据变化时，Vue会根据虚拟DOM的变化来更新实际的DOM。</li></ol></li></ol></li><li><p>调用组件</p><ol><li>引入组件有两种方式<ol><li>直接在要使用的页面中导入</li><li>在main.js中导入，然后app.component（”组件名称”,组件）注入全局这样就可以在全局使用了</li></ol></li><li>在组件中调用的组件名称也有两种方式<br>在 Vue.js 中，当您在 <code>main.js</code> 中全局注册组件时，例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PanelHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/PanelHead.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;PanelHead&#x27;</span>, <span class="hljs-title class_">PanelHead</span>);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><p>尽管您注册的组件名称是 <code>&#39;PanelHead&#39;</code>，但在模板中可以使用 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code> 或<code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code>的形式来引用，</p><p><strong>原因如下：</strong></p><ol start="3"><li><p><strong>组件名的大小写不敏感解析：</strong></p><p>Vue 在解析模板时，会将自定义组件标签名中的连字符形式（kebab-case）和大驼峰形式（PascalCase）都识别为同一个组件。例如：</p><ul><li><code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code></li><li><code>&lt;panel-head&gt;&lt;/panel-head&gt;</code></li></ul><p>上述两种写法都会被解析为注册的 <code>&#39;PanelHead&#39;</code> 组件。</p></li><li><p><strong>组件名的规范化：</strong></p><p>根据 Vue 的组件名解析规则，注册时的组件名会被标准化处理，模板中的标签名也会被转换为相应的格式，以进行匹配。</p><ul><li>注册组件时使用 PascalCase（大驼峰命名）的名称。</li><li>在模板中，可以使用 PascalCase 或 kebab-case（短横线命名）形式的组件标签。</li></ul></li><li><p><strong>HTML 中的大小写不敏感性：</strong></p><ul><li>在浏览器解析 HTML 时，标签名是大小写不敏感的。</li><li>为了遵循 HTML 规范，Vue 推荐在模板中使用 kebab-case 的组件名。</li></ul></li></ol><p><strong>总结：</strong></p><ul><li><strong>注册组件：</strong> 使用 PascalCase 命名，例如 <code>&#39;PanelHead&#39;</code>。</li><li><strong>在模板中引用：</strong> 可以使用 <code>&lt;PanelHead&gt;&lt;/PanelHead&gt;</code> 或 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，Vue 都能够正确解析。</li><li><strong>推荐使用：</strong> 在模板中使用 kebab-case 形式，即 <code>&lt;panel-head&gt;&lt;/panel-head&gt;</code>，以符合 HTML 规范和提高可读性。</li></ul></li><li><p><a id="vue3核心"></a>组合式API与选项式API的对比（本项目中使用组合式API）</p><ol><li><p>组合式API：Vue3提供了丰富的组合式API，帮助开发者管理组件的行为，核心功能如下：</p><ol><li><code>&lt;script setup&gt;</code> 是在单文件组件中使用组合式 API 的编译时语法糖。主要特点：<ol><li><p>顶层变量&#x2F;函数自动暴露给模板：意思是说<code>&lt;script setup&gt;</code> 中定义的变量和函数会自动暴露给当前组件的模板使用;这种暴露仅限于当前组件内部的 template 部分;</p><ol><li>无需 return 和 export 语句</li><li>引入的组件自动注册<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><br>   &lt;script setup&gt;<br>   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br>   <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span><br><br>   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++<br>   &lt;/script&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   <span class="hljs-string">``</span><span class="hljs-string">`              </span><br><span class="hljs-string">2. 组件实例的访问:父组件通过 ref 访问子组件时，访问的是子组件的实例;出于安全考虑，Vue 3 默认关闭了组件实例的属性访问需要通过 defineExpose 明确声明哪些属性/方法可以被父组件访问;</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br>      &lt;!-- 子组件 <span class="hljs-title class_">Child</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)          <span class="hljs-comment">// ✅ 自动暴露给当前模板使用</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">defineExpose</span>(&#123; count &#125;) <span class="hljs-comment">// ✅ 显式暴露给父组件访问</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;&#123; count &#125;&#125;  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 count --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-comment">&lt;!-- ✅ 可以直接访问 increment --&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br>   &lt;!-- 父组件 <span class="hljs-title class_">Parent</span>.<span class="hljs-property">vue</span> --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-comment">// 访问子组件实例的属性</span></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childRef.<span class="hljs-property">value</span>.<span class="hljs-property">count</span>)        <span class="hljs-comment">// ✅ 可以访问（因为被 defineExpose 暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   childRef.<span class="hljs-property">value</span>.<span class="hljs-property">increment</span>          <span class="hljs-comment">// ❌ 不能访问（未被暴露）</span></span></span><br><span class="language-javascript"><span class="language-xml">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>这种设计的目的是：</p><pre><code class="hljs">     提高代码的可维护性     增强组件的封装性     避免父组件随意访问和修改子组件的内部状态</code></pre></li></ol></li><li>响应式系统：数据变更自动触发视图更新 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// ref 基本类型响应式</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>count.<span class="hljs-property">value</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br><br><span class="hljs-comment">// reactive 对象响应式</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;)<br>state.<span class="hljs-property">age</span>++ <span class="hljs-comment">// 修改值会触发视图更新</span><br></code></pre></td></tr></table></figure></li><li><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html">生命周期钩子</a>(选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子。组合式 API：需要手动导入所需的响应式函数和生命周期钩子，从而提供更灵活和模块化的代码结构，他们俩周期钩子也有差别；比如组合式没有beforecreate，把setup当created用，其它就当改了个名)</li></ol><p><img src="/2024/10/16/vueVite/note_vue/1731056688357.png" alt="1731056688357"></p><p><img src="/2024/10/16/vueVite/note_vue/image.png" alt="alt text"><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span></span><br><span class="language-xml">      增加 1</span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">import</span> &#123; ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">onClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染之前调用的时beforeMount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件渲染完成调用的时mounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之前调用的时beforeUpdate函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件更新之后调用的时updated函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之前调用的时beforeUnmount函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;组件卸载之后调用的时unmounted函数&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><br> 4. 响应式监听<br>    1. watch的两个参数<br>       1. watch 的第一个参数需要是一个响应式数据（可以是多个），或者是一个返回值的函数。（比如返回一个对象obj的属性() &#x3D;&gt; obj.age）<br>       2. 箭头函数(newValue,oldValue) &#x3D;&gt; {}<br>          1. oldValue：监听的值在变化之前的值<br>          2. newValue：监听的值在变化之后的值<br>    2. watch的触发条件<br>       1. 要让 watch 监听器生效，需要在运行时修改被监听的响应式数据。直接在代码中修改变量的初始值（即在组件加载前设置的值）并不会触发 watch 的回调函数。watch 的作用是监听响应式数据的变化，当数据在运行时发生改变时（例如用户点击按钮触发事件函数），watch 才会检测到这种变化并执行回调函数。<br>    3.  watch的两个属性：<br>       1. immediate（获取初始化）：当设置为 true 时，监听器会在绑定后立即触发回调函数。这意味着在初始化阶段，即使被监听的值没有发生变化，回调函数也会被调用一次。作用如下<br>          1. 在组件加载时，需要根据初始值执行一些操作，例如根据初始参数请求数据。而不必等待被监听的值发生变化。<br>          2. 在组件创建时，需要将某些响应式数据同步到其他地方<br>          3. 在初始化组件的时候oldValue是undefined，newValue是当前值(初始值)<br>       2. deep：true<br>          1.  Vue3 的 reactive 会自动对对象进行深层代理（Proxy），所以：当直接修改 监听对象的内置嵌套对象时，两个监听器都会触发<br>          2.  deep: true 主要用于以下场景：<br>              1.  当你使用 reactive 对象作为 watch 的源，且需要在对象被整个替换时触发监听<br>              2.  当监听的是一个返回非响应式对象的 getter 函数时<br>            <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> deep = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,<br>   <span class="hljs-attr">info</span>: &#123;<br>      <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>      <span class="hljs-attr">contacts</span>: &#123;<br>         <span class="hljs-attr">phone</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>         <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;test@example.com&#x27;</span><br>      &#125;<br>&#125;<br>&#125;)<br><span class="hljs-title function_">watch</span>(deep, <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj changed&#x27;</span>)<br>&#125;)<span class="hljs-comment">//vue3自带不需要deep</span><br><br><span class="hljs-comment">// 如果是这种情况，则需要 deep: true：当改变的是 deep.info时，returnNonReactiveObj会被整个替换</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">returnNonReactiveObj</span> = (<span class="hljs-params"></span>) =&gt; (&#123;<br><span class="hljs-attr">info</span>: deep.<span class="hljs-property">info</span><br>&#125;)<br><span class="hljs-title function_">watch</span>(returnNonReactiveObj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;non-reactive obj changed:&#x27;</span>, newValue)<br>&#125;, &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;)<br><br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br> <span class="hljs-keyword">import</span> &#123; ref, reactive, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br> <span class="hljs-keyword">const</span> counter1 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-keyword">const</span> counter2 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br> <span class="hljs-comment">// 监听多个</span><br> <span class="hljs-title function_">watch</span>([counter1, counter2], <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter1 value is: &#x27;</span> + counter1.<span class="hljs-property">value</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new counter2 value is: &#x27;</span> + counter2.<span class="hljs-property">value</span>)<br> &#125;)<br><br> <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JJ&#x27;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br> &#125;)<br> <span class="hljs-comment">//监听初始化值</span><br> <span class="hljs-title function_">watch</span>(obj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br> <span class="hljs-comment">// watch监听单个属性</span><br> <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">name</span>, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The new obj value is: &#x27;</span> + obj.<span class="hljs-property">value</span>)<br> &#125;, &#123;<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br> &#125;)<br><br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>计算属性:更加灵活，可以在定义响应式变量时声明;<code>computed</code> 可以用于任何类型的数据处理，不仅限于数值计算。</p><ol><li>核心优势<ul><li>可处理任何数据类型</li><li>自动跟踪依赖关系</li><li>具有缓存机制</li><li>提高代码可读性和维护性</li></ul></li><li>以下是一些常见用例<ol><li><p><strong>字符串处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串转换</span><br><span class="hljs-keyword">const</span> upperCase = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> name.<span class="hljs-property">value</span>.<span class="hljs-title function_">toUpperCase</span>())<br><span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;firstName.value&#125;</span> <span class="hljs-subst">$&#123;lastName.value&#125;</span>`</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>数组处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数组过滤</span><br><span class="hljs-keyword">const</span> activeTodos = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> todos.<span class="hljs-property">value</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>))<br><span class="hljs-comment">// 数组排序</span><br><span class="hljs-keyword">const</span> sortedList = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> items.<span class="hljs-property">value</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>))<br></code></pre></td></tr></table></figure></li><li><p><strong>对象处理</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象转换</span><br><span class="hljs-keyword">const</span> userInfo = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;user.value.firstName&#125;</span> <span class="hljs-subst">$&#123;user.value.lastName&#125;</span>`</span>,<br>  <span class="hljs-attr">age</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span>,<br>  <span class="hljs-attr">isAdult</span>: user.<span class="hljs-property">value</span>.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span><br>&#125;))<br></code></pre></td></tr></table></figure></li><li><p><strong>复杂逻辑</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 购物车计算</span><br><span class="hljs-keyword">const</span> cartTotal = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> cart.<span class="hljs-property">value</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> total + (item.<span class="hljs-property">price</span> * item.<span class="hljs-property">quantity</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>字符倒序</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;this is a value&#x27;</span>)<br><br><span class="hljs-comment">// 注意这里</span><br><span class="hljs-keyword">const</span> reversedValue = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// 使用 ref 需要 .value</span><br><span class="hljs-keyword">return</span> value.<span class="hljs-property">value</span><br>   .<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>条件渲染和列表渲染</p><ol><li><p>v-for的参数</p><ol><li>如下代码中的v-for&#x3D;”(item, index) in props.menuData” 中：这个 index 是 Vue 提供的数组索引值，是 v-for 指令内置提供的第二个参数表示当前遍历项在数组中的索引值(从0开始)是可选参数,如果不需要索引值，可以省略<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">!-- 假设 props.<span class="hljs-property">menuData</span> 是这样的数组 --&gt;<br>  [<br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单1&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 0</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单2&#x27;</span> &#125; &#125;,  <span class="hljs-comment">// index = 1</span><br>     &#123; <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;菜单3&#x27;</span> &#125; &#125;   <span class="hljs-comment">// index = 2</span><br>  ]                       <br>   v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, index) in array&quot;</span><br>  <span class="hljs-comment">// item: 当前项</span><br>  <span class="hljs-comment">// index: 当前项的索引</span><br>                       <br></code></pre></td></tr></table></figure></li></ol></li><li><p>v-if 中 index 和 key</p><ol><li><p>index&#x3D;”<code>$&#123;index&#125;-$&#123;item.meta.id&#125;</code>“</p><ol><li>这是 Element Plus 菜单组件特有的属性</li><li>用于标识每个菜单项的唯一路径</li><li>帮助菜单组件追踪当前选中的菜单项</li><li>通常用于控制菜单的激活状态</li></ol></li><li><p><code>key</code> 属性:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">:key=&quot;`$&#123;index&#125;-$&#123;item.meta.id&#125;`&quot;<br></code></pre></td></tr></table></figure></li></ol><ul><li>这是 Vue 框架要求的特殊属性</li><li>用于给 v-for 循环中的每个元素一个唯一标识</li><li>帮助 Vue 在虚拟 DOM 更新时准确识别节点</li><li>提高渲染性能和准确性</li></ul><p>  它们的主要区别：</p><ul><li><code>index</code> 是功能性的唯一标识，用于菜单组件的功能实现</li><li><code>key</code> 是结构性的唯一标识，用于 Vue 框架的 DOM 更新优化</li></ul></li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 项目中的菜单组件 --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in props.menuData&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 无子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.children || item.children.length == 0&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:indx</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 结合路由信息以及动态元素实现图标渲染 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 菜单标题 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 有子菜单：分两个部分：标题+递归调用子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-sub-menu</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">v-else</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 标题区域的内容： #title是 Element Plus 的 el-sub-menu 组件预定义的插槽名称 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.meta.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 递归调用此组件实现子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- index：1  1-2  1-3 实现每个菜单项的唯一标识 --&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">SubMenu</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;`$&#123;props.index&#125;-$&#123;item.meta.id&#125;`&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">:menuData</span>=<span class="hljs-string">&quot;item.children&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-sub-menu</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="hljs-string">``</span><span class="hljs-string">`                   </span><br><span class="hljs-string"></span><br><span class="hljs-string"> `</span><span class="hljs-string">``</span>js<br>&lt;template&gt;<br>   &lt;!-- 条件渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>显示内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>其他内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>   &lt;!-- 列表渲染 --&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="language-xml">         &#123;&#123; item.name &#125;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目1&#x27;</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">   &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;项目2&#x27;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   ])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>v-if和v-show的区别</p><ul><li><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue.js 中用于条件渲染的指令，但它们有不同的作用和使用场景。</p></li><li><p>总结：</p><ul><li>使用 <code>v-if</code> 时，元素在条件为假时不会存在于 DOM 中。</li><li>使用 <code>v-show</code> 时，元素始终存在于 DOM 中，只是通过 CSS 控制显示或隐藏。</li></ul></li><li><p><code>v-if</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来有条件地渲染元素。</li><li><strong>特点</strong>：元素及其绑定的事件和子组件在条件为假时不会被渲染或销毁。</li><li><strong>性能</strong>：初始渲染时有更高的开销，因为需要添加或删除 DOM 元素。</li></ul></li><li><p><code>v-show</code></p><ul><li><strong>作用</strong>：根据表达式的真假值来切换元素的显示状态。</li><li><strong>特点</strong>：元素始终会被渲染并保留在 DOM 中，只是通过 CSS 的 <code>display</code> 属性来控制显示或隐藏。</li><li><strong>性能</strong>：初始渲染开销较小，但频繁切换显示状态时性能更好。</li></ul></li><li><p>使用场景</p><ul><li>**<code>v-if</code>**：适用于在运行时条件很少改变的场景，因为它会在条件变化时进行 DOM 的添加和删除。</li><li>**<code>v-show</code>**：适用于需要频繁切换显示状态的场景，因为它只会切换 <code>display</code> 属性。</li></ul></li><li><p>示例</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;!-- v-<span class="hljs-keyword">if</span> 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isShow 的值来添加或删除</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br>  &lt;!-- v-show 示例 --&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="language-xml">    这个元素会根据 isVisible 的值来显示或隐藏</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isShow</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">isVisible</span>: <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>事件处理与双向绑定</p><ol><li><code>v-model</code> 的用途:获取表单中的输入数据赋值给变量；<code>v-model</code> 是 Vue.js 中用于创建<strong>双向数据绑定</strong>的指令，主要用于表单输入元素与应用状态之间的同步。主要功能如下<ol><li><p><strong>双向绑定</strong>：</p><ul><li>自动将用户输入的值同步到组件的状态（如 <code>data</code> 或 <code>ref</code>）。</li><li>同时，当状态发生变化时，更新输入元素的显示值。</li></ul></li><li><p><strong>简化代码</strong>：</p><ul><li>替代手动编写 <code>:value</code> 和 <code>@input</code> 事件处理器，实现更简洁的双向绑定。</li></ul></li></ol></li><li>常见用法</li></ol><ul><li><p><strong>文本输入</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>复选框</strong>：</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;input type=&quot;checkbox&quot; v-model=&quot;变量名&quot; /&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>选择框</strong>：</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">      &lt;select v-model=&quot;变量名&quot;&gt;<br>         &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt;<br>         &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt;<br>      &lt;/select&gt;<br><br> ```js<br>&lt;template&gt;<br>      &lt;input v-model=&quot;username&quot; /&gt;<br>   &lt;button @click=&quot;handleClick&quot;&gt;点击&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>const username = ref(&#x27;&#x27;)<br>const handleClick = () =&gt; &#123;<br>console.log(username.value)<br>&#125;<br>&lt;/script&gt;<br>/*<br>   - **`v-model=&quot;username&quot;`**：<br>   - 将输入框的值与 `username` 变量绑定。<br>   - 用户在输入框中输入内容时，`username` 会自动更新。<br>   - 如果在代码中修改 `username` 的值，输入框的显示内容也会相应更新。<br><br>*/<br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>对比一下选项式API：在 Vue 2 和 Vue 3 的选项式 API 中的<code>&lt;script&gt;</code>中需要 return 和 export 的原因：(这些在组合式API中都不用考虑)</p><ol><li>export default 的目的：<ol><li>将组件配置对象导出，使其可以被其他组件引入使用</li><li>这是 ES6 模块系统的要求</li><li>Vue 通过这个导出的对象来创建组件实例</li></ol></li><li>return 的目的：<ol><li>在 data() 函数中返回数据对象，使其成为响应式数据</li><li>每个组件实例都需要独立的数据副本，避免数据共享<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-comment">// 选项式 API</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyComponent&#x27;</span>,<br><br><span class="hljs-comment">// data 必须是函数并返回对象，确保每个组件实例有独立的数据副本</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">methods</span>: &#123;<br>   <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>   &#125;<br>&#125;,<br><br><span class="hljs-attr">computed</span>: &#123;<br>   <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>   &#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br><span class="hljs-comment">// ❌ 错误示例</span><br><span class="hljs-attr">data</span>: &#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//组合式API中：组合式API基础语法</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 方式1：使用 ref() 定义基础类型</span><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><br><span class="hljs-comment">// 方式2：使用 reactive() 定义对象类型</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br><span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br><span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 使用时：(在template之外)</span><br><span class="hljs-comment">// ref 需要 .value </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">value</span>)<br><br><span class="hljs-comment">// reactive 直接使用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">message</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 在模板中使用 ref 不需要 .value --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- reactive 对象的使用 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; state.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>选项式与组合式API的区别（除了上述之外）： </p><ol><li><p>选项式 API：Vue 通过组件选项自动处理逻辑，无需手动导入响应式函数和生命周期钩子等等。</p></li><li><p>组合式 API：需要手动导入所需的响应式函数和生命周期钩子等等，从而提供更灵活和模块化的代码结构。（除了编译器宏比如defineProps，编译器宏：由 Vue 的编译器在编译时处理的特殊语法糖。它并非普通的 JavaScript 函数，因此不需要通过 import 从 ‘vue’ 中导入。自动可用：在<code>&lt;script setup&gt;</code>块内，defineProps 会被自动识别并处理。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//拿子传父举例</span><br><span class="hljs-comment">// 选项式 API</span><br>&lt;template&gt;<br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">   <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-event&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);<span class="hljs-comment">//自动处理this.$emit</span></span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">// 组合式 API</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">message-event</span>=<span class="hljs-string">&quot;handleMessageEvent&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; messageFromChild &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 必须遵循js的规范，任何变量使用前必须申明</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> messageFromChild = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleMessageEvent</span> = (<span class="hljs-params">message</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">messageFromChild.<span class="hljs-property">value</span> = message;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>选项式 API 和 组合式 API 的主要区别补充：</p><ol><li><p><strong>组织代码的方式</strong></p><ul><li><strong>选项式 API</strong>：通过选项（如 <code>data</code>、<code>methods</code>、<code>computed</code> 等）组织代码，适合简单组件。</li><li><strong>组合式 API</strong>：通过组合函数（如 <code>setup</code>）组织代码，更适合复杂逻辑和代码复用。</li></ul></li><li><p><strong>逻辑复用</strong></p><ul><li><strong>选项式 API</strong>：依赖混入（mixins）和高阶组件（HOCs），可能导致命名冲突和难以追踪。</li><li><strong>组合式 API</strong>：使用组合函数（composables）实现逻辑复用，结构更清晰，避免命名冲突。</li></ul></li><li><p><strong>类型推导和 TypeScript 支持</strong></p><ul><li><strong>选项式 API</strong>：TypeScript 支持有限，类型推导较复杂。</li><li><strong>组合式 API</strong>：与 TypeScript 集成更好，提供更精准的类型推导。</li></ul></li><li><p><strong>代码组织与可维护性</strong></p><ul><li><strong>选项式 API</strong>：按选项分割，功能分散，难以管理大型组件。</li><li><strong>组合式 API</strong>：按功能分割，相关逻辑集中，提升可维护性。</li></ul></li><li><p><strong>生命周期钩子</strong></p><ul><li><strong>选项式 API</strong>：通过选项直接定义生命周期钩子（如 <code>mounted</code>、<code>created</code>）。</li><li><strong>组合式 API</strong>：在 <code>setup</code> 内使用函数（如 <code>onMounted</code>、<code>onCreated</code>）定义生命周期钩子。</li></ul></li><li><p><strong>响应式系统</strong></p><ul><li><strong>选项式 API</strong>：使用 <code>data</code> 对象进行响应式管理，自动处理响应式属性。</li><li><strong>组合式 API</strong>：使用 <code>ref</code>、<code>reactive</code> 等函数显式创建响应式数据，更灵活。</li></ul></li><li><p><strong>学习曲线</strong></p></li></ol><ul><li><strong>选项式 API</strong>：更直观，适合 Vue 新手。</li><li><strong>组合式 API</strong>：需要理解响应式原理和组合函数，学习曲线稍陡。</li></ul><ol start="8"><li><strong>调试和测试</strong></li></ol><ul><li><strong>选项式 API</strong>：由于逻辑分散，单独测试某一功能较困难。</li><li><strong>组合式 API</strong>：逻辑集中，单元测试和调试更容易。</li></ul></li><li><p>最后总结一下两者的异同：</p><ol><li>同：无论是选项式还是组合式API，都得遵循js的规范，比如任何变量使用前必须申明，否则会报错；调用其他组件时都需要导入相应文件；</li><li>异：<ol><li>选项式需要export default导出组件对象，并在其中使用components申明导入的组件、data（）函数return 返回数据变量&#x2F;对象（定义申明）以实现相应，而组合式直接ref&#x2F;reactive即可；</li><li>组合式中需要导入响应式函数和生命周期钩子等等，而选项式不需要；（除了编译器宏比如defineProps之外）</li></ol></li><li>在这个项目中我主要使用组合式，往后就不管选项式了</li></ol></li></ol></li></ol></li><li><p><code>&lt;style scoped&gt;&lt;/style&gt;</code>：用于定义组件的样式。开发者可以使用CSS或预处理器（如Sass、Less、Tailwind CSS，问perplexity）编写样式：</p><ol><li><code>&lt;style&gt;</code> 标签内编写的 CSS 样式默认是全局作用域，会影响到其他路由页面。要使样式仅作用于当前组件，需要在 <code>&lt;style&gt;</code> 标签上添加 scoped 属性：   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style lang=<span class="hljs-string">&quot;less&quot;</span> scoped&gt;<br> <span class="hljs-comment">/* 在这里添加样式 */</span><br> .<span class="hljs-property">logo</span>-lg &#123;<br> font-<span class="hljs-attr">size</span>: 20px;<br> text-<span class="hljs-attr">align</span>: center;<br> <span class="hljs-attr">height</span>: 50px;<br> line-<span class="hljs-attr">height</span>: 50px;<br> <span class="hljs-attr">color</span>: style<br> &#125;<br> &lt;/style&gt;<br><br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li>根组件App.vue:包含了整个应用程序的布局结构<ol><li>页面渲染的入口点。所有其他组件都会嵌套在App.vue中</li><li>通常会与Vue Router的组件<code>&lt;RouterView /&gt;</code>结合使用，处理页面之间的导航和路由，实现不同页面的切换和展示；如果使用了路由，但是App.vue中没有<code>&lt;RouterView /&gt;</code>，则路由无法正常工作;经典内容如下：   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><br>&lt;template&gt;<br><br>   <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure></li></ol></li><li>Vue应用的入口文件main.js：初始化Vue实例并将其挂载到DOM中，导出了整个应用程序所需的全局状态和方法。一般来说，在这里初始化一些全局变量或函数，以便于后续操作，其基础操作如下：<ol><li>导入router实例<code>import router from &#39;./router&#39;</code>；(访问router&#x2F;index.js文件)</li><li>创建app实例<code>const app = createApp(App)</code>，这里的App是根组件App.vue;</li><li>挂载router实例<code>app.use(router)</code></li><li>挂载app实例到指定ID的div元素上：<code>app.mount(&#39;#app&#39;)</code><ol><li>这里的#app是index.html中的一个div元素的id，Vue会将app实例挂载到这个元素上，从而渲染整个应用</li><li>你也可以将app实例挂载到其他元素上,但要在index.html中添加相应的元素以及id属性</li><li>默认使用#app的原因<ol><li>约定俗成：使用id&#x3D;”app”是Vue文档和许多示例中的常见做法，主要是为了简化学习和开发过程。开发者可以快速识别出这是Vue应用的挂载点。</li><li>避免冲突：在大型应用中，使用特定的id可以帮助避免与其他JavaScript库或框架的冲突，确保Vue应用的DOM元素明确且独特。</li></ol></li></ol></li></ol></li><li>router文件夹：<ol><li>功能：路由管理<ol><li>导入组件，定义路由规则,控制页面间的跳转逻辑</li><li>定义 URL 路径与组件的对应关系</li><li>管理路由参数传递</li><li>router&#x2F;index.js负责初始化和配置Vue应用; 主要功能如下<ol><li>定义路由routes</li><li>创造并导出router实例</li></ol></li><li>注意：不能重复导入同一个组件，否则会导致组件重复注册，从而引发错误</li></ol></li><li>典型结构<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router/index.js</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span><br><span class="hljs-keyword">const</span> routes = [<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Home.vue&#x27;</span>)<br>&#125;,<br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>   <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/About.vue&#x27;</span>)<br>&#125;<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>routes<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br><br></code></pre></td></tr></table></figure></li></ol></li><li>View文件夹：<ol><li>视图功能:负责页面渲染<ol><li>存放页面级别的组件</li><li>对应具体的路由页面</li><li>组合和管理其他小组件</li></ol></li><li>与components的区别<ol><li>views：负责页面级别的组件，对应具体路由逻辑的页面（也就是说路由怎么设置的，view下就要有相应的页面组件），组合和管理其他小组件（可嵌入components中或者view中子组件）</li><li>components：负责通用的小组件，可以在多个页面中复用，不涉及具体的路由逻辑</li></ol></li><li>举例 Main.vue<ol><li>作用：主要负责页面的整体布局和结构，包含了整个页面的主要内容</li><li>典型结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- views/<span class="hljs-title class_">Main</span>.<span class="hljs-property">vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">Aside</span> /&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><pre><code class="hljs"> 1.  services ：存放业务逻辑层面的代码，包括多个组件共用的服务端接口调用函数等 2.  utils：存放通用工具函数，不同的地方不重复书写相同的代码片段</code></pre><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ul><li>当启动应用程序时，Vite 会按照如下顺序加载和处理这些文件：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">读取 package<span class="hljs-selector-class">.json</span>：获取项目依赖项和脚本信息。<br>解析 vue<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>：配置Vite的行为，包括环境变量管理、插件注册等。<br>载入 <span class="hljs-attribute">src</span>/App<span class="hljs-selector-class">.vue</span>：作为应用程序的根组件，负责渲染页面结构。<br>执行 <span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>：初始化应用程序，全局状态和方法的创建。<br>递归查找并加载各个组件：从根组件开始，逐级向下寻找并注入子组件，形成完整的DOM树结构。<br>优化与缓存处理：利用Vite提供的内置优化机制，对JS/CSS进行压缩混淆，以及对第三方库进行tree-shaking以减少无效代码。<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vueWatch</title>
    <link href="/2024/10/15/vueWatch&amp;deep/"/>
    <url>/2024/10/15/vueWatch&amp;deep/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简单讲讲vue3的watch函数和:deep伪类选择器</p></blockquote><span id="more"></span><h2 id="watch-函数说明"><a href="#watch-函数说明" class="headerlink" title="watch 函数说明"></a>watch 函数说明</h2><ol><li><code>watch</code> 是 Vue 3 的组合式 API 之一，用于监听响应式数据的变化</li><li>它接收两个主要参数：<ul><li>第一个参数：要监听的数据源（这里是一个返回 <code>route.params.id</code> 的箭头函数）</li><li>第二个参数：当数据变化时触发的回调函数</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>,  <span class="hljs-comment">// 监听路由参数中的id变化</span><br>  <span class="hljs-function">(<span class="hljs-params">newId</span>) =&gt;</span> &#123;           <span class="hljs-comment">// newId 是变化后的新值</span><br>    <span class="hljs-keyword">if</span> (newId) &#123;<br>      <span class="hljs-title function_">fetchData</span>()        <span class="hljs-comment">// 当id变化时重新获取数据</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;重新获取推荐视频&quot;</span>)<br>    &#125;<br>  &#125;<br>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">axios</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/videoDetail&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> &#125;<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;<br>    videoInfo.<span class="hljs-property">value</span> = data.<span class="hljs-property">result</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;视频详情数据&#x27;</span>, data.<span class="hljs-property">result</span>)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个典型的用例，常用于需要根据路由参数重新获取数据的场景。</p><ul><li><code>newId</code> 在这里指的是路由参数中的 <code>id</code> 的新值</li><li>这段代码的作用是监听视频的 ID 变化（通常在 URL 中），当用户切换到不同的视频时：<ol><li>路由参数 <code>id</code> 发生变化</li><li>watch 检测到变化，触发回调函数</li><li>执行 <code>fetchData()</code> 获取新视频的推荐内容</li></ol></li></ul><h3 id="key动态监测变化，自动重新渲染组件"><a href="#key动态监测变化，自动重新渲染组件" class="headerlink" title="key动态监测变化，自动重新渲染组件"></a>key动态监测变化，自动重新渲染组件</h3><ul><li>接着上面的例子，当检测到路由id变化后通过fetchData重新获数据后，还需要通过组件标签中的key属性实现组件自动重新渲染；如下例子所示，路由变化后嵌入的视频会自动更新；<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;video-play&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span></span><br><span class="hljs-tag">     <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;videoInfo.videoSrc&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;videoInfo.videoSrc&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="deep-选择器"><a href="#deep-选择器" class="headerlink" title=":deep() 选择器"></a>:deep() 选择器</h2><p><code>:deep()</code> 是 Vue 3 中的深度选择器，用于穿透 scoped CSS 的作用域限制。</p><ol><li>当使用 <code>&lt;style scoped&gt;</code> 时，Vue 会为组件的元素添加一个唯一的属性（如 data-v-hash）</li><li>样式会被编译为带有这个属性选择器的形式，从而将样式限制在当前组件内</li><li>但有时我们需要修改子组件或第三方组件的内部元素样式，这时就需要 <code>:deep()</code></li></ol><ul><li>另外值得注意的事，:deep属性最好选择class，不要选择组件名</li><li>使用示例<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 不使用 :deep 时（只能影响当前组件的元素）</span><br><span class="hljs-selector-class">.tabs</span> <span class="hljs-selector-class">.van-tab</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-comment">// 使用 :deep 后（可以影响子组件内部元素）</span><br><span class="hljs-selector-class">.tabs</span> :<span class="hljs-selector-tag">deep</span>(.van-tab) &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>比如说在vue项目中修改组件中引入的vant组件：<code>:deep(.van-tab--active)</code> 就是为了修改 Vant 组件库中 Tab 组件的激活状态样式。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>create my blog</title>
    <link href="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章讲述搭建博客的原因、过程以及使用hexo的技巧</p></blockquote><span id="more"></span><h2 id="为什么搭建博客？"><a href="#为什么搭建博客？" class="headerlink" title="为什么搭建博客？"></a>为什么搭建博客？</h2><p>学习的步骤可以分为输入、处理、输出三步，每一步都很重要，如果你学完某些内容却没有输出任何东西，那么它带给你受益是微乎其微的，随着时间的流逝，趋近于0；而写博客是一个非常方便的输出方式，写作的过程和内容也能体现出一个人的思考以及体会，更能帮助其更深一步理解所学知识；</p><p>对于一名计算机类专业的学生，我们接受的输入本身就大得多（相较大部分专业）；输出的重要性不言而喻，我下了面从5点论述，为什么写作对于程序员非常重要。</p><ol><li><p>写作&#x3D;协作，良好的写作能力促进人与人之间的交流，让整个团队的知识成果以文档的形式沉淀下来，使得项目更好更久地运行下去以及拓展；在大公司中越是职位越高的人越能出口成章流畅输出观点，他们的影响力也越大</p><div align="center"><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/1730185605407.png" width="300" height="200"></div></li><li><p>写作是学习的催化剂：写作不仅是向别人解释某个概念，它还能帮助我们更深入地思考问题，让思路更清晰；一旦养成写作的习惯，就会慢慢形成正循环。</p><div align="center"><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/1730185650216.png" width="300" height="200"></div></li><li><p>温故而知新：写作需要大量的阅读的资料作为支撑，所以写作也会让你更精确，更注重细节和刨根问底，帮助你复盘学习过程，并揭示看似理解了实际上却并不理解的知识，当你意识到当前的某些知识是在模糊不稳定的基础之上时，你就会开始寻找缺失的部分，获得更深的理解；</p></li><li><p>写代码和写文章有很多共同之处，顶尖的工程师往往也是好的文章作者，他们的文章和代码一样有逻辑性、行文流畅、优雅且工整;</p><center><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/1730190710172.png" width="300" height="200"><img src="/2024/09/23/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/1730190889437.png" width="300" height="200"></center></li><li><p>博客是写文章的一种很好的载体，坚持下去，无论有多少人看，收益最大的人一定是自己；</p></li></ol><ul><li><a href="https://www.bilibili.com/video/BV1eb421e7Ui/?share_source=copy_web&vd_source=7f150cf40745ac06f41469483a60fc41">参考</a></li></ul><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><ul><li>使用hexo搭建博客；具体参考<ul><li><a href="https://zhuanlan.zhihu.com/p/60578464">https://zhuanlan.zhihu.com/p/60578464</a></li><li><a href="https://blog.csdn.net/cat_bayi/article/details/128725230">https://blog.csdn.net/cat_bayi/article/details/128725230</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide">https://fluid-dev.github.io/hexo-fluid-docs/guide</a></li></ul></li></ul><ol><li><p>关联github page的仓存到本地</p></li><li><p>安装hexo</p></li><li><p>配置主题</p><ol><li>选择的是这个：<a href="https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file">https://github.com/fluid-dev/hexo-theme-fluid?tab=readme-ov-file</a></li></ol></li><li><p>安装hexo-deployer-git插件实现自动远程部署：npm install hexo-deployer-git –save</p></li><li><p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p><pre><code class="hljs">  deploy:     type: git     repository: git@github.com:用户名/用户名.github.io.git     branch: main</code></pre></li><li><p>关联域名： <a href="https://github.com/wcool1/wcool1.github.io/settings/pages">打开github上博客仓库的设置</a>: 重新设置Custom domain:[<a href="http://www.tolsz];并开启https;(github给的权益)">www.tolsz];并开启https;(github给的权益)</a></p><ul><li>为什么github pages部署hexo之后每次hexo g -d后关联的域名都会失效,每次都要在github上手动设置吗;<ul><li><a href="https://whybee.blog.csdn.net/article/details/140328361?spm=1001.2014.3001.5502">参考链接</a>：</li></ul><ol><li>不需要，只需要在github的该仓库中创建一个CNAME文件并将域名写入即可；等个1min就好了；但这样再下一次推送后CNAME文件又会失踪；原因如下</li><li>偶然中发现，刚开始还未部署hexo时本地仓库整个文件夹都和远程git仓库是关联同步的，包括CNAME和README.md都是同步的；但是部署hexo之后，远程仓库中只含有博客项目下的.deploy_git下的文件夹；每次更新使用hexo g 会根据本地内容（source中的文件）生成相应页面到pulic中， 然后hexo d进行部署时，会将public中的文件同步deploy_git下同时推送到远程的github仓库；即source下所有的文件内容对应public;比如source&#x2F;A hexo -g之后就会在public&#x2F;A 生成相应内容；</li><li>这也是为什么1中操作下CNAME文件会消失，因为public下没有CNAME文件，所以推送到远端时，自然也没有；解决办法就是在source文件夹下创建CNAME文件添加不含http前缀的域名，然后hexo g -d即可；</li><li>由于dns缓存的原因，每次更新并部署后需要过一会（20s-60s）才能看到新的内容，样式与本地的markdown看到的几乎一样；</li></ol></li></ul></li><li><p>常用命令：</p><pre><code class="hljs">  hexo new &quot;name&quot;       # 新建文章  hexo new page &quot;name&quot;  # 新建页面  hexo g                # 生成页面  hexo d                # 部署  hexo g -d             # 生成页面并部署  hexo s                # 本地预览  hexo clean            # 每次更新前使用：清除缓存文件: 删除 public 文件夹、db.json 文件以及 _config.yml 中配置的 public_dir 目录下的所有文件。确保生成干净的网站文件: 清除缓存后，下次运行 hexo generate 命令时，会重新生成所有网站文件，避免旧文件的影响。这样会导致你直接在Public下对文件做的修改比如更换Img、html等等都会被撤销；因此，强调修改任何东西都是在source、配置文件下才是正确稳妥的；  hexo help             # 帮助</code></pre></li><li><p>基本操作</p><ol><li><p>删除&#x2F;删除页面：直接在本地source &#x2F; _post 文件夹中删除&#x2F;修改相应文件然后hexo clean; hexo g -d即可</p></li><li><p>图片操作：</p><ol><li>插入图片时需要考虑其大小以及排版在此博客系统上的效果，一般使用html标签调整，设置width&#x2F;height为百分比；eg:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://alexcld.com/images/pengyuyan.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;25%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;25%&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>实际上，hexo渲染一篇post的工作流程是：</p><pre><code class="hljs">  拿到一个markdown文件，  根据这个文件的layout类型，  进行样式排版，生成html文件，  最终展示到网页端。</code></pre></li><li><p>发布一篇博客的操作流程</p><ol><li>进入本地git所在根目录</li><li>hexo new ‘title’</li><li>hexo clean</li><li>hexo g -d</li></ol></li></ol></li></ol><h2 id="hexo使用技巧"><a href="#hexo使用技巧" class="headerlink" title="hexo使用技巧"></a>hexo使用技巧</h2><ol><li>设置文章摘要和标签操作举例如下：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">hello</span> <span class="hljs-string">hexo</span> <span class="hljs-string">markdown</span><br><span class="hljs-attr">date:</span> <br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hello</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">我是短小精悍的文章摘要(๑•̀ㅂ•́)</span> <span class="hljs-string">✧</span><br><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><br><span class="hljs-string">紧接着文章摘要的正文内容</span><br><br><br></code></pre></td></tr></table></figure></li><li>资源引用：除了url的绝对引用外，相对引用可以使用 Hexo 提供的资源文件夹功能:使用文本编辑器打开站点根目录下的 _ config.yml 文件，将 post_asset_folder 值设置为 true。Hexo 将会在我们每一次通过 hexo new title 命令创建新文章时自动创建一个同名文件夹，于是我们便可以将文章中所引用的相关资源比如截图放到这个同名文件夹下，然后通过相对路径引用；不针对封面等与文章内容无关的资源；<ol><li>强调一下hexo g时，只会将source目录下的img文件夹、_posts下的new出来的md文件以及资源引用开启后下的同名文件夹下的资源文件复制到public下，其他的文件不会复制到public下；因此直接复制图片粘贴到md中的资源图片，vscode会默认在当前目录下创建一个img&#x2F;{title}文件夹用以存放截图，但是此文件夹不会被hexo g复制到public下，因此需要手动将其复制粘贴一份到资源引用功能开启后的同名（title）文件夹下，然后hexo g -d即可；</li></ol></li><li>分类与标签：<ol><li>二者区别：分类具有顺序性和层次性而标签没有顺序和层次；可忽略不计</li><li>在scaffolds&#x2F;post.md设置默认的文章模板如下，生成之后再加入分类&#x2F;标签即可，分类比较好用：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">标签</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">类别</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li></ol></li><li>自定制、美化博客<ol><li>参考：<ol><li><a href="https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/">https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/</a></li><li><a href="https://blog.csdn.net/weixin_51545953/article/details/128499341">https://blog.csdn.net/weixin_51545953/article/details/128499341</a></li></ol></li><li>配置：包括所有图片、导航栏的title、标题等等都在_conflg.主题.yml中设置,其优先级最高,然后考虑_config.yml;</li><li>修改banner图：<ol><li>在网上查找免费开源的风景图片并下载下来（避免版权纠纷）推荐几个免费开源的图片网站<ol><li><a href="https://pixabay.com/">https://pixabay.com/</a></li><li><a href="https://unsplash.com/">https://unsplash.com/</a></li><li><a href="https://www.pexels.com/">https://www.pexels.com/</a></li></ol></li><li>不知为何在配置中修改默认banner_img的属性不生效，但是可以分步设置各个分页的banner图，<a href="https://s81679.github.io/2020/02/25/hexo-theme-fluid/#%E4%B8%BB%E9%A0%81-Banner-%E5%A4%A7%E5%9C%96">参考</a><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 首页</span><br><span class="hljs-symbol">index:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>banner.jpg  <span class="hljs-meta"># 首页 Banner 头图，以下相同</span><br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">100</span>  <span class="hljs-meta"># 头图高度，屏幕百分比，available: 0 - 100</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-meta"># 文章頁</span><br><span class="hljs-meta"># Archive Page</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-symbol">archive:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>articles.jpg<br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-meta"># available: 0 - 100</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-meta"># 分類頁</span><br><span class="hljs-meta"># Categories Page</span><br><span class="hljs-meta">#---------------------------</span><br><span class="hljs-symbol">category:</span><br><span class="hljs-symbol">    banner_img:</span> <span class="hljs-keyword">/img/</span>categories.jpg<br><span class="hljs-symbol">    banner_img_height:</span> <span class="hljs-number">80</span>  <span class="hljs-meta"># available: 0 - 100</span><br></code></pre></td></tr></table></figure></li></ol></li><li>设置文章在首页中的封面图：<ol><li>设置模版scaffolds&#x2F;post中添加index_img: &#x2F;img&#x2F;cover&#x2F;<code>&#123;&#123; title &#125;&#125;</code>.png；</li><li>在source&#x2F;img下创建cover文件夹,将new的文章的封面移动到其中，并改为{title}.png</li><li>hexo clean ;hexo g -d</li></ol></li><li>同理，banner_img: &#x2F;img&#x2F;cover&#x2F;<code>&#123;&#123; title &#125;&#125; </code>.png设置文章的banner图</li></ol></li></ol><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>图片无法加载<ul><li>参考   <ul><li><a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></li></ul></li><li>解决办法：<ul><li>md文件中的图片路径只能是文件名，并将相应的图片放到其同名文件夹下，也就是说要想在云端能看到图片，那么在本地就看不到；</li><li>谷歌也没有发现更好的办法，也许这就是hexo的bug；</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
